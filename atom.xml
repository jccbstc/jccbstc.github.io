<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>业余的日落患者</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-27T08:18:15.939Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>及川彻</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>凹凸科技2017秋招java工程师笔试</title>
    <link href="http://example.com/2023/03/23/%E7%AC%94%E8%AF%95/%E5%87%B9%E5%87%B8%E7%A7%91%E6%8A%802017%E7%A7%8B%E6%8B%9Bjava%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95/"/>
    <id>http://example.com/2023/03/23/%E7%AC%94%E8%AF%95/%E5%87%B9%E5%87%B8%E7%A7%91%E6%8A%802017%E7%A7%8B%E6%8B%9Bjava%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95/</id>
    <published>2023-03-23T12:03:10.614Z</published>
    <updated>2023-03-27T08:18:15.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="凹凸科技2017秋招java工程师笔试"><a href="#凹凸科技2017秋招java工程师笔试" class="headerlink" title="凹凸科技2017秋招java工程师笔试"></a>凹凸科技2017秋招java工程师笔试</h1><h5 id="1-GC是什么？为什么要有GC？"><a href="#1-GC是什么？为什么要有GC？" class="headerlink" title="1.GC是什么？为什么要有GC？"></a>1.GC是什么？为什么要有GC？</h5><p>正确答案：</p><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">在<span class="hljs-keyword">java语言中，垃圾回收（Garbage </span>Collection，GC）的主要作用是回收程序中不再使用的内存。 为了减轻开发人员的工作，同时增加系统的安全性和稳定性，<span class="hljs-keyword">java语言提供了垃圾回收器来自动检测对象的作用域，可自动地把不再被使用的存储空间释放掉。主要的任务是：分配内存，回收不再被引用的对象的内存空间。 </span>垃圾回收器提高了开发人员的开发效率，保证程序的稳定性，但是也带来了问题，为了处理垃圾回收，垃圾回收器必须跟踪内存的使用情况，释放没用的对象，在完成内存的释放后还需要处理堆中的碎片，这些操作增加<span class="hljs-keyword">JVM的负担，从而降低了程序的执行效率。</span><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="2-简述final，finalize，finally的区别？"><a href="#2-简述final，finalize，finally的区别？" class="headerlink" title="2.简述final，finalize，finally的区别？"></a>2.简述final，finalize，finally的区别？</h5><p>正确答案：</p><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-number">1.</span> <span class="hljs-keyword">final</span>是关键字，<span class="hljs-keyword">final</span>可以修饰类、方法、属性。<br>    如果一个类被<span class="hljs-keyword">final</span>修饰，那么这个类就是最终类，不能派生出新的子类，不能作为父类被继承，该类中的所有方法都不能被重写，但是<span class="hljs-keyword">final</span>类中的成员变量是可以改变的，要想<span class="hljs-keyword">final</span>类中的成员变量的不可以改变，必须给成员变量添加<span class="hljs-keyword">final</span>修饰。因此，一个类不能同时被<span class="hljs-keyword">final</span>和<span class="hljs-keyword">abstract</span>修饰，这两个关键字相互矛盾。<br>    如果<span class="hljs-keyword">final</span>修饰方法，那么这个方法是最终方法，不允许任何子类重写该方法，但子类仍可以使用该方法，注意：<span class="hljs-keyword">final</span>参数用来表示这个参数在这个函数内部不允许被修改。<br>    <span class="hljs-keyword">final</span>修饰属性，被<span class="hljs-keyword">final</span>修饰的变量不可变。这里的不可变有两重含义：引用不可变和对象不可变。<span class="hljs-keyword">final</span>指的是引用不可变，即它只能指向初始化时指向的那个对象，而不关心指向对象内容的变化。因此，被<span class="hljs-keyword">final</span>修饰的变量必须初始化，该变量其实就是常量。<br><span class="hljs-number">2.</span> <span class="hljs-keyword">finally</span>作为异常处理的一部分，只能用在<span class="hljs-keyword">try</span>/<span class="hljs-keyword">catch</span>语句快中，<span class="hljs-keyword">finally</span>代码块中的语句一定会被执行，经常被用来释放资源，如IO流和数据库资源的释放。<br><span class="hljs-number">3.</span> finalize是<span class="hljs-built_in">Object</span>类的一个方法，该方法在<span class="hljs-built_in">Object</span>类中声明：<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span>() <span class="hljs-keyword">throws</span> Throwable { } <br>    在垃圾回收器执行时会调用被回收对象的<span class="hljs-title function_">finalize</span>()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放某个对象占用的空间，将首先调该对象的<br><span class="hljs-title function_">finalize</span>()方法，并且在下一次垃圾回收动作发生时，才真正将该对象占用的内存回收。<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="3-Abstract-class和interface有什么区别？"><a href="#3-Abstract-class和interface有什么区别？" class="headerlink" title="3.Abstract class和interface有什么区别？"></a>3.Abstract class和interface有什么区别？</h5><p>正确答案：</p><table><thead><tr><th></th><th>Abstract class</th><th>Interface</th></tr></thead><tbody><tr><td>实例化</td><td>不能</td><td>不能</td></tr><tr><td>类</td><td>一种继承关系，一个类只能使用一次继承关系。可以通过继承多个接口实现多重继承</td><td>一个类可以实现多个interface</td></tr><tr><td>数据成员</td><td>可有自己的</td><td>静态的不能被修改即必须是static final，一般不在此定义</td></tr><tr><td>方法</td><td>可以私有的，非abstract方法，必须实现</td><td>不可有私有的，默认是public，abstract 类型</td></tr><tr><td>变量</td><td>可有私有的，默认是friendly 型，其值可以在子类中重新定义，也可以重新赋值</td><td>不可有私有的，默认是public static final 型，且必须给其初值，实现类中不能重新定义，不能改变其值。</td></tr><tr><td>设计理念</td><td>表示的是“is-a”关系</td><td>表示的是“like-a”关系</td></tr><tr><td>实现</td><td>需要继承，要用extends</td><td>要用implements</td></tr></tbody></table><p>扩展：java8的接口新特性（可以有方法体的接口）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>{<br>    String <span class="hljs-title function_">myNewName</span><span class="hljs-params">(String newName)</span>;<br> <br>    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">myOldName</span><span class="hljs-params">()</span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"chao"</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="4-Java内存管理"><a href="#4-Java内存管理" class="headerlink" title="4.Java内存管理"></a>4.Java内存管理</h5><p>（1）请描述java的内存管理原理 </p><p>（2）请描述java的内存分区 </p><p>（3）请描述java的对象生命周期，以及对象的访问？</p><p>正确答案：</p><p>（1）请描述java的内存管理原理 </p><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Java的内存管理就是对象的分配和释放</span><br><span class="hljs-keyword"></span>在<span class="hljs-keyword">Java中，内存的分配是由程序完成的，</span><br><span class="hljs-keyword"></span>而内存的释放是由垃圾收集器(Garbage Collection，GC)完成的 <br></code></pre></td></tr></tbody></table></figure><p>（2）请描述java的内存分区 </p><p><img src="/image/v2-7a7c516c0aeb622705c86fd9b5e8c44a_720w.webp"></p><p>（3）请描述java的对象生命周期，以及对象的访问？</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">生命周期：  <br><span class="hljs-number">1</span>.创建阶段(Created)<br><span class="hljs-number">2</span>.应用阶段(In Use)：一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段<br><span class="hljs-number">3</span>.不可见阶段(Invisible)：例如我在for里面定义了<span class="hljs-selector-tag">i</span> for循环break了就不能访问<span class="hljs-selector-tag">i</span><br><span class="hljs-number">4</span>.不可达阶段(Unreachable)：对象处于不可达阶段是指该对象不再被任何强引用所持有。<br><span class="hljs-number">5</span>.收集阶段(Collected)：当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。<br><span class="hljs-number">6</span>.终结阶段(Finalized)：当对象执行完<span class="hljs-built_in">finalize</span>()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。<br><span class="hljs-number">7</span>.对象空间重分配阶段(De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”<br></code></pre></td></tr></tbody></table></figure><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">句柄访问方式：java堆中将划分出一块内存来作为句柄池，<span class="hljs-built_in">ref</span>erence中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。 指针访问方式：<span class="hljs-built_in">ref</span>erence变量中直接存储的就是对象的地址，而java堆对象一部分存储了对象实例数据，另外一部分存储了对象类型数据<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="5-指出以下程序的输出或错误。"><a href="#5-指出以下程序的输出或错误。" class="headerlink" title="5.指出以下程序的输出或错误。"></a>5.指出以下程序的输出或错误。</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>{<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span>{<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">long</span> b)</span>{<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>{<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">char</span> b)</span>{<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>正确答案：</p><figure class="highlight wren"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs wren">    <span class="hljs-title function_">publicvoidmethod</span>(<span class="hljs-params">inta</span>){<br>    }<br>    <span class="hljs-title function_">publicvoidmethod</span>(<span class="hljs-params">intb</span>){<br>    }<br>   <br>方法重载不以返回值类型为判断，重载通过不同的方法参数来区分，如不同的参数个数，不同的参数类型，不同的参数顺序；这<span class="hljs-number">2</span>个方法错误。<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="6-指出以下程序的输出或者错误"><a href="#6-指出以下程序的输出或者错误" class="headerlink" title="6.指出以下程序的输出或者错误"></a>6.指出以下程序的输出或者错误</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>{<br> Person(){<br>   System.out.println(<span class="hljs-string">"create person"</span>);  <br> }<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>{<br>   <span class="hljs-keyword">return</span><span class="hljs-string">"Person"</span>;<br> }<br>}<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>{<br> Teacher(){<br>   System.out.println(<span class="hljs-string">"create teacher"</span>);  <br>   <span class="hljs-built_in">super</span>();<br> }<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>{<br>   <span class="hljs-keyword">return</span><span class="hljs-string">"Teacher"</span>;<br> }<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>{<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{<br>   <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>   <span class="hljs-type">Person</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>   System.out.println(person.getName());<br>   System.out.println(teacher.getName());<br> }<br>}<br></code></pre></td></tr></tbody></table></figure><p>正确答案：</p><figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">super</span>要在构造函数第一行使用<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="7-假设树的节点的data类型为int型，请实现两棵树是否相等的比较？"><a href="#7-假设树的节点的data类型为int型，请实现两棵树是否相等的比较？" class="headerlink" title="7.假设树的节点的data类型为int型，请实现两棵树是否相等的比较？"></a>7.假设树的节点的data类型为int型，请实现两棵树是否相等的比较？</h5><p> 注:A,B两棵树相等且当rootA-&gt;data==rootB-&gt;data，而且A和B的左右子树相等或者左右互换后相等。</p><p> （1）给出树节点的结构定义 </p><p>（2）写出实现思路，以及复杂度估计 </p><p>（3）用你习惯的语言或者伪代码实现该算法</p><p>正确答案：</p><p>（1）给出树节点的结构定义 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> {<br>    <span class="hljs-type">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br><br>    TreeNode() {<br>    }<br><br>    TreeNode(<span class="hljs-type">int</span> val) {<br>        <span class="hljs-built_in">this</span>.val = val;<br>    }<br><br>    TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) {<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>（3）用你习惯的语言或者伪代码实现该算法</p><p>与LeetCode<a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a>相识</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equation</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> {<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span> &amp;&amp; root2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span> || root2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> (root1.val == root2.val)<br>                &amp;&amp; equation(root1.left,root2.left)<br>                &amp;&amp; equation(root1.right,root2.right);<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="8-假设基本数据为整型，输入为一串无序的整数，请用堆排序的方式对该整数串排序（增序），有重复时保留重复的数。"><a href="#8-假设基本数据为整型，输入为一串无序的整数，请用堆排序的方式对该整数串排序（增序），有重复时保留重复的数。" class="headerlink" title="8.假设基本数据为整型，输入为一串无序的整数，请用堆排序的方式对该整数串排序（增序），有重复时保留重复的数。"></a>8.假设基本数据为整型，输入为一串无序的整数，请用堆排序的方式对该整数串排序（增序），有重复时保留重复的数。</h5><p> 测试数据:[3,6,23,4,3,2,9,10,18,11] </p><p>（1）堆排序的思想，使用情况一般是什么？</p><p>（2）算法所需要的数据结构？ </p><p>（3）用你习惯的语言或者伪代码实现你的算法？</p><p>正确答案：</p><p>（1）堆排序的思想，使用情况一般是什么？</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。<br><br>每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。<br></code></pre></td></tr></tbody></table></figure><p>（2）算法所需要的数据结构？</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">使用线性数据结构比如数组就可以实现堆排序<br></code></pre></td></tr></tbody></table></figure><p>（3）用你习惯的语言或者伪代码实现你的算法？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSort</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>};<br>        sort(arr);<br>        System.out.println(Arrays.toString(arr));<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>            adjustHeap(arr, i, arr.length);<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) {<br>            swap(arr, <span class="hljs-number">0</span>, j);<br>            adjustHeap(arr, <span class="hljs-number">0</span>, j);<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; k &lt; length; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) {<br>            <span class="hljs-keyword">if</span> (k + <span class="hljs-number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="hljs-number">1</span>]) {<br>                k++;<br>            }<br>            <span class="hljs-keyword">if</span> (arr[k] &gt; temp) <br>                arr[i] = arr[k];<br>                i = k;<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>        arr[i] = temp;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[a];<br>        arr[a] = arr[b];<br>        arr[b] = temp;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="9-输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和是输入的那个数字，要求时间复杂度为O-n-，如果有多对数字的和等于输入的数字，输出任意一对即可。"><a href="#9-输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和是输入的那个数字，要求时间复杂度为O-n-，如果有多对数字的和等于输入的数字，输出任意一对即可。" class="headerlink" title="9.输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和是输入的那个数字，要求时间复杂度为O(n)，如果有多对数字的和等于输入的数字，输出任意一对即可。"></a>9.输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和是输入的那个数字，要求时间复杂度为O(n)，如果有多对数字的和等于输入的数字，输出任意一对即可。</h5><p>正确答案：</p><p>同LeetCode<a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a>，因题目比LeetCode多一个条件，可用以下方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findAns</span><span class="hljs-params">(<span class="hljs-type">int</span>[] data, <span class="hljs-type">int</span> sum)</span> {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> data.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> size-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (begin &lt; size &amp;&amp; end &gt;=<span class="hljs-number">0</span> &amp;&amp; begin &lt; end) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cu</span> <span class="hljs-operator">=</span> data[begin] + data[end];<br>        <span class="hljs-keyword">if</span> (cu &gt; sum) {<br>            end --;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cu &lt; sum) {<br>            begin ++;<br>        } <span class="hljs-keyword">else</span> {<br>            System.out.println(data[begin] + <span class="hljs-string">" "</span> + data[end]);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>    }<br>    System.out.println(<span class="hljs-string">"无匹配项"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>LeetCode<a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a>解法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) {<br>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) {<br>            <span class="hljs-keyword">if</span> (map.containsKey(target-nums[i])) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{map.get(target-nums[i]),i};<br>            }<br>            map.put(nums[i],i);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{};<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="10-输入一个英文句子，翻转句子中的顺序，但单词内字符的顺序不变，句子中单词以空格隔开，为简单起见。标点符号和普通字母一样处理，例如输入”i-am-a-student”-则输出”student-a-am-I”"><a href="#10-输入一个英文句子，翻转句子中的顺序，但单词内字符的顺序不变，句子中单词以空格隔开，为简单起见。标点符号和普通字母一样处理，例如输入”i-am-a-student”-则输出”student-a-am-I”" class="headerlink" title="10.输入一个英文句子，翻转句子中的顺序，但单词内字符的顺序不变，句子中单词以空格隔开，为简单起见。标点符号和普通字母一样处理，例如输入”i am a student”.则输出”student a am I”"></a>10.输入一个英文句子，翻转句子中的顺序，但单词内字符的顺序不变，句子中单词以空格隔开，为简单起见。标点符号和普通字母一样处理，例如输入”i am a student”.则输出”student a am I”</h5><p>正确答案：</p><p>同LeetCode<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> trimSpaces(s);<br>        <span class="hljs-comment">// 翻转字符串</span><br>        reverse(sb, <span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 翻转每个单词</span><br>        reverseEachWord(sb);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    }<br><br>    <span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title function_">trimSpaces</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="hljs-string">' '</span>) {<br>            ++left;<br>        }<br>        <br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="hljs-string">' '</span>) {<br>            --right;<br>        }<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (left &lt;= right) {<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(left);<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span>) {<br>                sb.append(c);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sb.charAt(sb.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">' '</span>) {<br>                sb.append(c);<br>            }<br><br>            ++left;<br>        }<br>        <span class="hljs-keyword">return</span> sb;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(StringBuilder sb, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> {<br>        <span class="hljs-keyword">while</span> (left &lt; right) {<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> sb.charAt(left);<br>            sb.setCharAt(left++, sb.charAt(right));<br>            sb.setCharAt(right--, tmp);<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(StringBuilder sb)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sb.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (start &lt; n) {<br>            <span class="hljs-keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="hljs-string">' '</span>) {<br>                ++end;<br>            }<br>            reverse(sb, start, end - <span class="hljs-number">1</span>);<br>            start = end + <span class="hljs-number">1</span>;<br>            ++end;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="11-请用java，实现Stack类或者Queue类，支持该数据结构的基本操作。"><a href="#11-请用java，实现Stack类或者Queue类，支持该数据结构的基本操作。" class="headerlink" title="11.请用java，实现Stack类或者Queue类，支持该数据结构的基本操作。"></a>11.请用java，实现Stack类或者Queue类，支持该数据结构的基本操作。</h5><p>正确答案：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> {  <br>         <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">LinkedList</span> <span class="hljs-variable">ll</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();  <br>         <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Object obj)</span>{  <br>                ll.addFirst(obj);  <br>        }  <br>         <br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>{  <br>                <span class="hljs-keyword">return</span> ll.removeFirst();  <br>        }  <br>         <br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>{  <br>                <span class="hljs-keyword">return</span> ll.getFirst();  <br>        }  <br>         <br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span>{  <br>                <span class="hljs-keyword">return</span> ll.isEmpty();  <br>        }  <br>} <br></code></pre></td></tr></tbody></table></figure><hr><h5 id="12-设计线程类WorkThead，其构造函数接收一个message字符串作为参数，把该字符串打印到console上，同时，在WorkThread的main函数中启动该线程"><a href="#12-设计线程类WorkThead，其构造函数接收一个message字符串作为参数，把该字符串打印到console上，同时，在WorkThread的main函数中启动该线程" class="headerlink" title="12.设计线程类WorkThead，其构造函数接收一个message字符串作为参数，把该字符串打印到console上，同时，在WorkThread的main函数中启动该线程"></a>12.设计线程类WorkThead，其构造函数接收一个message字符串作为参数，把该字符串打印到console上，同时，在WorkThread的main函数中启动该线程</h5><p>正确答案：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class WorkThead <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>{<br>    String message;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WorkThead</span><span class="hljs-params">(Stirng message)</span>{<br>        <span class="hljs-built_in">this</span>.message=message;<br>        System.Out.PrintIn(message);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>{<br>         <br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span>{<br>        WorkThead（<span class="hljs-string">"hello world!"</span>）.start();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;凹凸科技2017秋招java工程师笔试&quot;&gt;&lt;a href=&quot;#凹凸科技2017秋招java工程师笔试&quot; class=&quot;headerlink&quot; title=&quot;凹凸科技2017秋招java工程师笔试&quot;&gt;&lt;/a&gt;凹凸科技2017秋招java工程师笔试&lt;/h1&gt;&lt;h5 i</summary>
      
    
    
    
    <category term="笔试" scheme="http://example.com/categories/%E7%AC%94%E8%AF%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="GC" scheme="http://example.com/tags/GC/"/>
    
    <category term="interface" scheme="http://example.com/tags/interface/"/>
    
    <category term="abstract" scheme="http://example.com/tags/abstract/"/>
    
    <category term="线程类" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>点我达2019届校招Java开发笔试</title>
    <link href="http://example.com/2023/03/21/%E7%AC%94%E8%AF%95/%E7%82%B9%E6%88%91%E8%BE%BE2019%E5%B1%8A%E6%A0%A1%E6%8B%9BJava%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%95/"/>
    <id>http://example.com/2023/03/21/%E7%AC%94%E8%AF%95/%E7%82%B9%E6%88%91%E8%BE%BE2019%E5%B1%8A%E6%A0%A1%E6%8B%9BJava%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%95/</id>
    <published>2023-03-21T11:14:07.098Z</published>
    <updated>2023-03-21T11:25:00.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="点我达2019届校招Java开发笔试"><a href="#点我达2019届校招Java开发笔试" class="headerlink" title="点我达2019届校招Java开发笔试"></a>点我达2019届校招Java开发笔试</h1><h5 id="1-统计各部门平均年龄，其中三部门人员平均年龄分别为38岁、24岁、42岁。A和B-两部门人员平均年龄为30岁，B和C两部门人员平均年龄为34岁。这三个部门全体人员的平均年龄为多少岁？"><a href="#1-统计各部门平均年龄，其中三部门人员平均年龄分别为38岁、24岁、42岁。A和B-两部门人员平均年龄为30岁，B和C两部门人员平均年龄为34岁。这三个部门全体人员的平均年龄为多少岁？" class="headerlink" title="1.统计各部门平均年龄，其中三部门人员平均年龄分别为38岁、24岁、42岁。A和B 两部门人员平均年龄为30岁，B和C两部门人员平均年龄为34岁。这三个部门全体人员的平均年龄为多少岁？"></a>1.统计各部门平均年龄，其中三部门人员平均年龄分别为38岁、24岁、42岁。A和B 两部门人员平均年龄为30岁，B和C两部门人员平均年龄为34岁。这三个部门全体人员的平均年龄为多少岁？</h5><p>A. 34</p><p>B. 35</p><p>C. 36</p><p>D. 37</p><p>正确答案：B</p><p>本题考查计算中的平均数。依题设A部门x人,B部门y人, C部门z人，根据“A和B两部门人员平均年龄为30岁”可得：38x+24y=30(x+y)，求得x：y=3：4，x=0.75y;又根据“B和C两部门人员平均年龄为34岁”可得：24y+42z=34(y+z)，求得y：z=4：5，那么，x：y：z=3：4：5，那么设三者人数分别是3a、4a、5a，部门总人数=12a，平均年龄=(38×3a + 24×4a + 42×5a)÷12a，利用尾数法可知，括号内各项相加后尾数为0，只有35乘以12尾数为0。</p><hr><h5 id="2-以下数据结构的说法，错误的是"><a href="#2-以下数据结构的说法，错误的是" class="headerlink" title="2.以下数据结构的说法，错误的是"></a>2.以下数据结构的说法，错误的是</h5><p>A. 红黑树插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn)</p><p>B. B+树插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn)</p><p>C. Hash表插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(n)</p><p>D. 排序链表插入操作的平均时间复杂度为O(n)，最坏时间复杂度为O(n)</p><p>正确答案：C</p><p><img src="/image/105_1411202746369_3.png"></p><p>哈希表插入的时间复杂度与冲突次数有关，O(冲突次数/n)，最好的情况冲突次数为0,直接插入，时间复杂度为O(1)。最坏情况是所有值对应同一个键值，这是冲突次数最多，为0+1+2+3+4+…+(n-1)=n*(n-1)/2,平均比较次数为(n-1)/2,时间复杂度为O(n)</p><hr><h5 id="3-用直接插入排序方法对下面4个序列进行排序-由小到大-元素比较次数最少的是"><a href="#3-用直接插入排序方法对下面4个序列进行排序-由小到大-元素比较次数最少的是" class="headerlink" title="3.用直接插入排序方法对下面4个序列进行排序(由小到大),元素比较次数最少的是"></a>3.用直接插入排序方法对下面4个序列进行排序(由小到大),元素比较次数最少的是</h5><p>A. 88,95,12,88,21,54,23,79</p><p>B. 95,21,79,88,54,23,39,12</p><p>C. 39,54,21,79,88,23,95,12</p><p>D. 12,21,23,39,79,54,88,95</p><p>正确答案：D</p><p>逆序越少的序列，在 直接插入排序 中比较次数是越少的</p><hr><h5 id="4-三个进程A，B，C。单核CPU执行时，需要以下资源。其中优先级高的进程可以抢占CPU资源但不能抢占IO资源。所有任务执行完毕时候，需要多长时间？"><a href="#4-三个进程A，B，C。单核CPU执行时，需要以下资源。其中优先级高的进程可以抢占CPU资源但不能抢占IO资源。所有任务执行完毕时候，需要多长时间？" class="headerlink" title="4.三个进程A，B，C。单核CPU执行时，需要以下资源。其中优先级高的进程可以抢占CPU资源但不能抢占IO资源。所有任务执行完毕时候，需要多长时间？"></a>4.三个进程A，B，C。单核CPU执行时，需要以下资源。其中优先级高的进程可以抢占CPU资源但不能抢占IO资源。所有任务执行完毕时候，需要多长时间？</h5><p><img src="/image/Snipaste_2023-03-21_17-58-02.png"></p><p>A. 170ms</p><p>B. 200ms</p><p>C. 240ms</p><p>D. 270ms</p><p>正确答案：B</p><p><img src="/image/1328940_1521735302471_425DB0E95E3B0B63D006DBDB55AA7538.png">优先级：A&gt;B&gt;C </p><p>  A先I/O后CPU，这时候CPU是空闲的。B先CPU后I/O，C先CPU后I/O，B的优先级比C高，B先进行CPU操作； </p><p>  B执行完CPU操作以后A还在进行I/O操作，这时候C进行CPU操作，B等A的I/O执行完以后再进行操作； </p><p>  C执行完CPU操作以后，A还没执行完I/O操作，C也等着； </p><p>  A执行完I/O操作以后，B比C的优先级高，B进行I/O操作，A进行CPU操作，C等候。 </p><p>  B执行完I/O操作以后，C再操作</p><hr><h5 id="5-针对二分查找算法，假设一个有序数组有-136-个元素，那么要查找到第-10-个元素，-需要比较的元素为"><a href="#5-针对二分查找算法，假设一个有序数组有-136-个元素，那么要查找到第-10-个元素，-需要比较的元素为" class="headerlink" title="5.针对二分查找算法，假设一个有序数组有 136 个元素，那么要查找到第 10 个元素， 需要比较的元素为"></a>5.针对二分查找算法，假设一个有序数组有 136 个元素，那么要查找到第 10 个元素， 需要比较的元素为</h5><p>A. 68,34,17,9,13,11,10</p><p>B. 68,34,17,8,12,10</p><p>C. 69,35,18,10</p><p>D. 68,34,18,9,13,11,10</p><p>正确答案：B</p><p><img src="/image/7670357_1535630115432_53CEA007563557CCA6E2FD0CDA1861DB.jpg"></p><hr><h5 id="6-入栈序列是：a1-a3-a5-a2-a4-a6-出栈序列是：a5-a4-a2-a6-a3-a1，则栈的容量最小是"><a href="#6-入栈序列是：a1-a3-a5-a2-a4-a6-出栈序列是：a5-a4-a2-a6-a3-a1，则栈的容量最小是" class="headerlink" title="6.入栈序列是：a1,a3,a5,a2,a4,a6,出栈序列是：a5,a4,a2,a6,a3,a1，则栈的容量最小是"></a>6.入栈序列是：a1,a3,a5,a2,a4,a6,出栈序列是：a5,a4,a2,a6,a3,a1，则栈的容量最小是</h5><p>A. 5</p><p>B. 3</p><p>C. 6</p><p>D. 4</p><p>正确答案：D</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">1                         1<br>3                        <span class="hljs-number"> 1 </span>3<br>5                        <span class="hljs-number"> 1 </span>3 5<br>-                        <span class="hljs-number"> 1 </span>3                     5<br>2                        <span class="hljs-number"> 1 </span>3 2<br>4                        <span class="hljs-number"> 1 </span>3<span class="hljs-number"> 2 </span>4<br>-                        <span class="hljs-number"> 1 </span>3<span class="hljs-number"> 2 </span>                  4<br>-                        <span class="hljs-number"> 1 </span>3                     2<br>6                        <span class="hljs-number"> 1 </span>3<span class="hljs-number"> 6 </span>             <br>-                        <span class="hljs-number"> 1 </span>3                     6<br>-                        <span class="hljs-number"> 1 </span>                      3<br>-                                                 1<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="7-在现代计算机上，即使是单核单CPU系统，一个程序的死循环bug，也不会导致别的程序完全得不到时间运行，这跟哪些因素有关？"><a href="#7-在现代计算机上，即使是单核单CPU系统，一个程序的死循环bug，也不会导致别的程序完全得不到时间运行，这跟哪些因素有关？" class="headerlink" title="7.在现代计算机上，即使是单核单CPU系统，一个程序的死循环bug，也不会导致别的程序完全得不到时间运行，这跟哪些因素有关？"></a>7.在现代计算机上，即使是单核单CPU系统，一个程序的死循环bug，也不会导致别的程序完全得不到时间运行，这跟哪些因素有关？</h5><p>A. 时钟中断</p><p>B. OS进程（线程）时间片划分</p><p>C. 虚拟内存机制</p><p>D. OS抢占式调度</p><p>正确答案：ABD</p><hr><h5 id="8-Linux-系统中列出当前占用8080端口进程的命令1"><a href="#8-Linux-系统中列出当前占用8080端口进程的命令1" class="headerlink" title="8.Linux 系统中列出当前占用8080端口进程的命令1"></a>8.Linux 系统中列出当前占用8080端口进程的命令1</h5><p>正确答案：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lsof -i:8080<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="9-21点是一种扑克游戏。如果玩家拿到扑克牌的点数总和超过21点则称为爆点，被判失败。其中A牌可以被记为11点或者1点，J-Q-K-都记为10点。如果用一副牌玩游戏（52张牌），玩家手上拿到一个K和6。那他再抽两张牌会爆点的可能性约有多大？"><a href="#9-21点是一种扑克游戏。如果玩家拿到扑克牌的点数总和超过21点则称为爆点，被判失败。其中A牌可以被记为11点或者1点，J-Q-K-都记为10点。如果用一副牌玩游戏（52张牌），玩家手上拿到一个K和6。那他再抽两张牌会爆点的可能性约有多大？" class="headerlink" title="9.21点是一种扑克游戏。如果玩家拿到扑克牌的点数总和超过21点则称为爆点，被判失败。其中A牌可以被记为11点或者1点，J, Q, K 都记为10点。如果用一副牌玩游戏（52张牌），玩家手上拿到一个K和6。那他再抽两张牌会爆点的可能性约有多大？"></a>9.21点是一种扑克游戏。如果玩家拿到扑克牌的点数总和超过21点则称为爆点，被判失败。其中A牌可以被记为11点或者1点，J, Q, K 都记为10点。如果用一副牌玩游戏（52张牌），玩家手上拿到一个K和6。那他再抽两张牌会爆点的可能性约有多大？</h5><p>正确答案：</p><p>93.7% 或 93.8% </p><hr><h5 id="10-已知二叉树的中序遍历结果为MFLEDABKCGHJI，后序遍历结果为FELMDKHGJICBA，则其先序遍历结果为"><a href="#10-已知二叉树的中序遍历结果为MFLEDABKCGHJI，后序遍历结果为FELMDKHGJICBA，则其先序遍历结果为" class="headerlink" title="10.已知二叉树的中序遍历结果为MFLEDABKCGHJI，后序遍历结果为FELMDKHGJICBA，则其先序遍历结果为"></a>10.已知二叉树的中序遍历结果为MFLEDABKCGHJI，后序遍历结果为FELMDKHGJICBA，则其先序遍历结果为</h5><p>正确答案：</p><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ADMLFEBCKIJGH</span><br></code></pre></td></tr></tbody></table></figure><p><img src="/image/794224367_1552819658034_46AB337EAF03E990FA44D325F26F96CF.png"></p><hr><h5 id="11-为了解决进程间的同步和互斥问题，通常采用一种称为信号量机制的方法。若系统中有7个进程共享若干个资源R，每个进程都需要6个资源R，那么使系统不发生死锁的资源R的最少数目是"><a href="#11-为了解决进程间的同步和互斥问题，通常采用一种称为信号量机制的方法。若系统中有7个进程共享若干个资源R，每个进程都需要6个资源R，那么使系统不发生死锁的资源R的最少数目是" class="headerlink" title="11.为了解决进程间的同步和互斥问题，通常采用一种称为信号量机制的方法。若系统中有7个进程共享若干个资源R，每个进程都需要6个资源R，那么使系统不发生死锁的资源R的最少数目是"></a>11.为了解决进程间的同步和互斥问题，通常采用一种称为信号量机制的方法。若系统中有7个进程共享若干个资源R，每个进程都需要6个资源R，那么使系统不发生死锁的资源R的最少数目是</h5><p>正确答案：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">36<br></code></pre></td></tr></tbody></table></figure><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">用银行家算法计算死锁时，假设有m个共享资源，n个进程，每个进程所需的最大资源数为w，那么仅是m&gt;n*(w-<span class="hljs-number">1</span>)时，才会不死锁。如果每个进程所需的资源数不同，则先平均分配，只要有一个进程满足了资源要求，就不会死锁。<br><br>不会发生死锁的资源数m &gt; n * (w-<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-number">7</span> * (<span class="hljs-number">6</span> - <span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-number">7</span> * <span class="hljs-number">5</span> <span class="hljs-operator">=</span> <span class="hljs-number">35</span><br>最少： <span class="hljs-number">36</span>个<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="12-假设某一虚拟存储系统采用先进先出（FIFO）页面淘汰算法，有一个进程在内存中占3页（开始时内存为空），当访问如下页面序列号后1-2-3-1-2-4-2-3-5-3-4-5-6会产生几次缺页"><a href="#12-假设某一虚拟存储系统采用先进先出（FIFO）页面淘汰算法，有一个进程在内存中占3页（开始时内存为空），当访问如下页面序列号后1-2-3-1-2-4-2-3-5-3-4-5-6会产生几次缺页" class="headerlink" title="12.假设某一虚拟存储系统采用先进先出（FIFO）页面淘汰算法，有一个进程在内存中占3页（开始时内存为空），当访问如下页面序列号后1,2,3,1,2,4,2,3,5,3,4,5,6会产生几次缺页"></a>12.假设某一虚拟存储系统采用先进先出（FIFO）页面淘汰算法，有一个进程在内存中占3页（开始时内存为空），当访问如下页面序列号后1,2,3,1,2,4,2,3,5,3,4,5,6会产生几次缺页</h5><p>正确答案：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></tbody></table></figure><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> 依次进入缺页产生次数为<span class="hljs-number">3</span>  接下来<span class="hljs-number">1</span> <span class="hljs-number">2</span> 存在，<span class="hljs-number">4</span>没有 则<span class="hljs-number">1</span>出 现在为<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> ，次数加<span class="hljs-number">1</span>则为<span class="hljs-number">4</span> ，<span class="hljs-number">2</span> <span class="hljs-number">3</span> 存在 <span class="hljs-number">5</span>没有则 <span class="hljs-number">2</span>出，缺页次数加<span class="hljs-number">1</span>后为<span class="hljs-number">5</span>，现在为 <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> ，<span class="hljs-number">5</span>存在，<span class="hljs-number">6</span>没有则<span class="hljs-number">3</span>出现在为 <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> ，缺页次数加<span class="hljs-number">1</span> 为<span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="13-若磁头的当前位置在第100磁道，现在有一磁盘读写请求序列如下：32-286-125-192-28-41-297-413-29-64-80-4。若采用最短寻道时间优先算法，则平均寻道长度是多少？"><a href="#13-若磁头的当前位置在第100磁道，现在有一磁盘读写请求序列如下：32-286-125-192-28-41-297-413-29-64-80-4。若采用最短寻道时间优先算法，则平均寻道长度是多少？" class="headerlink" title="13.若磁头的当前位置在第100磁道，现在有一磁盘读写请求序列如下：32,286,125,192,28,41,297,413,29,64,80,4。若采用最短寻道时间优先算法，则平均寻道长度是多少？"></a>13.若磁头的当前位置在第100磁道，现在有一磁盘读写请求序列如下：32,286,125,192,28,41,297,413,29,64,80,4。若采用最短寻道时间优先算法，则平均寻道长度是多少？</h5><p>正确答案：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">42</span>.<span class="hljs-number">08</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">磁盘最短寻道时间优先算法：<br>从100开始依次搜索顺序：80，64，41，32，29，28，4，125，192，286，297，413<br> 寻道长：20<span class="hljs-string">+16</span><span class="hljs-string">+23</span><span class="hljs-string">+9</span><span class="hljs-string">+3</span><span class="hljs-string">+1</span><span class="hljs-string">+24</span><span class="hljs-string">+121</span><span class="hljs-string">+67</span><span class="hljs-string">+94</span><span class="hljs-string">+11</span><span class="hljs-string">+116</span> <br>                / 12 = 42.08<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="14-用两个栈来实现一个队列，完成队列的Push和Pop操作。-队列中的元素为int类型。"><a href="#14-用两个栈来实现一个队列，完成队列的Push和Pop操作。-队列中的元素为int类型。" class="headerlink" title="14.用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。"></a>14.用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</h5><p>同LeetCode <a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> {<br>    Stack&lt;Integer&gt; sta1,sta2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> {<br>        sta1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        sta2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> {<br>        sta1.push(x);<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (sta2.isEmpty()) {<br>            <span class="hljs-keyword">while</span> (!sta1.isEmpty()) {<br>                sta2.push(sta1.pop());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> sta2.pop();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (sta2.isEmpty()) {<br>            <span class="hljs-keyword">while</span> (!sta1.isEmpty()) {<br>                sta2.push(sta1.pop());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> sta2.peek();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> sta1.isEmpty() &amp;&amp; sta2.isEmpty();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="15-把只包含因子2、3和5的数称作丑数（Ugly-Number）。例如6、8都是丑数，但14不是，因为它包含因子7。-习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。"><a href="#15-把只包含因子2、3和5的数称作丑数（Ugly-Number）。例如6、8都是丑数，但14不是，因为它包含因子7。-习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。" class="headerlink" title="15.把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。"></a>15.把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</h5><p>同LeetCode <a href="https://leetcode.cn/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> dp[a] * <span class="hljs-number">2</span>,n2 = dp[b] * <span class="hljs-number">3</span>,n3 = dp[c] * <span class="hljs-number">5</span>;<br>            dp[i] = Math.min(Math.min(n1,n2),n3);<br>            <span class="hljs-keyword">if</span> (dp[i] == n1) a ++;<br>            <span class="hljs-keyword">if</span> (dp[i] == n2) b ++;<br>            <span class="hljs-keyword">if</span> (dp[i] == n3) c ++;<br>        }<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="16-现在一副54张的扑克牌（2个大王-2个小王），任意抽五张牌，判断是不是顺子。其中A看作1-J为11-Q为12-K为13。另外这里还有个“癞子”规则，就是大王和小王可以代替任何牌。比如：“红心A-黑桃3-小王-大王-方片5”-上面的5张牌就可以变成“1-2-3-4-5”-大小王分别看作2和4-。现在我们要用程序来判断5张牌是不是顺子。为了方便起见-你可以认为大小王是0。"><a href="#16-现在一副54张的扑克牌（2个大王-2个小王），任意抽五张牌，判断是不是顺子。其中A看作1-J为11-Q为12-K为13。另外这里还有个“癞子”规则，就是大王和小王可以代替任何牌。比如：“红心A-黑桃3-小王-大王-方片5”-上面的5张牌就可以变成“1-2-3-4-5”-大小王分别看作2和4-。现在我们要用程序来判断5张牌是不是顺子。为了方便起见-你可以认为大小王是0。" class="headerlink" title="16.现在一副54张的扑克牌（2个大王,2个小王），任意抽五张牌，判断是不是顺子。其中A看作1,J为11,Q为12,K为13。另外这里还有个“癞子”规则，就是大王和小王可以代替任何牌。比如：“红心A,黑桃3,小王,大王,方片5”, 上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4)。现在我们要用程序来判断5张牌是不是顺子。为了方便起见,你可以认为大小王是0。"></a>16.现在一副54张的扑克牌（2个大王,2个小王），任意抽五张牌，判断是不是顺子。其中A看作1,J为11,Q为12,K为13。另外这里还有个“癞子”规则，就是大王和小王可以代替任何牌。比如：“红心A,黑桃3,小王,大王,方片5”, 上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4)。现在我们要用程序来判断5张牌是不是顺子。为了方便起见,你可以认为大小王是0。</h5><p>同LeetCode <a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">面试题61. 扑克牌中的顺子</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isStraight</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">joker</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) joker++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == nums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[joker] &lt; <span class="hljs-number">5</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="17-代码能否保证所有Hello-DWD一定在Done-All-DWD之前输出？如果不能，请尽可能多的提供方法来保证"><a href="#17-代码能否保证所有Hello-DWD一定在Done-All-DWD之前输出？如果不能，请尽可能多的提供方法来保证" class="headerlink" title="17.代码能否保证所有Hello, DWD一定在Done All DWD之前输出？如果不能，请尽可能多的提供方法来保证"></a>17.代码能否保证所有Hello, DWD一定在Done All DWD之前输出？如果不能，请尽可能多的提供方法来保证</h5><p><img src="/image/305066_1534750392503_B5EDEED71BFBF89B70B287FD212A36B7.png"></p><p>正确答案：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">不能。CountDownLatch<span class="hljs-regexp">/线程池await/</span>共享变量等<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="18-代码的输出结果是："><a href="#18-代码的输出结果是：" class="headerlink" title="18.代码的输出结果是："></a>18.代码的输出结果是：</h5><p><img src="/image/305066_1534750278152_FEE897EE5CCF6E31EDE586CBBB9A27C9.png"></p><p>正确答案：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></tbody></table></figure><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">此题考察的是<span class="hljs-keyword">finally</span>抢占<span class="hljs-keyword">return</span>的知识点。<br>当<span class="hljs-keyword">finally</span>里面有<span class="hljs-keyword">return</span>语句时，会执行<span class="hljs-keyword">finally</span>里的<span class="hljs-keyword">return</span>语句而忽略<span class="hljs-keyword">try</span>，<span class="hljs-keyword">catch</span>代码块里的<span class="hljs-keyword">return</span>语句。<br>所以这里不管抛不抛出异常都会执行<span class="hljs-keyword">finally</span>里的<span class="hljs-keyword">return</span>语句。<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="19-代码的输出结果是："><a href="#19-代码的输出结果是：" class="headerlink" title="19.代码的输出结果是："></a>19.代码的输出结果是：</h5><p><img src="/image/305066_1534750195915_7E8C99BB2BBEE41E7A3647118425284E.png"></p><p>正确答案：</p><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">AS</span> <br><span class="hljs-keyword">BS</span> <br><span class="hljs-keyword">AC</span> <br>BC <br><span class="hljs-keyword">AC</span> <br>BC<br></code></pre></td></tr></tbody></table></figure><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">静态语句块、构造语句块和构造函数的执行顺序 <br>静态语句块：在类加载的时候执行（从父类到子类） <br>静态语句块执行完，执行main方法 <br><span class="hljs-keyword">new</span><span class="hljs-type"></span>对象，从上到下先执行构造代码块在执行构造器<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;点我达2019届校招Java开发笔试&quot;&gt;&lt;a href=&quot;#点我达2019届校招Java开发笔试&quot; class=&quot;headerlink&quot; title=&quot;点我达2019届校招Java开发笔试&quot;&gt;&lt;/a&gt;点我达2019届校招Java开发笔试&lt;/h1&gt;&lt;h5 id=&quot;1</summary>
      
    
    
    
    <category term="笔试" scheme="http://example.com/categories/%E7%AC%94%E8%AF%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="智力题" scheme="http://example.com/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
    <category term="红黑树" scheme="http://example.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
    <category term="b+数" scheme="http://example.com/tags/b-%E6%95%B0/"/>
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="银行家算法" scheme="http://example.com/tags/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的迭代遍历</title>
    <link href="http://example.com/2023/03/20/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2023/03/20/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/</id>
    <published>2023-03-20T07:26:28.537Z</published>
    <updated>2023-03-20T07:27:34.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><h3 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="前序遍历（迭代法）"></a>前序遍历（迭代法）</h3><p>想出栈为左右，入栈得为右左</p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> {<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>){<br>            <span class="hljs-keyword">return</span> result;<br>        }<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()){<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            result.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>){<br>                stack.push(node.right);<br>            }<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>){<br>                stack.push(node.left);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="后序遍历（迭代法）"><a href="#后序遍历（迭代法）" class="headerlink" title="后序遍历（迭代法）"></a>后序遍历（迭代法）</h3><p>后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> {<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>){<br>            <span class="hljs-keyword">return</span> result;<br>        }<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()){<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            result.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>){<br>                stack.push(node.left);<br>            }<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>){<br>                stack.push(node.right);<br>            }<br>        }<br>        Collections.reverse(result);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="中序遍历（迭代法）"><a href="#中序遍历（迭代法）" class="headerlink" title="中序遍历（迭代法）"></a>中序遍历（迭代法）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> {<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>){<br>            <span class="hljs-keyword">return</span> result;<br>        }<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()){<br>           <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>){<br>               stack.push(cur);<br>               cur = cur.left;<br>           }<span class="hljs-keyword">else</span>{<br>               cur = stack.pop();<br>               result.add(cur.val);<br>               cur = cur.right;<br>           }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的迭代遍历&quot;&gt;&lt;a href=&quot;#二叉树的迭代遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的迭代遍历&quot;&gt;&lt;/a&gt;二叉树的迭代遍历&lt;/h1&gt;&lt;h3 id=&quot;前序遍历（迭代法）&quot;&gt;&lt;a href=&quot;#前序遍历（迭代法）&quot; class=&quot;he</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="广度优先搜索" scheme="http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>并发类问题3</title>
    <link href="http://example.com/2023/03/12/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%983/"/>
    <id>http://example.com/2023/03/12/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%983/</id>
    <published>2023-03-12T08:25:11.698Z</published>
    <updated>2023-03-12T08:27:48.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发类问题3"><a href="#并发类问题3" class="headerlink" title="并发类问题3"></a>并发类问题3</h1><h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><ul><li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；（单位）</li><li>线程共享本进程的地址空间，而进程之间是独立的地址空间；（地址空间）</li><li>每个进程具备各自的数据空间，进程之间的切换会有较大的开销。进程的上下文切换时间开销远远大于线程上下文切换时间,耗费资源较大,效率要差一些；（资源开销）</li><li>进程的并发性较低,线程的并发性较高；（并发性）</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；（拥有的资源）</li><li>一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮；（崩溃）</li><li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言,除了 CPU 外,系统不会为线程分配内存，线程组之间只能共享资源；（内存空间）</li></ul><h3 id="并行和并发的区别？"><a href="#并行和并发的区别？" class="headerlink" title="并行和并发的区别？"></a>并行和并发的区别？</h3><ul><li>并行：单位时间多个处理器同时处理多个任务。 </li><li>并发：一个处理器处理多个任务，按时间片轮流处理多个任务。</li></ul><h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><p>即便是单核的处理器也会支持多线程，处理器会给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给每个线程的执行时间，一般来说时间片非常的短，所以处理器会不停地切换线程。 </p><p>CPU会通过时间片分配算法来循环执行任务，当前任务执行完一个时间片后会切换到下一个任务，但切换前会保存上一个任务的状态，因为下次切换回这个任务时还要加载这个任务的状态继续执行，从任务保存到在加载的过程就是一次上下文切换。</p><h3 id="Java中守护线程和用户线程的区别？"><a href="#Java中守护线程和用户线程的区别？" class="headerlink" title="Java中守护线程和用户线程的区别？"></a>Java中守护线程和用户线程的区别？</h3><p>任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on) 设置，true则是将该线程设置为守护线程，false则是将该线程设置为用户线程。同时，Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。 </p><p>用户线程：平时使用到的线程均为用户线程。 </p><p>守护线程：用来服务用户线程的线程，例如垃圾回收线程。 </p><p>守护线程和用户线程的区别主要在于Java虚拟机何时离开。 </p><p>用户线程：当任何一个用户线程未结束，Java虚拟机是不会结束的。 </p><p>守护线程：如何只剩守护线程未结束，Java虚拟机结束。</p><h3 id="Java中的死锁、活锁、饥饿有什么区别？"><a href="#Java中的死锁、活锁、饥饿有什么区别？" class="headerlink" title="Java中的死锁、活锁、饥饿有什么区别？"></a>Java中的死锁、活锁、饥饿有什么区别？</h3><p>活锁：任务或者执行者没有被阻塞，由于某些条件没有被满足，导致线程一直重复尝试、失败、尝试、失败。例如，线程1和线程2都需要获取一个资源，但他们同时让其他线程先获取该资源，两个线程一直谦让，最后都无法获取 </p><p>活锁和死锁的区别： </p><ul><li>活锁是在不断地尝试、死锁是在一直等待。 </li><li>活锁有可能自行解开、死锁无法自行解开。</li></ul><p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源， 导致一直无法执行的状态。以打印机打印文件为例，当有多个线程需要打印文件，系统按照短文件优先的策略进行打印，但当短文件的打印任务一直不间断地出现，那长文件的打印任务会被一直推迟，导致饥饿。活锁就是在忙式等待条件下发生的饥饿，忙式等待就是不进入等待状态的等待。 </p><p>产生饥饿的原因： </p><ul><li>高优先级的线程占用了低优先级线程的CPU时间 </li><li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。 </li><li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait()方法)，因为其他线程总是被持续地获得唤醒。 死锁、饥饿的区别：饥饿可自行解开，死锁不行。</li></ul><h3 id="创建线程一共有哪几种方法？"><a href="#创建线程一共有哪几种方法？" class="headerlink" title="创建线程一共有哪几种方法？"></a>创建线程一共有哪几种方法？</h3><ul><li>继承Thread类创建线程 </li><li>实现Runnable接口创建线程 </li><li>使用Callable和Future创建线程 </li><li>使用线程池例如用Executor框架</li></ul><h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3><ul><li>中断：Interrupt方法中断线程 </li><li>使用volatile boolean标志位停止线程：在线程中设置一个boolean标志位，同时用volatile修饰保证可见性，在线程里不断地读取这个值，其他地方可以修改这个boolean值。 </li><li>使用stop()方法停止线程，但该方法已经被废弃。因为这样线程不能在停止前保存数据，会出现数据完整性问题。</li></ul><h3 id="同步方法和同步方法块哪个效果更好？"><a href="#同步方法和同步方法块哪个效果更好？" class="headerlink" title="同步方法和同步方法块哪个效果更好？"></a>同步方法和同步方法块哪个效果更好？</h3><p>同步块更好些，因为它锁定的范围更灵活些，只在需要锁住的代码块锁住相应的对象，而同步方法会锁住整个对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发类问题3&quot;&gt;&lt;a href=&quot;#并发类问题3&quot; class=&quot;headerlink&quot; title=&quot;并发类问题3&quot;&gt;&lt;/a&gt;并发类问题3&lt;/h1&gt;&lt;h3 id=&quot;线程与进程的比较&quot;&gt;&lt;a href=&quot;#线程与进程的比较&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="进程" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发类问题2</title>
    <link href="http://example.com/2023/03/10/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%982/"/>
    <id>http://example.com/2023/03/10/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%982/</id>
    <published>2023-03-10T09:39:32.248Z</published>
    <updated>2023-03-11T09:18:35.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发类问题"><a href="#并发类问题" class="headerlink" title="并发类问题"></a>并发类问题</h1><h3 id="runnable-和-callable-有什么区别？"><a href="#runnable-和-callable-有什么区别？" class="headerlink" title="runnable 和 callable 有什么区别？"></a>runnable 和 callable 有什么区别？</h3><p>相同点： </p><ul><li>两者都是接口 </li><li>两者都需要调用Thread.start启动线程</li></ul><p>不同点： </p><ul><li>callable的核心是call()方法，允许返回值，runnable的核心是run()方法，没有返回值 </li><li>call()方法可以抛出异常，但是run()方法不行 </li><li>callable和runnable都可以应用于executors，thread类只支持runnable</li></ul><h3 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h3><ul><li>调用 start() 方法是用来启动线程的，轮到该线程执行时，会自动调用 run()；直接调用 run() 方法，无法达到启动多线程的目的，相当于主线程线性执行 Thread 对象的 run() 方法。</li><li>一个线程对线的 start() 方法只能调用一次，多次调用会抛出 java.lang.IllegalThreadStateException 异常；run() 方法没有限制。</li></ul><h3 id="线程同步以及线程调度相关的方法有哪些？"><a href="#线程同步以及线程调度相关的方法有哪些？" class="headerlink" title="线程同步以及线程调度相关的方法有哪些？"></a>线程同步以及线程调度相关的方法有哪些？</h3><ul><li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒 某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是 让它们竞争，只有获得锁的线程才能进入就绪状态；</li><li>join()：与sleep()方法一样，是一个可中断的方法，在一个线程中调用另一个线程的join()方法，会使得当前的线程挂起，知直到执行join()方法的线程结束。例如在B线程中调用A线程的join()方法，B线程进入阻塞状态，直到A线程结束或者到达指定的时间。 </li><li>yield()：暂停当前线程，以便其他线程有机会执行，不过不能指定暂停的时间，并且也不能保证当前线程马上停止。yield方法只是将Running状态转变为Runnable状态。</li></ul><h3 id="线程的sleep-方法和yield-方法有什么不同？"><a href="#线程的sleep-方法和yield-方法有什么不同？" class="headerlink" title="线程的sleep()方法和yield()方法有什么不同？"></a>线程的sleep()方法和yield()方法有什么不同？</h3><ul><li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给优先级低的线程以运行的机会，而yield()方法只会给相同优先级或者更高优先级的线程以运行机会。</li><li>线程执行sleep()方法后会转入阻塞状态，所以，执行sleep()方法的线程在指定的时间内肯定不会被执行，而yield()方法只是使当前线程重新回到可执行状态，所以执行yield()方法的线程有可能在进入到可执行状态后马上又被执行。</li><li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常。</li></ul><h3 id="sleep-方法和wait-方法的区别？"><a href="#sleep-方法和wait-方法的区别？" class="headerlink" title="sleep()方法和wait()方法的区别？"></a>sleep()方法和wait()方法的区别？</h3><p>相同点： </p><ul><li>wait()方法和sleep()方法都可以使得线程进入到阻塞状态。 </li><li>wait()和sleep()方法都是可中断方法，被中断后都会收到中断异常。</li></ul><p>不同点： </p><ul><li>wait()是Object的方法，sleep()是Thread的方法。 </li><li>wait()必须在同步方法中进行，sleep()方法不需要。 </li><li>线程在同步方法中执行sleep()方法，不会释放monitor的锁，而wait()方法会释放monitor的锁。 </li><li>sleep()方法在短暂的休眠之后会主动退出阻塞，而wait()方法在没有指定wait时间的情况下需要被其他线程中断才可以退出阻塞。</li></ul><h3 id="wait-方法一般在循环块中使用还是if块中使用？"><a href="#wait-方法一般在循环块中使用还是if块中使用？" class="headerlink" title="wait()方法一般在循环块中使用还是if块中使用？"></a>wait()方法一般在循环块中使用还是if块中使用？</h3><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。</p><h3 id="为什么wait-，notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么wait-，notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？</h3><p>因为wait()暂停的是持有锁的对象，notify()或notifyAll()唤醒的是等待锁的对象。所以wait()、notify()、notifyAll()都需要线程持有锁的对象，进而需要在同步方法或者同步块中被调用。</p><h3 id="为什么Thread类的sleep和yield方法是静态的？"><a href="#为什么Thread类的sleep和yield方法是静态的？" class="headerlink" title="为什么Thread类的sleep和yield方法是静态的？"></a>为什么Thread类的sleep和yield方法是静态的？</h3><p>如果sleep和yield是静态方法，那么不管哪个线程，只要一调用就把自己给sleep、yield了。</p><p>如果sleep和yield是实例方法，一个线程可以获取其他线程对象的引用，然后通过引用调要其他线程的sleep和yield方法，让其他线程让出CPU使用权。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发类问题&quot;&gt;&lt;a href=&quot;#并发类问题&quot; class=&quot;headerlink&quot; title=&quot;并发类问题&quot;&gt;&lt;/a&gt;并发类问题&lt;/h1&gt;&lt;h3 id=&quot;runnable-和-callable-有什么区别？&quot;&gt;&lt;a href=&quot;#runnable-和-call</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>死锁定义及发生的条件</title>
    <link href="http://example.com/2023/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%8F%91%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6/"/>
    <id>http://example.com/2023/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%8F%91%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6/</id>
    <published>2023-03-08T07:20:27.984Z</published>
    <updated>2023-03-08T09:38:16.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁定义及发生的条件"><a href="#死锁定义及发生的条件" class="headerlink" title="死锁定义及发生的条件"></a>死锁定义及发生的条件</h1><p><strong>死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</strong></p><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ul><li>互斥条件；</li><li>持有并等待条件；</li><li>不可剥夺条件；</li><li>环路等待条件；</li></ul><h4 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h4><p>互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</p><p><img src="/image/%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6.webp" alt="互斥条件"></p><h4 id="持有并等待条件"><a href="#持有并等待条件" class="headerlink" title="持有并等待条件"></a>持有并等待条件</h4><p>持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</p><p><img src="/image/%E6%8C%81%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6.webp"></p><h4 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h4><p>不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</p><p><img src="/image/%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6.webp"></p><h4 id="环路等待条件"><a href="#环路等待条件" class="headerlink" title="环路等待条件"></a>环路等待条件</h4><p>环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</p><p>比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。</p><p><img src="/image/%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6.webp" alt="环路等待条件"></p><h3 id="避免死锁问题的发生"><a href="#避免死锁问题的发生" class="headerlink" title="避免死锁问题的发生"></a>避免死锁问题的发生</h3><p>那么避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。</p><p>那什么是资源有序分配法呢？</p><p>线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</p><p>我们使用资源有序分配法的方式来修改前面发生死锁的代码，我们可以不改动线程 A 的代码。</p><p>我们先要清楚线程 A 获取资源的顺序，它是先获取互斥锁 A，然后获取互斥锁 B。</p><p>所以我们只需将线程 B 改成以相同顺序的获取资源，就可以打破死锁了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;死锁定义及发生的条件&quot;&gt;&lt;a href=&quot;#死锁定义及发生的条件&quot; class=&quot;headerlink&quot; title=&quot;死锁定义及发生的条件&quot;&gt;&lt;/a&gt;死锁定义及发生的条件&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="http://example.com/2023/03/07/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/03/07/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2023-03-07T12:51:50.993Z</published>
    <updated>2023-03-08T06:46:38.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><p><img src="/image/v2-7a7c516c0aeb622705c86fd9b5e8c44a_720w.webp"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><p>Program Counter Register 程序计数器（寄存器）<br>作用：是记录下一条 jvm 指令的执行地址行号。<br>特点：</p><ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul><h4 id="2）作用"><a href="#2）作用" class="headerlink" title="2）作用"></a>2）作用</h4><ul><li>解释器会解释指令为机器码交给 cpu 执行，程序计数器会记录下一条指令的地址行号，这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</li><li>多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行。</li></ul><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h4 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li>每个线程运行需要的内存空间，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li></ul><h5 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h5><p>不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</p><h5 id="栈内存分配越大越好吗？"><a href="#栈内存分配越大越好吗？" class="headerlink" title="栈内存分配越大越好吗？"></a>栈内存分配越大越好吗？</h5><p>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</p><h5 id="方法呢的局部变量是否线程安全"><a href="#方法呢的局部变量是否线程安全" class="headerlink" title="方法呢的局部变量是否线程安全"></a>方法呢的局部变量是否线程安全</h5><p>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的<br>如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。</p><h4 id="2）栈内存溢出"><a href="#2）栈内存溢出" class="headerlink" title="2）栈内存溢出"></a>2）栈内存溢出</h4><p>栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 java.lang.stackOverflowError ，使用 -Xss256k 指定栈内存大小！</p><h4 id="3）线程运行诊断"><a href="#3）线程运行诊断" class="headerlink" title="3）线程运行诊断"></a>3）线程运行诊断</h4><p>案例一：cpu 占用过多<br>解决方法：Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高，这时需要定位占用 CPU 过高的线程</p><p>top 命令，查看是哪个进程占用 CPU 过高<br>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过 top 查到的进程号 通过 ps 命令进一步查看是哪个线程占用 CPU 过高<br>jstack 进程 id 通过查看进程中的线程的 nid ，刚才通过 ps 命令看到的 tid 来对比定位，注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>一些带有 native 关键字的方法就是需要 JAVA 去调用本地的C或者C++方法，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h4 id="1）定义-2"><a href="#1）定义-2" class="headerlink" title="1）定义"></a>1）定义</h4><p>Heap 堆</p><ul><li>通过new关键字创建的对象都会被放在堆内存</li></ul><p>特点</p><ul><li>它是线程共享，堆内存中的对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h4 id="2）堆内存溢出"><a href="#2）堆内存溢出" class="headerlink" title="2）堆内存溢出"></a>2）堆内存溢出</h4><p>java.lang.OutofMemoryError ：java heap space. 堆内存溢出<br>可以使用 -Xmx8m 来指定堆内存大小。</p><h4 id="2）堆内存诊断"><a href="#2）堆内存诊断" class="headerlink" title="2）堆内存诊断"></a>2）堆内存诊断</h4><ol><li>jps 工具<br>查看当前系统中有哪些 java 进程</li><li>jmap 工具<br>查看堆内存占用情况 jmap - heap 进程id</li><li>jconsole 工具<br>图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm 工具</li></ol><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h4 id="1）定义-3"><a href="#1）定义-3" class="headerlink" title="1）定义"></a>1）定义</h4><p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区域。方法区域类似于用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它。此规范不强制指定方法区的位置或用于管理已编译代码的策略。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的！</p><h4 id="2）组成"><a href="#2）组成" class="headerlink" title="2）组成"></a>2）组成</h4><p>Hotspot 虚拟机 jdk1.6 1.7 1.8 内存结构图</p><p><img src="/image/20210208112903305.png"></p><h4 id="3）方法区内存溢出"><a href="#3）方法区内存溢出" class="headerlink" title="3）方法区内存溢出"></a>3）方法区内存溢出</h4><ul><li>1.8 之前会导致永久代内存溢出<ul><li>使用 -XX:MaxPermSize=8m 指定永久代内存大小</li></ul></li><li>1.8 之后会导致元空间内存溢出<ul><li>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</li></ul></li></ul><h4 id="4）运行时常量池"><a href="#4）运行时常量池" class="headerlink" title="4）运行时常量池"></a>4）运行时常量池</h4><p>二进制字节码包含（类的基本信息，常量池，类方法定义，包含了虚拟机的指令）<br>首先看看常量池是什么，编译如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>然后使用 javap -v Test.class 命令反编译查看结果。</p><p><img src="/image/20210208124448238.png"></p><p>每条指令都会对应常量池表中一个地址，常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p><p><img src="/image/20210208124525875.png"></p><p><strong>常量池</strong>：<br>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息<br><strong>运行时常量池</strong>：<br>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><h4 id="5）StringTable"><a href="#5）StringTable" class="headerlink" title="5）StringTable"></a>5）StringTable</h4><ul><li>常量池中的字符串仅是符号，只有在被用到时才会转化为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</li></ul><p><strong>intern方法 1.8</strong><br>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败<br>无论放入是否成功，都会返回串池中的字符串对象</li></ul><p>注意：此时如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTable</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"a"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"b"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"b"</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s3.intern();<br>        System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br>        System.out.println(s5 == s3); <span class="hljs-comment">// false</span><br>        System.out.println(s6 == s5); <span class="hljs-comment">// true</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br><span class="hljs-comment">// "a" "b" 被放入串池中，str 则存在于堆内存之中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"b"</span>);<br><span class="hljs-comment">// 调用 str 的 intern 方法，这时串池中没有 "ab" ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 "ab" 是同一个对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">st2</span> <span class="hljs-operator">=</span> str.intern();<br><span class="hljs-comment">// 给 str3 赋值，因为此时串池中已有 "ab" ，则直接将串池中的内容返回</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br><span class="hljs-comment">// 因为堆内存与串池中的 "ab" 是同一个对象，所以以下两条语句打印的都为 true</span><br>System.out.println(str == st2); <span class="hljs-comment">// true</span><br>System.out.println(str == str3); <span class="hljs-comment">// true</span><br>}<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// 此处创建字符串对象 "ab" ，因为串池中还没有 "ab" ，所以将其放入串池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br>        <span class="hljs-comment">// "a" "b" 被放入串池中，str 则存在于堆内存之中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"b"</span>);<br>        <span class="hljs-comment">// 此时因为在创建 str3 时，"ab" 已存在与串池中，所以放入失败，但是会返回串池中的 "ab" </span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str.intern();<br>System.out.println(str == str2); <span class="hljs-comment">// false</span><br>System.out.println(str == str3); <span class="hljs-comment">// false</span><br>System.out.println(str2 == str3); <span class="hljs-comment">// true</span><br>}<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="6）StringTable-的位置"><a href="#6）StringTable-的位置" class="headerlink" title="6）StringTable 的位置"></a>6）StringTable 的位置</h4><p>jdk1.6 StringTable 位置是在永久代中，1.8 StringTable 位置是在堆中。</p><h4 id="7）StringTable-垃圾回收"><a href="#7）StringTable-垃圾回收" class="headerlink" title="7）StringTable 垃圾回收"></a>7）StringTable 垃圾回收</h4><p>-Xmx10m 指定堆内存大小<br>-XX:+PrintStringTableStatistics 打印字符串常量池信息<br>-XX:+PrintGCDetails<br>-verbose:gc 打印 gc 的次数，耗费时间等信息</p><h4 id="8）StringTable-性能调优"><a href="#8）StringTable-性能调优" class="headerlink" title="8）StringTable 性能调优"></a>8）StringTable 性能调优</h4><ul><li>因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间</li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">StringTableSize</span>=桶个数（最少设置为 1009 以上）<br></code></pre></td></tr></tbody></table></figure><ul><li>考虑是否需要将字符串对象入池<br>可以通过 intern 方法减少重复入池</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h4 id="1）定义-4"><a href="#1）定义-4" class="headerlink" title="1）定义"></a>1）定义</h4><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul><h4 id="2）使用直接内存的好处"><a href="#2）使用直接内存的好处" class="headerlink" title="2）使用直接内存的好处"></a>2）使用直接内存的好处</h4><p>文件读写流程：</p><p><img src="/image/20210208180041113.png"></p><p>因为 java 不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 然后在将系统缓冲区数据，复制到 java 堆内存中。缺点是数据存储了两份，在系统内存中有一份，java 堆中有一份，造成了不必要的复制。</p><p><strong>使用了 DirectBuffer 文件读取流程</strong></p><p><img src="/image/20210208181022863.png"></p><p>直接内存是操作系统和 Java 代码都可以访问的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。</p><h4 id="3）直接内存的回收机制总结"><a href="#3）直接内存的回收机制总结" class="headerlink" title="3）直接内存的回收机制总结"></a>3）直接内存的回收机制总结</h4><ul><li><p>使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用freeMemory 方法</p></li><li><p>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存</p></li></ul><p><strong>注意：</strong></p><p>一般用 jvm 调优时，会加上下面的参数：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-XX:+DisableExplicitGC  <span class="hljs-regexp">//</span> 静止显示的 GC<br></code></pre></td></tr></tbody></table></figure><p>意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构&quot;&gt;&lt;/a&gt;JVM内存结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/image/v2-7a7c516c0aeb622705c86fd9b5e8c4</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>进程间的通信方式</title>
    <link href="http://example.com/2023/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2023/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2023-03-06T12:28:36.396Z</published>
    <updated>2023-03-08T09:37:55.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>分为<strong>匿名管道</strong>和<strong>命名管道</strong></p><p><strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p><p><strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。它的好处，就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p><p><strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，<strong>管道传输的数据是无格式的流且大小受限</strong>。</p><p><strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p><strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。</p><p><strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以<strong>每个消息体都是固定大小的存储块</strong>，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><p>需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>进程有三种方式响应信号</strong></p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 <strong>TCP 协议</strong>的通信方式，一个是基于 <strong>UDP 协议</strong>的通信方式，一个是<strong>本地进程间</strong>通信方式。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程间的通信方式&quot;&gt;&lt;a href=&quot;#进程间的通信方式&quot; class=&quot;headerlink&quot; title=&quot;进程间的通信方式&quot;&gt;&lt;/a&gt;进程间的通信方式&lt;/h1&gt;&lt;h2 id=&quot;管道&quot;&gt;&lt;a href=&quot;#管道&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="进程" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发类问题</title>
    <link href="http://example.com/2023/02/26/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/02/26/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%98/</id>
    <published>2023-02-26T13:03:50.024Z</published>
    <updated>2023-03-11T09:17:52.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发类问题"><a href="#并发类问题" class="headerlink" title="并发类问题"></a>并发类问题</h1><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><h5 id="六种状态及转换"><a href="#六种状态及转换" class="headerlink" title="六种状态及转换"></a>六种状态及转换</h5><p><img src="/image/image-20210831090722658.png"></p><ul><li>新建<ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></li><li>可运行<ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></li><li>终结<ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li><li>此时会取消与底层线程关联</li></ul></li><li>阻塞<ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></li><li>等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></li><li>有时限等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></li></ul><p><em><strong>其它情况（了解）</strong></em></p><ul><li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li><li>park，unpark 等方法也可以让线程等待和唤醒</li></ul><h5 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h5><p>五种状态的说法来自于操作系统层面的划分</p><p><img src="/image/Snipaste_2023-02-26_17-30-45.png"></p><p><img src="/image/image-20210831092652602.png"></p><ul><li>运行态：分到 cpu 时间，能真正执行线程内代码的</li><li>就绪态：有资格分到 cpu 时间，但还未轮到它的</li><li>阻塞态：没资格分到 cpu 时间的<ul><li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li><li>多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等</li></ul></li><li>新建与终结态：与 java 中同名状态类似</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>七大参数</strong></p><ol><li>corePoolSize <strong>核心线程数目</strong> - 池中会保留的最多线程数</li><li>maximumPoolSize <strong>最大线程数目</strong> - 核心线程+救急线程的最大数目</li><li>keepAliveTime <strong>生存时间</strong> - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit <strong>时间单位</strong> - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue <strong>阻塞队列</strong> - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory <strong>线程工厂</strong> - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler <strong>拒绝策略</strong> - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol><li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li><li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li><li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li><li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li></ol></li></ol><p><img src="/image/image-20210831093204388.png"></p><h3 id="wait-vs-sleep"><a href="#wait-vs-sleep" class="headerlink" title="wait vs sleep"></a>wait vs sleep</h3><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li><p>语法使用不同</p><ul><li>wait 方法必须配合 synchronized 一起使用，不然在运行时就会抛出 IllegalMonitorStateException 的异常</li></ul></li><li><p>方法归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒。</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同（重点）</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制(同第一条)</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul><h3 id="lock-vs-synchronized"><a href="#lock-vs-synchronized" class="headerlink" title="lock vs synchronized"></a>lock vs synchronized</h3><p><strong>三个层面</strong></p><p>不同点</p><ul><li>语法层面<ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li></ul></li><li>功能层面<ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul></li><li>性能层面<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul></li></ul><p><strong>公平锁</strong></p><ul><li>公平锁的公平体现<ul><li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li><li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li><li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li></ul></li><li>公平锁会降低吞吐量，一般不用</li></ul><p><strong>条件变量</strong></p><ul><li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</li><li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ul><li>掌握线程安全要考虑的三个问题</li><li>掌握 volatile 能解决哪些问题</li></ul><p><strong>原子性</strong></p><ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li></ul><p><strong>可见性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li></ul><p><strong>有序性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li><li>注意：<ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul></li></ul><h3 id="Hashtable-vs-ConcurrentHashMap"><a href="#Hashtable-vs-ConcurrentHashMap" class="headerlink" title="Hashtable vs ConcurrentHashMap"></a>Hashtable vs ConcurrentHashMap</h3><ul><li><p>Hashtable 与 ConcurrentHashMap 的区别</p></li><li><p>ConcurrentHashMap 在不同版本的实现区别</p></li></ul><p><strong>Hashtable 对比 ConcurrentHashMap</strong></p><ul><li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li><li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li><li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li></ul><p><strong>ConcurrentHashMap 1.7</strong></p><ul><li>数据结构：<code>Segment(大数组) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li><li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。<strong>Segment 数组不能扩容</strong>，意味着并发度在 ConcurrentHashMap 创建时就固定了</li><li>索引计算<ul><li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li><li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li></ul></li><li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，<strong>每次扩容翻倍</strong></li><li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li></ul><p><strong>ConcurrentHashMap 1.8</strong></p><ul><li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li><li>并发度：Node 数组有多大，并发度就有多大，<strong>与 1.7 不同，Node 数组可以扩容</strong></li><li>扩容条件：<strong>Node 数组满 3/4 时就会扩容</strong></li><li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode</li><li>扩容时并发 get<ul><li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li><li>如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变</li><li>如果链表最后几个元素扩容后索引不变，则节点无需复制</li></ul></li><li>扩容时并发 put<ul><li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li><li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li><li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li></ul></li><li>与 1.7 相比是懒惰初始化</li><li>capacity 代表预估的元素个数，capacity / factory 来计算出初始数组大小，需要贴近 $2^n$ </li><li>loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3/4</li><li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul><li>ThreadLocal 的作用与原理</li><li>ThreadLocal 的内存释放时机</li></ul><p><strong>作用</strong></p><ul><li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ul><p><strong>原理</strong></p><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p>ThreadLocalMap 的一些特点</p><ul><li>key 的 hash 值统一分配</li><li><strong>初始容量 16，扩容因子 2/3，扩容容量翻倍</strong></li><li>key 索引冲突后用开放寻址法解决冲突</li></ul><p><strong>弱引用 key</strong></p><p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p><ul><li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li></ul><p><strong>内存释放时机</strong></p><ul><li>被动 GC 释放 key<ul><li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li></ul></li><li>懒惰被动释放 value<ul><li>get key 时，发现是 null key，则释放其 value 内存</li><li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li></ul></li><li>主动 remove 释放 key，value<ul><li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li><li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发类问题&quot;&gt;&lt;a href=&quot;#并发类问题&quot; class=&quot;headerlink&quot; title=&quot;并发类问题&quot;&gt;&lt;/a&gt;并发类问题&lt;/h1&gt;&lt;h3 id=&quot;线程状态&quot;&gt;&lt;a href=&quot;#线程状态&quot; class=&quot;headerlink&quot; title=&quot;线程状态&quot;</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://example.com/2023/02/23/%E5%9F%BA%E7%A1%80/HashMap/"/>
    <id>http://example.com/2023/02/23/%E5%9F%BA%E7%A1%80/HashMap/</id>
    <published>2023-02-23T05:36:17.271Z</published>
    <updated>2023-03-11T09:13:49.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h4 id="底层数据结构，1-7与1-8有何不同？"><a href="#底层数据结构，1-7与1-8有何不同？" class="headerlink" title="底层数据结构，1.7与1.8有何不同？"></a>底层数据结构，1.7与1.8有何不同？</h4><p>1.7数组+链表，1.8数组+（链表|红黑树）</p><h4 id="为何要用红黑树，为何一上来不树化？"><a href="#为何要用红黑树，为何一上来不树化？" class="headerlink" title="为何要用红黑树，为何一上来不树化？"></a>为何要用红黑树，为何一上来不树化？</h4><p>红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应当是偶然情况<br>hash表的查找，更新的时间复杂度是0(1），而红黑树的查找，更新的时间复杂度是0(log2n)，TreeNode 占用空间也比普通Node的大，如非必要，尽量还是使用链表</p><h4 id="树化阈值为何是8"><a href="#树化阈值为何是8" class="headerlink" title="树化阈值为何是8"></a>树化阈值为何是8</h4><p> hash值如果足够随机，则在hash表内按泊松分布，在负载因子0.75的情况下，长度超过8的链表出现概率是<br>0.00000006，选择8就是为了让树化几率足够小</p><h4 id="何时会树化"><a href="#何时会树化" class="headerlink" title="何时会树化"></a>何时会树化</h4><p>树化两个条件：链表长度超过树化阈值；数组容量 &gt;=64</p><h4 id="何时会退化为链表？"><a href="#何时会退化为链表？" class="headerlink" title="何时会退化为链表？"></a>何时会退化为链表？</h4><p>退化情况1：在扩容时如果拆分树时，树元素个数&lt;=6则会退化链表，<br>退化情况2：remove树节点时，若root、root.left、root.right、root.left.left有一个为 null，也会退化为链表</p><h4 id="索引如何计算？"><a href="#索引如何计算？" class="headerlink" title="索引如何计算？"></a>索引如何计算？</h4><p>计算对象的hashCode()，再进行调用HashMap的hash()方法进行二次哈希，最后&amp;(capacity-1)得到索引</p><h4 id="hashCode都有了，为何还要提供hash-）方法？"><a href="#hashCode都有了，为何还要提供hash-）方法？" class="headerlink" title="hashCode都有了，为何还要提供hash(）方法？"></a>hashCode都有了，为何还要提供hash(）方法？</h4><p>二次hash(）是为了综合高位数据，让哈希分布更为均匀</p><h4 id="数组容量为何是2的n次幂？"><a href="#数组容量为何是2的n次幂？" class="headerlink" title="数组容量为何是2的n次幂？"></a>数组容量为何是2的n次幂？</h4><p>计算索引时，如果是2的n次幂可以使用位与运算代替取模，效率更高；扩容时 hash&amp;oldCap==0的元素留在原来位置，否则新位置=旧位置+oldCap</p><p>都是为了配合容量为2的n次幂时的优化手段，例如Hashtable的容量就不是2的n次幂，并不能说哪种设计更<br>优，应该是设计者综合了各种因素，最终选择了使用2的n次幂作为容量</p><h4 id="介绍一下put方法流程，1-7与1-8有何不同"><a href="#介绍一下put方法流程，1-7与1-8有何不同" class="headerlink" title="介绍一下put方法流程，1.7与1.8有何不同?"></a>介绍一下put方法流程，1.7与1.8有何不同?</h4><p>1.HashMap是懒惰创建数组的，首次使用才创建数组</p><p>2.计算索引(桶下标)</p><p>3.如果桶下标还没人占用，创建Node占位返回</p><p>4.如果桶下标已经有人占用</p><p>​已经是TreeNode走红黑树的添加或更新逻辑</p><p>​是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</p><p>5.返回前检查容量是否超过阈值，一旦超过进行扩容</p><p>6.不同</p><p>​链表插入节点时，1.7是头插法，1.8是尾插法</p><p>​1.7是大于等于阈值且没有空位时才扩容，而1.8是大于阈值就扩容</p><h4 id="1-8在扩容计算Node索引时，会优化加载因子为何默认是0-75f"><a href="#1-8在扩容计算Node索引时，会优化加载因子为何默认是0-75f" class="headerlink" title="1.8在扩容计算Node索引时，会优化加载因子为何默认是0.75f"></a>1.8在扩容计算Node索引时，会优化加载因子为何默认是0.75f</h4><p>在空间占用与查询时间之间取得较好的权衡</p><p>大于这个值，空间节省了，但链表就会比较长影响性能</p><p>小于这个值，冲突减少了，但扩容就会更频繁，空间占用多</p><h4 id="多线程下会有啥问题"><a href="#多线程下会有啥问题" class="headerlink" title="多线程下会有啥问题?"></a>多线程下会有啥问题?</h4><p>扩容死链（1.7)</p><p>数据错乱（1.7，1.8)</p><h4 id="key能否为null，作为key的对象有什么要求"><a href="#key能否为null，作为key的对象有什么要求" class="headerlink" title="key能否为null，作为key的对象有什么要求?"></a>key能否为null，作为key的对象有什么要求?</h4><p>1.HashMap 的 key可以为null，但 Map 的其他实现则不然</p><p>2.作为key的对象，必须实现 hashCode和equals，并且 key的内容不能修改（不可变)</p><h4 id="String对象的-hashCode-如何设计的，为啥每次乘的是31"><a href="#String对象的-hashCode-如何设计的，为啥每次乘的是31" class="headerlink" title="String对象的 hashCode()如何设计的，为啥每次乘的是31"></a>String对象的 hashCode()如何设计的，为啥每次乘的是31</h4><p>目标是达到较为均匀的散列效果，每个字符串的hashCode足够独特</p><p>1.字符串中的每个字符都可以表现为一个数字，称为Sj，其中i的范围是0~n - 1</p><p>2.散列公式为:So* 31n-1+ S1* 31n-2+ … Si * 31n-1-i + …Sn-1 * 310</p><p>3.31代入公式有较好的散列特性，并且31*h可以被优化为</p><p>​即32 * h - h</p><p>​即25 * h - h</p><p>​即h &lt;&lt; 5 - h</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h1&gt;&lt;h4 id=&quot;底层数据结构，1-7与1-8有何不同？&quot;&gt;&lt;a href=&quot;#底层数据结构，1-7与1-8</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="HashMap" scheme="http://example.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList的扩容规则,FailFast与FailSafe</title>
    <link href="http://example.com/2023/02/21/%E5%9F%BA%E7%A1%80/ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99,FailFast%E4%B8%8EFailSafe/"/>
    <id>http://example.com/2023/02/21/%E5%9F%BA%E7%A1%80/ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99,FailFast%E4%B8%8EFailSafe/</id>
    <published>2023-02-21T12:43:04.840Z</published>
    <updated>2023-03-11T09:15:22.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList的扩容规则-FailFast与FailSafe"><a href="#ArrayList的扩容规则-FailFast与FailSafe" class="headerlink" title="ArrayList的扩容规则,FailFast与FailSafe"></a>ArrayList的扩容规则,FailFast与FailSafe</h1><h2 id="ArrayList的扩容规则"><a href="#ArrayList的扩容规则" class="headerlink" title="ArrayList的扩容规则"></a>ArrayList的扩容规则</h2><p><img src="/image/Snipaste_2023-02-21_20-18-44.png"></p><p>ArrayList无参构造源码</p><p>创建时是一个为空的数组，第一次添加元素的时候才分配容量为10的内存</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>}<br></code></pre></td></tr></tbody></table></figure><p>ArrayList有参构造源码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> {<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) {<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"Illegal Capacity: "</span>+<br>                                           initialCapacity);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>add()扩容不是直接乘以1.5，先用位运算&gt;&gt;1，然后加上本身</p><figure class="highlight node-repl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">15</span>*<span class="hljs-number">1.5</span></span><br>&lt; 22.5<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">15</span>&gt;&gt;<span class="hljs-number">1</span></span><br>&lt; 7<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">7</span>+<span class="hljs-number">15</span></span><br>&lt; 22<br></code></pre></td></tr></tbody></table></figure><h2 id="FailFast与FailSafe"><a href="#FailFast与FailSafe" class="headerlink" title="FailFast与FailSafe"></a>FailFast与FailSafe</h2><p><img src="/image/Snipaste_2023-02-22_16-18-08.png"></p><h3 id="FailFast"><a href="#FailFast" class="headerlink" title="FailFast:"></a>FailFast:</h3><p>ArrayList源码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; {<br>    <span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> cursor != size;<br>    }<br><br>    <span class="hljs-meta">@SuppressWarnings("unchecked")</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> {<br>        checkForComodification();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        checkForComodification();<br><br>        <span class="hljs-keyword">try</span> {<br>            ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>            cursor = lastRet;<br>            lastRet = -<span class="hljs-number">1</span>;<br>            expectedModCount = modCount;<br>        } <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        }<br>    }<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>checkForComodification这个方法，它是在<strong>modCount != expectedModCount的时候抛出的异常</strong>，而在next方法中第一句就是checkForComodification，所以遍历集合才会可能抛出并发修改异常。</p><p>而且，在创建一个迭代器后，expectedModCount的初始值就是modCount了，对集合修改只会改变modCount，expectedModCount只会在迭代器的remove方法中被修改为modCountt</p><p>ArrayList的其他方法</p><p>remove：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> {<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) {<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) {<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>fastRemove中对modCount++了，所以后面modCount会和expectedModCount不相等，进而抛出并发修改异常。</p><p>add：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> {<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在ensureCapacityInternal方法里对modCount++了。</p><p>set：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> {<br>    rangeCheck(index);<br><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    elementData[index] = element;<br>    <span class="hljs-keyword">return</span> oldValue;<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看出set方法并没有对modCount++，所以对集合的某个元素进行修改并不会fail-fast</p><h3 id="FailSafe"><a href="#FailSafe" class="headerlink" title="FailSafe:"></a>FailSafe:</h3><p>ArrayList使用fail-fast机制自然是因为它增强了数据的安全性。但在某些场景，我们可能想避免fail-fast机制抛出的异常，这时我们就要将ArrayList替换为使用fail-safe机制的CopyOnWriteArrayList。</p><p><strong>写时复制</strong>，简单理解就是，当我们往一个容器添加元素的时候，先将当前容器复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> {<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> {<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    } <span class="hljs-keyword">finally</span> {<br>        lock.unlock();<br>    }<br>}<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArray</span><span class="hljs-params">(Object[] a)</span> {<br>    array = a;<br>}<br></code></pre></td></tr></tbody></table></figure><p>添加的时候是需要加锁的，否则多线程写的时候会复制出N个副本出来……</p><p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p><p>CopyOnWrite的应用场景：CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p><p>CopyOnWrite的缺点：CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下：</p><h3 id="如何避免fail-fast抛异常？"><a href="#如何避免fail-fast抛异常？" class="headerlink" title="如何避免fail-fast抛异常？"></a><strong>如何避免fail-fast抛异常？</strong></h3><p>1.如果非要在遍历的时候修改集合，那么建议用迭代器的remove等方法，而不是用集合的remove等方法。</p><p>2.如果是并发的环境，那还要对Iterator对象加锁；也可以直接使用Collections.synchronizedList。</p><p>3.CopyOnWriteArrayList（采用fail-safe）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ArrayList的扩容规则-FailFast与FailSafe&quot;&gt;&lt;a href=&quot;#ArrayList的扩容规则-FailFast与FailSafe&quot; class=&quot;headerlink&quot; title=&quot;ArrayList的扩容规则,FailFast与Fail</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ArrayList" scheme="http://example.com/tags/ArrayList/"/>
    
    <category term="迭代器" scheme="http://example.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
    <category term="CopyOnWrite" scheme="http://example.com/tags/CopyOnWrite/"/>
    
  </entry>
  
  <entry>
    <title>位运算技巧</title>
    <link href="http://example.com/2023/02/05/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2023/02/05/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/</id>
    <published>2023-02-05T05:18:38.235Z</published>
    <updated>2023-02-05T05:20:41.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算技巧"><a href="#位运算技巧" class="headerlink" title="位运算技巧"></a>位运算技巧</h1><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><ul><li><p>&amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0，如<br>  1 0 0 1 1<br>&amp;  1 1 0 0 1<br><code>------------------------------</code><br>  1 0 0 0 1 </p></li><li><p>| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如<br>  1 0 0 1 1<br>|   1 1 0 0 1<br><code>------------------------------</code><br>  1 1 0 1 1 </p></li><li><p>^ 异或运算，两个位相同则为 0，不同则为 1，如<br>  1 0 0 1 1<br>^  1 1 0 0 1<br><code>-----------------------------</code><br>  0 1 0 1 0 </p></li><li><p>~ 取反运算，0 则变为 1，1 则变为 0，如<br>~   1 0 0 1 1<br><code>-----------------------------</code><br>   0 1 1 0 0 </p></li><li><p>&lt;&lt; 左移运算，向左进行移位操作，高位丢弃，低位补 0，如</p></li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">int a = 8;<br>a &lt;&lt; 3;<br>移位前：0000 0000 0000 0000 0000 0000 0000 1000<br>移位后：0000 0000 0000 0000 0000 0000 0100 0000<br></code></pre></td></tr></tbody></table></figure><p>&gt;&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，</p><p>无符号右移：&gt;&gt;&gt;，将二进制向右移动1位，最左边用0填补如</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">unsigned int a = 8;<br>a &gt;&gt; 3;<br>移位前：0000 0000 0000 0000 0000 0000 0000 1000<br>移位后：0000 0000 0000 0000 0000 0000 0000 0001<br><br>int a = -8;<br>a &gt;&gt; 3;<br>移位前：1111 1111 1111 1111 1111 1111 1111 1000<br>移位前：1111 1111 1111 1111 1111 1111 1111 1111<br></code></pre></td></tr></tbody></table></figure><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><h3 id="1-位操作实现乘除法"><a href="#1-位操作实现乘除法" class="headerlink" title="1. 位操作实现乘除法"></a>1. 位操作实现乘除法</h3><ul><li>数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">int a = 2;<br>a &gt;&gt; 1; ---&gt; 1<br>a &lt;&lt; 1; ---&gt; 4<br></code></pre></td></tr></tbody></table></figure><h3 id="2-位操作交货两数"><a href="#2-位操作交货两数" class="headerlink" title="2. 位操作交货两数"></a>2. 位操作交货两数</h3><ul><li>位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">//普通操作<br>void swap(int &amp;a, int &amp;b) {<br>  a = a + b;<br>  b = a - b;<br>  a = a - b;<br>}<br><br>//位与操作<br>void swap(int &amp;a, int &amp;b) {<br>  a ^= b;<br>  b ^= a;<br>  a ^= b;<br>}<br></code></pre></td></tr></tbody></table></figure><p>位与操作解释：第一步：a ^= b —&gt; a = (a^b); </p><p>第二步：b ^= a —&gt; b = b^(a^b) —&gt; b = (b^b)^a = a</p><p>第三步：a ^= b —&gt; a = (a^b)^a = (a^a)^b = b</p><h3 id="3-位操作判断奇偶数"><a href="#3-位操作判断奇偶数" class="headerlink" title="3. 位操作判断奇偶数"></a>3. 位操作判断奇偶数</h3><ul><li>只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if(0 == (a &amp; 1)) {<br> //偶数<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-位操作交换符号"><a href="#4-位操作交换符号" class="headerlink" title="4. 位操作交换符号"></a>4. 位操作交换符号</h3><ul><li>交换符号将正数变成负数，负数变成正数</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">int reversal(int a) {<br>  return ~a + 1;<br>}<br></code></pre></td></tr></tbody></table></figure><p>整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</p><h3 id="5-位操作求绝对值"><a href="#5-位操作求绝对值" class="headerlink" title="5. 位操作求绝对值"></a>5. 位操作求绝对值</h3><ul><li>整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 <strong>0xffffffff</strong>），然后根据符号进行相应的操作</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">int abs(int a) {<br>  int i = a &gt;&gt; 31;<br>  return i == 0 ? a : (~a + 1);<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面的操作可以进行优化，可以将 i == 0 的<strong>条件判断</strong>语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">int abs2(int a) {<br>  int i = a &gt;&gt; 31;<br>  return ((a^i) - i);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="6-利用或操作-和空格将英文字符转换为小写"><a href="#6-利用或操作-和空格将英文字符转换为小写" class="headerlink" title="6.利用或操作 | 和空格将英文字符转换为小写"></a>6.利用或操作 <code>|</code> 和空格将英文字符转换为小写</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-string">'a'</span> | <span class="hljs-string">' '</span>) = <span class="hljs-string">'a'</span><br>(<span class="hljs-string">'A'</span> | <span class="hljs-string">' '</span>) = <span class="hljs-string">'a'</span><br></code></pre></td></tr></tbody></table></figure><h3 id="7-利用与操作-amp-和下划线将英文字符转换为大写"><a href="#7-利用与操作-amp-和下划线将英文字符转换为大写" class="headerlink" title="7.利用与操作 &amp; 和下划线将英文字符转换为大写"></a>7.利用与操作 <code>&amp;</code> 和下划线将英文字符转换为大写</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-string">'b'</span> &amp; <span class="hljs-string">'_'</span>) = <span class="hljs-string">'B'</span><br>(<span class="hljs-string">'B'</span> &amp; <span class="hljs-string">'_'</span>) = <span class="hljs-string">'B'</span><br></code></pre></td></tr></tbody></table></figure><h3 id="8-利用异或操作-和空格进行英文字符大小写互换"><a href="#8-利用异或操作-和空格进行英文字符大小写互换" class="headerlink" title="8.利用异或操作 ^ 和空格进行英文字符大小写互换"></a>8.利用异或操作 <code>^</code> 和空格进行英文字符大小写互换</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-string">'d'</span> ^ <span class="hljs-string">' '</span>) = <span class="hljs-string">'D'</span><br>(<span class="hljs-string">'D'</span> ^ <span class="hljs-string">' '</span>) = <span class="hljs-string">'d'</span><br></code></pre></td></tr></tbody></table></figure><h3 id="9-判断两个数是否异号"><a href="#9-判断两个数是否异号" class="headerlink" title="9.判断两个数是否异号"></a>9.判断两个数是否异号</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ((x ^ y) &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>, y = <span class="hljs-number">2</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ((x ^ y) &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></tbody></table></figure><h3 id="10-加一"><a href="#10-加一" class="headerlink" title="10.加一"></a>10.加一</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>n = -~n;<br><span class="hljs-comment">// 现在 n = 2</span><br></code></pre></td></tr></tbody></table></figure><h3 id="11-减一"><a href="#11-减一" class="headerlink" title="11.减一"></a>11.减一</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>n = ~-n;<br><span class="hljs-comment">// 现在 n = 1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="12-n-amp-n-1"><a href="#12-n-amp-n-1" class="headerlink" title="12.n &amp; (n-1)"></a>12.<em>n &amp; (n-1)</em></h3><p>这个操作是算法中常见的，作用是消除数字 <code>n</code> 的二进制表示中的最后一个 1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;位运算技巧&quot;&gt;&lt;a href=&quot;#位运算技巧&quot; class=&quot;headerlink&quot; title=&quot;位运算技巧&quot;&gt;&lt;/a&gt;位运算技巧&lt;/h1&gt;&lt;h2 id=&quot;位操作符&quot;&gt;&lt;a href=&quot;#位操作符&quot; class=&quot;headerlink&quot; title=&quot;位操作符&quot;</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://example.com/2023/02/05/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2023/02/05/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2023-02-05T04:13:36.269Z</published>
    <updated>2023-02-06T05:07:37.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>191.位1的个数</p><p>剑指 Offer 56 - I. 数组中数字出现的次数</p><p>剑指 Offer 56 - II. 数组中数字出现的次数 II</p><p>剑指 Offer 65. 不用加减乘除做加法</p><p>231.2 的幂</p><p>268.丢失的数字</p><h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) {<br>            sum += (n &amp; <span class="hljs-number">1</span>);<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a>剑指 Offer 56 - I. 数组中数字出现的次数</h2><p><img src="/image/Snipaste_2023-02-05_12-11-13.png" alt="Snipaste_2023-02-05_12-11-13"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumbers(<span class="hljs-type">int</span>[] nums) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: nums) {<br>            a ^= i;<br>        }<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> ((a &amp; m) == <span class="hljs-number">0</span>) {<br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: nums) {<br>            <span class="hljs-keyword">if</span> ((i &amp; m) == <span class="hljs-number">0</span>) x ^= i;<br>            <span class="hljs-keyword">else</span> y ^= i;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] {x,y};<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a>剑指 Offer 56 - II. 数组中数字出现的次数 II</h2><p><img src="/image/Snipaste_2023-02-05_12-11-38.png" alt="Snipaste_2023-02-05_12-11-38"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; ++j) {<br>                count += (nums[j] &gt;&gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) {<br>                result |= <span class="hljs-number">1</span> &lt;&lt; i;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a>剑指 Offer 65. 不用加减乘除做加法</h2><p><img src="/image/Snipaste_2023-02-05_12-11-48.png" alt="Snipaste_2023-02-05_12-11-48"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<br>            a ^= b;<br>            b = c;<br>        }<br>        <span class="hljs-keyword">return</span> a;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231.2 的幂"></a>231.2 的幂</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268.丢失的数字"></a>268.丢失的数字</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">missingNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length + <span class="hljs-number">1</span>; ++i) {<br>            ans ^= i;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) {<br>            ans ^= nums[i];<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h1&gt;&lt;p&gt;191.位1的个数&lt;/p&gt;
&lt;p&gt;剑指 Offer 56 - I. 数组中数字出现的次数&lt;/p&gt;
&lt;p&gt;剑指 Offer 56 - </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法前五种</title>
    <link href="http://example.com/2023/01/05/%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%89%8D%E4%BA%94%E7%A7%8D/"/>
    <id>http://example.com/2023/01/05/%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%89%8D%E4%BA%94%E7%A7%8D/</id>
    <published>2023-01-05T07:22:39.211Z</published>
    <updated>2023-01-05T07:23:54.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十大排序算法前五种"><a href="#十大排序算法前五种" class="headerlink" title="十大排序算法前五种"></a>十大排序算法前五种</h1><p><img src="/image/%E6%8E%92%E5%BA%8F_%E6%80%BB%E7%BB%93.png"></p><h3 id="冒泡排序（Bubble-Sort"><a href="#冒泡排序（Bubble-Sort" class="headerlink" title="冒泡排序（Bubble Sort)"></a>冒泡排序（Bubble Sort)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] arr) {<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) {<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) {<br>               <span class="hljs-keyword">if</span> (arr[j + <span class="hljs-number">1</span>] &lt; arr[j]) {<br>                   <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j + <span class="hljs-number">1</span>];<br>                   arr[j + <span class="hljs-number">1</span>] = arr[j];<br>                   arr[j] = temp;<br>               }<br>           }<br>       }<br>       <span class="hljs-keyword">return</span> arr;<br>   }<br></code></pre></td></tr></tbody></table></figure><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] selectionSort(<span class="hljs-type">int</span>[] arr) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; arr.length; j++) {<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex])<br>                minIndex = j;<br>        }<br>        <span class="hljs-keyword">if</span> (i != minIndex) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[minIndex];<br>            arr[minIndex] = arr[i];<br>            arr[i] = temp;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> arr;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] insertionSort(<span class="hljs-type">int</span>[] arr) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; ++i) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; current &lt; arr[preIndex]) {<br>            arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>            preIndex --;<br>        }<br>        arr[preIndex + <span class="hljs-number">1</span>] = current;<br>    }<br>    <span class="hljs-keyword">return</span> arr;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shellSort(<span class="hljs-type">int</span>[] arr) {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> temp, gap = len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; len; i++) {<br>            temp = arr[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; temp) {<br>                arr[preIndex + gap] = arr[preIndex];<br>                preIndex -= gap;<br>            }<br>            arr[preIndex + gap] = temp;<br>        }<br>        gap /= <span class="hljs-number">2</span>;<br>    }<br>    <span class="hljs-keyword">return</span> arr;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] mergeSort(<span class="hljs-type">int</span>[] arr) {<br>    <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span>[] left = Arrays.copyOfRange(arr, <span class="hljs-number">0</span>, mid);<br>    <span class="hljs-type">int</span>[] right = Arrays.copyOfRange(arr, mid, arr.length);<br>    <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));<br>}<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] merge(<span class="hljs-type">int</span>[] left, <span class="hljs-type">int</span>[] right) {<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[left.length + right.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; index &lt; result.length; index++) {<br>        <span class="hljs-keyword">if</span> (i &gt;= left.length)<br>            result[index] = right[j++];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt;= right.length)<br>            result[index] = left[i++];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left[i] &gt; right[j])<br>            result[index] = right[j++];<br>        <span class="hljs-keyword">else</span><br>            result[index] = left[i++];<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十大排序算法前五种&quot;&gt;&lt;a href=&quot;#十大排序算法前五种&quot; class=&quot;headerlink&quot; title=&quot;十大排序算法前五种&quot;&gt;&lt;/a&gt;十大排序算法前五种&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/image/%E6%8E%92%E5%BA%8F_%E6%80</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>不同路径问题</title>
    <link href="http://example.com/2023/01/02/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/01/02/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-01-02T06:18:23.358Z</published>
    <updated>2023-01-02T06:19:18.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不同路径问题"><a href="#不同路径问题" class="headerlink" title="不同路径问题"></a>不同路径问题</h1><p>62.不同路径</p><p>63.不同路径 II</p><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp.length; ++i) {<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp[<span class="hljs-number">0</span>].length; ++i) {<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; ++i) {<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; dp[i].length; ++j) {<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63.不同路径 II"></a>63.不同路径 II</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> {<br>        <span class="hljs-keyword">if</span> (obstacleGrid == <span class="hljs-literal">null</span> || obstacleGrid.length == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) {<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) {<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) {<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) {<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;不同路径问题&quot;&gt;&lt;a href=&quot;#不同路径问题&quot; class=&quot;headerlink&quot; title=&quot;不同路径问题&quot;&gt;&lt;/a&gt;不同路径问题&lt;/h1&gt;&lt;p&gt;62.不同路径&lt;/p&gt;
&lt;p&gt;63.不同路径 II&lt;/p&gt;
&lt;h2 id=&quot;62-不同路径&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="矩阵" scheme="http://example.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>动态规划入门题</title>
    <link href="http://example.com/2023/01/02/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%E9%A2%98/"/>
    <id>http://example.com/2023/01/02/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%E9%A2%98/</id>
    <published>2023-01-02T03:34:42.701Z</published>
    <updated>2023-01-02T03:36:45.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划入门题"><a href="#动态规划入门题" class="headerlink" title="动态规划入门题"></a>动态规划入门题</h1><p>509.斐波那契数</p><p>70.爬楼梯</p><p>746.使用最小花费爬楼梯</p><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509.斐波那契数"></a>509.斐波那契数</h2><h4 id="用常量"><a href="#用常量" class="headerlink" title="用常量"></a>用常量</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,b = <span class="hljs-number">1</span>,c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) {<br>            c = a + b;<br>            a = b;<br>            b = c;<br>        }<br>        <span class="hljs-keyword">return</span> c;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="用数组"><a href="#用数组" class="headerlink" title="用数组"></a>用数组</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) {<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><h4 id="用常量-1"><a href="#用常量-1" class="headerlink" title="用常量"></a>用常量</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,b = <span class="hljs-number">2</span>,c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; ++i) {<br>            c = a + b;<br>            a = b;<br>            b = c;<br>        }<br>        <span class="hljs-keyword">return</span> c;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="用数组-1"><a href="#用数组-1" class="headerlink" title="用数组"></a>用数组</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; ++i) {<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> {<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cost.length];<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; cost.length; ++i) {<br>            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>],dp[i - <span class="hljs-number">2</span>]) + cost[i];<br>        }<br><br>        <span class="hljs-keyword">return</span> Math.min(dp[cost.length - <span class="hljs-number">1</span>],dp[cost.length - <span class="hljs-number">2</span>]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划入门题&quot;&gt;&lt;a href=&quot;#动态规划入门题&quot; class=&quot;headerlink&quot; title=&quot;动态规划入门题&quot;&gt;&lt;/a&gt;动态规划入门题&lt;/h1&gt;&lt;p&gt;509.斐波那契数&lt;/p&gt;
&lt;p&gt;70.爬楼梯&lt;/p&gt;
&lt;p&gt;746.使用最小花费爬楼梯&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="记忆化搜索" scheme="http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列经典题目</title>
    <link href="http://example.com/2023/01/01/%E7%AE%97%E6%B3%95/%E6%A0%88/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
    <id>http://example.com/2023/01/01/%E7%AE%97%E6%B3%95/%E6%A0%88/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/</id>
    <published>2023-01-01T09:31:40.673Z</published>
    <updated>2023-02-22T11:38:12.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈与队列经典题目"><a href="#栈与队列经典题目" class="headerlink" title="栈与队列经典题目"></a>栈与队列经典题目</h1><p>20.有效的括号</p><p>1047.删除字符串中的所有相邻重复项</p><p>150.逆波兰表达式求值</p><p>239.滑动窗口最大值</p><p>347.前 K 个高频元素</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> {<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; s.length();i ++){<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'('</span>){<br>                stack.push(<span class="hljs-string">')'</span>);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'{'</span>){<br>                stack.push(<span class="hljs-string">'}'</span>);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'['</span>){<br>                stack.push(<span class="hljs-string">']'</span>);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.isEmpty() || stack.pop() != ch){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="C:\Users\86173\Desktop\Snipaste_2023-02-22_13-26-29.png"></p><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h2><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String s)</span> {<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; arr.length;i ++){<br>            <span class="hljs-keyword">if</span>(stack.isEmpty() || stack.peek() != arr[i]){<br>                stack.push(arr[i]);<br>            } <span class="hljs-keyword">else</span> {<br>                stack.pop();<br>            }<br>        }<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) {<br>            str = stack.pop() + str;<br>        }<br>        <span class="hljs-keyword">return</span> str;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2022-12-31_12-16-07.png"></p><h4 id="StringBuilder模拟栈"><a href="#StringBuilder模拟栈" class="headerlink" title="StringBuilder模拟栈"></a>StringBuilder模拟栈</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) {<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (top &gt;= <span class="hljs-number">0</span> &amp;&amp; str.charAt(top) == c) {<br>                str.deleteCharAt(top);<br>                top --;<br>            } <span class="hljs-keyword">else</span> {<br>                str.append(c);<br>                top ++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> str.toString();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2022-12-31_12-19-29.png"></p><h4 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String S)</span> {<br>        <span class="hljs-type">char</span>[] s = S.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; S.length(); i++) {<br>            <span class="hljs-keyword">if</span> (top == -<span class="hljs-number">1</span> || s[top] != s[i]) {<br>                s[++top] = s[i];<br>            } <span class="hljs-keyword">else</span> {<br>                top--;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> String.valueOf(s, <span class="hljs-number">0</span>, top + <span class="hljs-number">1</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2022-12-31_12-20-23.png"></p><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> {<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; tokens.length;i ++){<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> tokens[i];<br>            <span class="hljs-keyword">if</span>(isNumber(s)){<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br>                stack.push(j);<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-keyword">switch</span> (s) {<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">"+"</span>:<br>                        stack.push(num1 + num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">"-"</span>:<br>                        stack.push(num1 - num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">"*"</span>:<br>                        stack.push(num1 * num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">"/"</span>:<br>                        stack.push(num1 / num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String token)</span> {<br>        <span class="hljs-keyword">return</span> !(<span class="hljs-string">"+"</span>.equals(token) || <span class="hljs-string">"-"</span>.equals(token) || <span class="hljs-string">"*"</span>.equals(token) || <span class="hljs-string">"/"</span>.equals(token));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) {<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums;<br>        <span class="hljs-comment">// 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序</span><br>        LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-comment">// 结果数组</span><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length-k+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 遍历nums数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++){<br>            <span class="hljs-comment">// 保证从大到小 如果前面数小则需要依次弹出，直至满足要求</span><br>            <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;= nums[i]){<br>                queue.pollLast();<br>            }<br>            <span class="hljs-comment">// 添加当前值对应的数组下标</span><br>            queue.addLast(i);<br>            <span class="hljs-comment">// 判断当前队列中队首的值是否有效</span><br>            <span class="hljs-keyword">if</span>(queue.peek() &lt;= i-k){<br>                queue.poll();   <br>            } <br>            <span class="hljs-comment">// 当窗口长度为k时 保存当前窗口中最大值</span><br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span> &gt;= k){<br>                result[i+<span class="hljs-number">1</span>-k] = nums[queue.peek()];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-22_19-37-08.png"></p><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h2><h4 id="基于大顶堆实现"><a href="#基于大顶堆实现" class="headerlink" title="基于大顶堆实现"></a>基于大顶堆实现</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) {<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums){<br>            map.put(num,map.getOrDefault(num,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        }<br>        <br>        <span class="hljs-comment">//PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2)-&gt;pair2[1]-pair1[1]);</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() {<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] m, <span class="hljs-type">int</span>[] n)</span> {<br>                <span class="hljs-keyword">return</span> n[<span class="hljs-number">1</span>] - m[<span class="hljs-number">1</span>];<br>            }<br>        });<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){<br>            pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{entry.getKey(),entry.getValue()});<br>        }<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++){<br>            ans[i] = pq.poll()[<span class="hljs-number">0</span>];<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈与队列经典题目&quot;&gt;&lt;a href=&quot;#栈与队列经典题目&quot; class=&quot;headerlink&quot; title=&quot;栈与队列经典题目&quot;&gt;&lt;/a&gt;栈与队列经典题目&lt;/h1&gt;&lt;p&gt;20.有效的括号&lt;/p&gt;
&lt;p&gt;1047.删除字符串中的所有相邻重复项&lt;/p&gt;
&lt;p&gt;150</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="队列" scheme="http://example.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="堆(优先队列)" scheme="http://example.com/tags/%E5%A0%86-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="单调队列" scheme="http://example.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列的互相实现</title>
    <link href="http://example.com/2022/12/28/%E7%AE%97%E6%B3%95/%E6%A0%88/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/12/28/%E7%AE%97%E6%B3%95/%E6%A0%88/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-28T03:45:19.998Z</published>
    <updated>2022-12-28T03:47:30.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈与队列的互相实现"><a href="#栈与队列的互相实现" class="headerlink" title="栈与队列的互相实现"></a>栈与队列的互相实现</h1><p>232.用栈实现队列</p><p>225.用队列实现栈</p><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> {<br>    Stack&lt;Integer&gt; stk1 , stk2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> {<br>        stk1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stk2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> {<br>        stk1.push(x);<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span>(stk2.isEmpty()){<br>            <span class="hljs-keyword">while</span>(!stk1.isEmpty()){<br>                stk2.push(stk1.pop());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> stk2.pop();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span>(stk2.isEmpty()){<br>            <span class="hljs-keyword">while</span>(!stk1.isEmpty()){<br>                stk2.push(stk1.pop());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> stk2.peek();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> stk1.isEmpty() &amp;&amp; stk2.isEmpty();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> {<br><br>    Queue&lt;Integer&gt; queue1;<br>    Queue&lt;Integer&gt; queue2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> {<br>        queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> {<br>        queue2.offer(x);<br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty()){<br>            queue2.offer(queue1.poll());<br>        }<br>        Queue&lt;Integer&gt; queueTemp;<br>        queueTemp = queue1;<br>        queue1 = queue2;<br>        queue2 = queueTemp; <br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> queue1.poll();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> queue1.peek();<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> queue1.isEmpty();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈与队列的互相实现&quot;&gt;&lt;a href=&quot;#栈与队列的互相实现&quot; class=&quot;headerlink&quot; title=&quot;栈与队列的互相实现&quot;&gt;&lt;/a&gt;栈与队列的互相实现&lt;/h1&gt;&lt;p&gt;232.用栈实现队列&lt;/p&gt;
&lt;p&gt;225.用队列实现栈&lt;/p&gt;
&lt;h2 id=&quot;2</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="队列" scheme="http://example.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="设计" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>棋盘问题</title>
    <link href="http://example.com/2022/12/27/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/12/27/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-27T03:40:35.859Z</published>
    <updated>2023-02-24T04:59:42.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h1><p>51.N 皇后</p><p>37.解数独</p><h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51.N 皇后"></a>51.N 皇后</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;String&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-type">char</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : arr) {<br>            Arrays.fill(c, <span class="hljs-string">'.'</span>);<br>        }<br>        dfs(n, <span class="hljs-number">0</span>, arr);<br>        <span class="hljs-keyword">return</span> list;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">char</span>[][] arr)</span> {<br>        <span class="hljs-keyword">if</span> (row == n) {<br>            list.add(Array2List(arr));<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; ++col) {<br>            <span class="hljs-keyword">if</span> (isValid(row, col, n, arr)) {<br>                arr[row][col] = <span class="hljs-string">'Q'</span>;<br>                dfs(n, row+<span class="hljs-number">1</span>, arr);<br>                arr[row][col] = <span class="hljs-string">'.'</span>;<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> List <span class="hljs-title function_">Array2List</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chessboard)</span> {<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chessboard) {<br>            list.add(String.copyValueOf(c));<br>        }<br>        <span class="hljs-keyword">return</span> list;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span>[][] arr)</span> {<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;row; ++i) {<br>            <span class="hljs-keyword">if</span> (arr[i][col] == <span class="hljs-string">'Q'</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=row-<span class="hljs-number">1</span>, j=col-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&gt;=<span class="hljs-number">0</span>; i--, j--) {<br>            <span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">'Q'</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=row-<span class="hljs-number">1</span>, j=col+<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;=n-<span class="hljs-number">1</span>; i--, j++) {<br>            <span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">'Q'</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-24_12-57-13.png"></p><p><img src="/image/Snipaste_2023-02-24_12-58-37.png"></p><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h2><p>该方法时间复杂度较高</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solveSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> {<br>        solveSudokuHelper(board);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">solveSudokuHelper</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++){<br>                <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">'.'</span>){<br>                    <span class="hljs-keyword">continue</span>;<br>                }<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span>; k &lt;= <span class="hljs-string">'9'</span>; k++){ <br>                    <span class="hljs-keyword">if</span> (isValidSudoku(i, j, k, board)){<br>                        board[i][j] = k;<br>                        <span class="hljs-keyword">if</span> (solveSudokuHelper(board)){<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        }<br>                        board[i][j] = <span class="hljs-string">'.'</span>;<br>                    }<br>                }<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidSudoku</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val, <span class="hljs-type">char</span>[][] board)</span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++){<br>            <span class="hljs-keyword">if</span> (board[row][i] == val){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++){<br>            <span class="hljs-keyword">if</span> (board[j][col] == val){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">startRow</span> <span class="hljs-operator">=</span> (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startCol</span> <span class="hljs-operator">=</span> (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++){<br>                <span class="hljs-keyword">if</span> (board[i][j] == val){<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;棋盘问题&quot;&gt;&lt;a href=&quot;#棋盘问题&quot; class=&quot;headerlink&quot; title=&quot;棋盘问题&quot;&gt;&lt;/a&gt;棋盘问题&lt;/h1&gt;&lt;p&gt;51.N 皇后&lt;/p&gt;
&lt;p&gt;37.解数独&lt;/p&gt;
&lt;h2 id=&quot;51-N-皇后&quot;&gt;&lt;a href=&quot;#51-N-皇后&quot; </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>全排列问题</title>
    <link href="http://example.com/2022/12/26/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/12/26/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-26T03:07:21.564Z</published>
    <updated>2023-02-01T09:12:14.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h1><p>46.全排列</p><p>47.全排列 II</p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        dfs(nums);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) {<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) {<br>            <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.add(nums[i]);<br>            dfs(nums);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h2><p>去重必须先将数组排序</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        Arrays.sort(nums);<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        dfs(nums);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) {<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) {<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.add(nums[i]);<br>            dfs(nums);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;全排列问题&quot;&gt;&lt;a href=&quot;#全排列问题&quot; class=&quot;headerlink&quot; title=&quot;全排列问题&quot;&gt;&lt;/a&gt;全排列问题&lt;/h1&gt;&lt;p&gt;46.全排列&lt;/p&gt;
&lt;p&gt;47.全排列 II&lt;/p&gt;
&lt;h2 id=&quot;46-全排列&quot;&gt;&lt;a href=&quot;#46-全</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
</feed>
