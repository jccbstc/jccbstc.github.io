<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>业余的日落患者</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-03T11:43:21.050Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>及川彻</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 常见数据类型和应用场景</title>
    <link href="http://example.com/2023/04/03/Redis/Redis%20%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://example.com/2023/04/03/Redis/Redis%20%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2023-04-03T11:36:32.932Z</published>
    <updated>2023-04-03T11:43:21.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-常见数据类型和应用场景"><a href="#Redis-常见数据类型和应用场景" class="headerlink" title="Redis 常见数据类型和应用场景"></a>Redis 常见数据类型和应用场景</h1><h2 id="常见数据类型介绍与实现"><a href="#常见数据类型介绍与实现" class="headerlink" title="常见数据类型介绍与实现"></a>常见数据类型介绍与实现</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p><ul><li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li><li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li><li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li></ul><p>字符串对象的内部编码（encoding）有 3 种 ：<strong>int、raw和 embstr</strong>。</p><p><img src="/image/string%E7%BB%93%E6%9E%84.webp"></p><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p><img src="/image/int.webp"></p><h4 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h4><p><img src="/image/raw.webp"></p><h4 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h4><p><img src="/image/embstr.webp"></p><p><code>embstr</code>和<code>raw</code>编码都会使用<code>SDS</code>来保存值，但不同之处在于<code>embstr</code>会通过一次内存分配函数来分配一块连续的内存空间来保存<code>redisObject</code>和<code>SDS</code>，而<code>raw</code>编码会通过调用两次内存分配函数来分别分配两块空间来保存<code>redisObject</code>和<code>SDS</code>。Redis这样做会有很多好处：</p><ul><li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次；</li><li>释放 <code>embstr</code>编码的字符串对象同样只需要调用一次内存释放函数；</li><li>因为<code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</li></ul><p>但是 embstr 也有缺点的：</p><ul><li>如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以<strong>embstr编码的字符串对象实际上是只读的</strong>，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p><ul><li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p><ul><li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li><li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p><p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p><p><img src="/image/bitmap.webp"></p><p><strong>内部实现：</strong></p><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>Redis HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。</p><p>所以，简单来说 HyperLogLog <strong>提供不精确的去重计数</strong>。</p><p>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的。</p><p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数</strong>，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p><p><strong>内部实现：</strong></p><p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li></ul><p>基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p><h2 id="Redis-数据类型的应用场景"><a href="#Redis-数据类型的应用场景" class="headerlink" title="Redis 数据类型的应用场景"></a>Redis 数据类型的应用场景</h2><ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享session信息等。</li><li>List 类型的应用场景：消息队列（有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li></ul><p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p><ul><li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li><li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li><li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li><li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="把-Redis-当作队列来使用时，会面临的-2-个问题"><a href="#把-Redis-当作队列来使用时，会面临的-2-个问题" class="headerlink" title="把 Redis 当作队列来使用时，会面临的 2 个问题"></a>把 Redis 当作队列来使用时，会面临的 2 个问题</h3><ul><li>Redis 本身可能会丢数据；</li><li>面对消息挤压，内存资源会紧张；</li></ul><h3 id="Redis-发布-x2F-订阅机制为什么不可以作为消息队列？"><a href="#Redis-发布-x2F-订阅机制为什么不可以作为消息队列？" class="headerlink" title="Redis 发布/订阅机制为什么不可以作为消息队列？"></a>Redis 发布/订阅机制为什么不可以作为消息队列？</h3><ol><li>发布/订阅机制没有基于任何数据类型实现，所以不具备「数据持久化」的能力，也就是发布/订阅机制的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，发布/订阅机制的数据也会全部丢失。</li><li>发布订阅模式是“发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。</li><li>当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 <code>client-output-buffer-limit pubsub 32mb 8mb 60</code>。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis-常见数据类型和应用场景&quot;&gt;&lt;a href=&quot;#Redis-常见数据类型和应用场景&quot; class=&quot;headerlink&quot; title=&quot;Redis 常见数据类型和应用场景&quot;&gt;&lt;/a&gt;Redis 常见数据类型和应用场景&lt;/h1&gt;&lt;h2 id=&quot;常见数据类</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>丑数</title>
    <link href="http://example.com/2023/04/02/%E7%AE%97%E6%B3%95/%E4%B8%91%E6%95%B0/"/>
    <id>http://example.com/2023/04/02/%E7%AE%97%E6%B3%95/%E4%B8%91%E6%95%B0/</id>
    <published>2023-04-02T02:00:40.124Z</published>
    <updated>2023-04-02T02:02:11.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h1><p>263.丑数</p><p>264.丑数 II</p><h3 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263.丑数"></a>263.丑数</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isUgly</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span>[] cs = {<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>};<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cs.length; ++i) {<br>            <span class="hljs-keyword">while</span> (n % cs[i] == <span class="hljs-number">0</span>) {<br>                n /= cs[i];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h3 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264.丑数 II"></a>264.丑数 II</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,b = <span class="hljs-number">0</span>,c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * dp[a],n2 = <span class="hljs-number">3</span> * dp[b],n3 = <span class="hljs-number">5</span> * dp[c];<br>            dp[i] = Math.min(Math.min(n1,n2),n3);<br>            <span class="hljs-keyword">if</span> (n1 == dp[i]) a++;<br>            <span class="hljs-keyword">if</span> (n2 == dp[i]) b++;<br>            <span class="hljs-keyword">if</span> (n3 == dp[i]) c++;<br>        }<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;丑数&quot;&gt;&lt;a href=&quot;#丑数&quot; class=&quot;headerlink&quot; title=&quot;丑数&quot;&gt;&lt;/a&gt;丑数&lt;/h1&gt;&lt;p&gt;263.丑数&lt;/p&gt;
&lt;p&gt;264.丑数 II&lt;/p&gt;
&lt;h3 id=&quot;263-丑数&quot;&gt;&lt;a href=&quot;#263-丑数&quot; class=&quot;h</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>字符串的反转和字符串中单词的反转</title>
    <link href="http://example.com/2023/04/01/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%8D%E8%BD%AC%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8F%8D%E8%BD%AC/"/>
    <id>http://example.com/2023/04/01/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%8D%E8%BD%AC%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8F%8D%E8%BD%AC/</id>
    <published>2023-04-01T09:05:27.105Z</published>
    <updated>2023-04-01T09:10:04.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串的反转和字符串中单词的反转"><a href="#字符串的反转和字符串中单词的反转" class="headerlink" title="字符串的反转和字符串中单词的反转"></a>字符串的反转和字符串中单词的反转</h1><p>151.反转字符串中的单词</p><p>557.反转字符串中的单词 III</p><p>剑指 Offer 58 - II. 左旋转字符串 （左旋）</p><p>189.轮转数组（右旋）</p><p>541.反转字符串 II</p><p>剑指 Offer 05. 替换空格</p><p>345.反转字符串中的元音字母</p><p>796.旋转字符串</p><h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h3><h5 id="不用API库"><a href="#不用API库" class="headerlink" title="不用API库"></a>不用API库</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> trimSpaces(s);<br><br>        <span class="hljs-comment">// 翻转字符串</span><br>        reverse(sb, <span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 翻转每个单词</span><br>        reverseEachWord(sb);<br><br>        <span class="hljs-keyword">return</span> sb.toString();<br>    }<br><br>    <span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title function_">trimSpaces</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 去掉字符串开头的空白字符</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="hljs-string">' '</span>) {<br>            ++left;<br>        }<br><br>        <span class="hljs-comment">// 去掉字符串末尾的空白字符</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="hljs-string">' '</span>) {<br>            --right;<br>        }<br><br>        <span class="hljs-comment">// 将字符串间多余的空白字符去除</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (left &lt;= right) {<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(left);<br><br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span>) {<br>                sb.append(c);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sb.charAt(sb.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">' '</span>) {<br>                sb.append(c);<br>            }<br><br>            ++left;<br>        }<br>        <span class="hljs-keyword">return</span> sb;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(StringBuilder sb, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> {<br>        <span class="hljs-keyword">while</span> (left &lt; right) {<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> sb.charAt(left);<br>            sb.setCharAt(left++, sb.charAt(right));<br>            sb.setCharAt(right--, tmp);<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(StringBuilder sb)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sb.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (start &lt; n) {<br>            <span class="hljs-comment">// 循环至单词的末尾</span><br>            <span class="hljs-keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="hljs-string">' '</span>) {<br>                ++end;<br>            }<br>            <span class="hljs-comment">// 翻转单词</span><br>            reverse(sb, start, end - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 更新start，去找下一个单词</span><br>            start = end + <span class="hljs-number">1</span>;<br>            ++end;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="用API库"><a href="#用API库" class="headerlink" title="用API库"></a>用API库</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> {<br>        String[] words = s.trim().split(<span class="hljs-string">" +"</span>);<br>        Collections.reverse(Arrays.asList(words));<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">" "</span>, words);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h3 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557.反转字符串中的单词 III"></a>557.反转字符串中的单词 III</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">char</span>[] chars = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; chars.length; j++) {<br>            <span class="hljs-keyword">if</span> (chars[j] == <span class="hljs-string">' '</span>) {<br>                reverse(chars, i, j - <span class="hljs-number">1</span>);<br>                i = j + <span class="hljs-number">1</span>;<br>            }<br>        }<br>        reverse(chars, i, chars.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> String.valueOf(chars);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {<br>        <span class="hljs-keyword">while</span> (i &lt; j) {<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> chars[i];<br>            chars[i++] = chars[j];<br>            chars[j--] = temp;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h3 id="剑指-Offer-58-II-左旋转字符串-（左旋）"><a href="#剑指-Offer-58-II-左旋转字符串-（左旋）" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串 （左旋）"></a>剑指 Offer 58 - II. 左旋转字符串 （左旋）</h3><h5 id="遍历拼接"><a href="#遍历拼接" class="headerlink" title="遍历拼接"></a>遍历拼接</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n; i &lt; s.length(); i++)<br>            res.append(s.charAt(i));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>            res.append(s.charAt(i));<br>        <span class="hljs-keyword">return</span> res.toString();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h5 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">return</span> s.substring(n,s.length()) + s.substring(<span class="hljs-number">0</span>,n);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h3 id="189-轮转数组（右旋）"><a href="#189-轮转数组（右旋）" class="headerlink" title="189.轮转数组（右旋）"></a>189.轮转数组（右旋）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        k %= length;<br>        reverse(nums, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>);<span class="hljs-comment">//先反转全部的元素</span><br>        reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<span class="hljs-comment">//在反转前k个元素</span><br>        reverse(nums, k, length - <span class="hljs-number">1</span>);<span class="hljs-comment">//接着反转剩余的</span><br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {<br>        <span class="hljs-keyword">while</span> (start &lt; end) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[start];<br>            nums[start++] = nums[end];<br>            nums[end--] = temp;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h3 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541.反转字符串 II"></a>541.反转字符串 II</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> {<br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; s.length();i = k * <span class="hljs-number">2</span> + i){<br>            reverse(arr,i,Math.min(i + k,s.length()) - <span class="hljs-number">1</span>);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>{<br>        <span class="hljs-keyword">while</span>(left &lt; right){<br>            <span class="hljs-type">char</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> arr[left];<br>            arr[left] = arr[right];<br>            arr[right] = a;<br>            left ++;<br>            right --;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h3><h5 id="StringBuilder模仿数组"><a href="#StringBuilder模仿数组" class="headerlink" title="StringBuilder模仿数组"></a>StringBuilder模仿数组</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceSpace</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) {<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span>) {<br>                sb.append(c);<br>            } <span class="hljs-keyword">else</span> {<br>                sb.append(<span class="hljs-string">"%20"</span>);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h3 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345.反转字符串中的元音字母"></a>345.反转字符串中的元音字母</h3><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseVowels</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) {<br>            <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; !isVowel(arr[i])) {<br>                ++i;<br>            }<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; !isVowel(arr[j])) {<br>                --j;<br>            }<br>            <span class="hljs-keyword">if</span> (i &lt; j) {<br>                swap(arr, i, j);<br>                ++i;<br>                --j;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVowel</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"aeiouAEIOU"</span>.indexOf(ch) &gt;= <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">char</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> {<br>        <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h3 id="796-旋转字符串"><a href="#796-旋转字符串" class="headerlink" title="796.旋转字符串"></a>796.旋转字符串</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">rotateString</span><span class="hljs-params">(String s, String goal)</span> {<br>        <span class="hljs-keyword">return</span> A.length() == B.length() &amp;&amp; (A + A).contains(B);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串的反转和字符串中单词的反转&quot;&gt;&lt;a href=&quot;#字符串的反转和字符串中单词的反转&quot; class=&quot;headerlink&quot; title=&quot;字符串的反转和字符串中单词的反转&quot;&gt;&lt;/a&gt;字符串的反转和字符串中单词的反转&lt;/h1&gt;&lt;p&gt;151.反转字符串中的单词&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>StringTable</title>
    <link href="http://example.com/2023/03/31/%E5%9F%BA%E7%A1%80/StringTable/"/>
    <id>http://example.com/2023/03/31/%E5%9F%BA%E7%A1%80/StringTable/</id>
    <published>2023-03-31T10:51:24.971Z</published>
    <updated>2023-03-31T10:52:56.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h1><h5 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">"hello"</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-03-31_16-03-21.png"></p><p>把s的值改一下，改成”world“</p><p>值没改变，而是引用指向了一个新的字符串。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">"hello"</span>;<br>s = <span class="hljs-string">"world"</span>;<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-03-31_18-37-23.png"></p><h5 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"a"</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"b"</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-03-31_16-05-21.png"></p><h5 id="new-String"><a href="#new-String" class="headerlink" title="new String()"></a>new String()</h5><p><img src="/image/Snipaste_2023-03-31_16-07-23.png"></p><h5 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h5><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>ern方法的作用就是尝试将一个字符串放入StringTable中，<br>如果不存在就放入StringTable并返回StringTable中的地址，<br>如果存在的话就直接返回StringTable中的地址。<br>这是jdk1<span class="hljs-number">.8</span>版本中<span class="hljs-built_in">int</span>ern方法的作用，jdk1<span class="hljs-number">.6</span>版本中有些不同，<br><span class="hljs-number">1.6</span>中<span class="hljs-built_in">int</span>ern尝试将字符串对象放入StringTable，如果有则并不会放入，<br>如果没有会把此对象复制一份，放入StringTable， <br>再把StringTable中的对象返回。不过我们在这里不讨论<span class="hljs-number">1.6</span>版本。<br></code></pre></td></tr></tbody></table></figure><p>在intern方法之前存在</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTable</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"a"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"b"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s3.intern();<br><br>        System.out.println(s5 == s3); <span class="hljs-comment">// false</span><br>        System.out.println(s6 == s5); <span class="hljs-comment">// true</span><br>        System.out.println(s6 == s3); <span class="hljs-comment">// false</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-03-31_16-15-44.png"></p><p>在intern方法之后存在</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTable</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"a"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"b"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s3.intern();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br>        System.out.println(s5 == s3); <span class="hljs-comment">// true</span><br>        System.out.println(s6 == s5); <span class="hljs-comment">// true</span><br>        System.out.println(s6 == s3); <span class="hljs-comment">// true</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-03-31_16-16-33.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;StringTable&quot;&gt;&lt;a href=&quot;#StringTable&quot; class=&quot;headerlink&quot; title=&quot;StringTable&quot;&gt;&lt;/a&gt;StringTable&lt;/h1&gt;&lt;h5 id=&quot;String的不可变性&quot;&gt;&lt;a href=&quot;#String</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="StringTable" scheme="http://example.com/tags/StringTable/"/>
    
  </entry>
  
  <entry>
    <title>堆排序和快速排序</title>
    <link href="http://example.com/2023/03/30/%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2023/03/30/%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2023-03-30T13:43:32.666Z</published>
    <updated>2023-03-31T11:06:19.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆排序和快速排序"><a href="#堆排序和快速排序" class="headerlink" title="堆排序和快速排序"></a>堆排序和快速排序</h1><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>            adjustHeap(arr, i, arr.length);<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) {<br>            swap(arr, <span class="hljs-number">0</span>, j);<br>            adjustHeap(arr, <span class="hljs-number">0</span>, j);<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; k &lt; length; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) {<br>            <span class="hljs-keyword">if</span> (k + <span class="hljs-number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="hljs-number">1</span>]) {<br>                k++;<br>            }<br>            <span class="hljs-keyword">if</span> (arr[k] &gt; temp) {<br>                arr[i] = arr[k];<br>                i = k;<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>        arr[i] = temp;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[a];<br>        arr[a] = arr[b];<br>        arr[b] = temp;<br>    }<br></code></pre></td></tr></tbody></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low, j = high;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i &gt; j) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[low];<br>        <span class="hljs-keyword">while</span> (i &lt; j) {<br>            <span class="hljs-keyword">while</span> (temp &lt;= arr[j] &amp;&amp; i &lt; j) {<br>                j--;<br>            }<br>            <span class="hljs-keyword">while</span> (temp &gt;= arr[i] &amp;&amp; i &lt; j) {<br>                i++;<br>            }<br>            <span class="hljs-keyword">if</span> (i &lt; j) {<br>                t = arr[j];<br>                arr[j] = arr[i];<br>                arr[i] = t;<br>            }<br>            arr[low] = arr[i];<br>            arr[i] = temp;<br>            quickSort(arr, low, j - <span class="hljs-number">1</span>);<br>            quickSort(arr, j + <span class="hljs-number">1</span>, high);<br>        }<br>    }<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆排序和快速排序&quot;&gt;&lt;a href=&quot;#堆排序和快速排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序和快速排序&quot;&gt;&lt;/a&gt;堆排序和快速排序&lt;/h1&gt;&lt;h5 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>百度校招Java研发工程师笔试卷</title>
    <link href="http://example.com/2023/03/30/%E7%AC%94%E8%AF%95/%E7%99%BE%E5%BA%A6%E6%A0%A1%E6%8B%9BJava%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E5%8D%B7/"/>
    <id>http://example.com/2023/03/30/%E7%AC%94%E8%AF%95/%E7%99%BE%E5%BA%A6%E6%A0%A1%E6%8B%9BJava%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E5%8D%B7/</id>
    <published>2023-03-30T07:48:54.986Z</published>
    <updated>2023-03-30T13:08:19.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度校招Java研发工程师笔试卷"><a href="#百度校招Java研发工程师笔试卷" class="headerlink" title="百度校招Java研发工程师笔试卷"></a>百度校招Java研发工程师笔试卷</h1><h5 id="1-当请求过多，超出线程池负荷的时候，会触发拒绝策略。下列选项中，对于拒绝策略的描述错误的是："><a href="#1-当请求过多，超出线程池负荷的时候，会触发拒绝策略。下列选项中，对于拒绝策略的描述错误的是：" class="headerlink" title="1.当请求过多，超出线程池负荷的时候，会触发拒绝策略。下列选项中，对于拒绝策略的描述错误的是："></a>1.当请求过多，超出线程池负荷的时候，会触发拒绝策略。下列选项中，对于拒绝策略的描述错误的是：</h5><p>A. CallerRunsPolicy，线程调用运行该任务的 execute 本身，此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</p><p>B. AbortPolicy，处理程序遭到拒绝将直接抛出异常，丢弃任务。</p><p>C. DiscardPolicy，不能执行的任务将被删除。这种策略将丢弃任务，同时也会抛出异常。</p><p>D. DiscardOldestPolicy，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序。</p><p>正确答案：C</p><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">线程池拒绝策略：<br>  （<span class="hljs-number">1</span>） AbortPolicy 。丢弃任务，并抛出RejectedExecutionException异常，线程池默认拒绝策略；<br>  （<span class="hljs-number">2</span>） <span class="hljs-keyword">DiscardPolicy。丢弃任务，不抛出异常；</span><br><span class="hljs-keyword"></span>  （<span class="hljs-number">3</span>） <span class="hljs-keyword">DiscardOldesPolicy.丢弃队列最前面的任务，然后重新提交被拒绝的任务；</span><br><span class="hljs-keyword"></span>  （<span class="hljs-number">4</span>） CallerRunPolicy。由调用的线程处理该任务，谁调用谁的线程处理。<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="2-下列关于AOP术语的描述中，错误的是："><a href="#2-下列关于AOP术语的描述中，错误的是：" class="headerlink" title="2.下列关于AOP术语的描述中，错误的是："></a>2.下列关于AOP术语的描述中，错误的是：</h5><p>A. Joinpoint，是指目标对象上所定义的各个方法。</p><p>B. Pointcut，是用来定义当前的横切逻辑准备织入到哪些连接点上。</p><p>C. Advice，用来定义横切逻辑，即在连接点上准备织入什么样的逻辑。</p><p>D. Aspect，是一个用来封装切点和通知的组件。</p><p>正确答案：A</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 连接点（Joinpoint）<br>连接点描述的是程序执行的某个特定位置<br><span class="hljs-bullet">2.</span> 切入点（Pointcut）<br>切入点是一个连接点的过滤条件，AOP 通过切点定位到特定的连接点。<br><span class="hljs-bullet">3.</span> 通知（Advice）<br>切面在某个具体的连接点采取的行为或行动，称为通知。<br><span class="hljs-bullet">4.</span> 通知器（Advisor）<br>通知器由一个切入点（pointcut）和一个通知（Advice）组成。<br><span class="hljs-bullet">5.</span> 切面（Aspect）<br>与通知器（advisor）类似都是通知+切入点。<br><span class="hljs-bullet">6.</span> 目标(Target)<br>被通知的对象（方法）<br><span class="hljs-bullet">7.</span> 代理(Proxy)<br>向目标对象应用通知之后创建的对象<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="3-JVM中有很多垃圾回收策略，其中会用到很多垃圾收集器，如果我们将垃圾收集器的作用范围划分为新生代和老年代的话，那么以下哪个选项中的所有收集器的作用域是属于老年代"><a href="#3-JVM中有很多垃圾回收策略，其中会用到很多垃圾收集器，如果我们将垃圾收集器的作用范围划分为新生代和老年代的话，那么以下哪个选项中的所有收集器的作用域是属于老年代" class="headerlink" title="3.JVM中有很多垃圾回收策略，其中会用到很多垃圾收集器，如果我们将垃圾收集器的作用范围划分为新生代和老年代的话，那么以下哪个选项中的所有收集器的作用域是属于老年代"></a>3.JVM中有很多垃圾回收策略，其中会用到很多垃圾收集器，如果我们将垃圾收集器的作用范围划分为新生代和老年代的话，那么以下哪个选项中的所有收集器的作用域是属于老年代</h5><p>A. Serial收集器、ParNew收集器、Paraller Scavenge收集器</p><p>B. Serial Old收集器、Paraller Old收集器、CMS收集器</p><p>C. Serial Old收集器、Paraller Old收集器、Paraller Scavenge收集器</p><p>D. CMS收集器、ParNew收集器、Paraller Scavenge收集器</p><p>正确答案：B</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">年轻代：serial <span class="hljs-built_in">GC</span>、parNew <span class="hljs-built_in">GC</span>、paraller Scavenge <span class="hljs-built_in">GC</span><br>老年代：serial old <span class="hljs-built_in">GC</span> 、paraller old <span class="hljs-built_in">GC</span>、CMS<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="4-下面几项关于Java程序初始化的几个原则："><a href="#4-下面几项关于Java程序初始化的几个原则：" class="headerlink" title="4.下面几项关于Java程序初始化的几个原则："></a>4.下面几项关于Java程序初始化的几个原则：</h5><p>①静态对象（变量）优先于非静态对象（变量）初始化；</p><p>②父类优先于子类进行初始化；</p><p>③按照成员变量的定义顺序进行初始化；</p><p>其中正确的有：</p><p>A. ①②</p><p>B. ①③</p><p>C. ②③</p><p>D. ①②③</p><p>正确答案：D</p><hr><h5 id="5-以下哪个不是分布式锁的实现方式"><a href="#5-以下哪个不是分布式锁的实现方式" class="headerlink" title="5.以下哪个不是分布式锁的实现方式"></a>5.以下哪个不是分布式锁的实现方式</h5><p>A. 使用数据库乐观锁实现</p><p>B. 使用数据库悲观锁实现</p><p>C. 使用redis的setnx()、expire()方法，用于分布式锁</p><p>D. 基于Zookeeper实现分布式锁</p><p>正确答案：B</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">目前分布式锁的实现方案主要包括三种：<br><br>1.基于数据库（唯一索引）<br>2.基于缓存（Redis，memcached，tair）<br>3.基于Zookeeper<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="6-对于数列4、5、6、7、9、12、18、23，如果采用折半查找元素9，请问需要查找几次？"><a href="#6-对于数列4、5、6、7、9、12、18、23，如果采用折半查找元素9，请问需要查找几次？" class="headerlink" title="6.对于数列4、5、6、7、9、12、18、23，如果采用折半查找元素9，请问需要查找几次？"></a>6.对于数列4、5、6、7、9、12、18、23，如果采用折半查找元素9，请问需要查找几次？</h5><p>A. 2</p><p>B. 3</p><p>C. 4</p><p>D. 5</p><p>正确答案：B</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span> 代表数组长度<br><span class="hljs-attribute">4</span>、<span class="hljs-number">5</span>、<span class="hljs-number">6</span>、<span class="hljs-number">7</span>、<span class="hljs-number">9</span>、<span class="hljs-number">12</span>、<span class="hljs-number">18</span>、<span class="hljs-number">23</span><br><span class="hljs-attribute">1</span>)   Array[(<span class="hljs-number">0</span> + n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]  小于 <span class="hljs-number">9</span>, (<span class="hljs-number">0</span> + n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> = <span class="hljs-number">3</span><br><span class="hljs-attribute">2</span>)   Array[(<span class="hljs-number">3</span> + <span class="hljs-number">1</span> + n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] 大于 <span class="hljs-number">9</span>, (<span class="hljs-number">3</span> + <span class="hljs-number">1</span> + n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> = <span class="hljs-number">5</span><br><span class="hljs-attribute">3</span>)   Array[(<span class="hljs-number">3</span> + <span class="hljs-number">1</span> + <span class="hljs-number">5</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] 等于 <span class="hljs-number">9</span><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="7-现有一字符串”hello-world”，使用哈夫曼编码最少使用多少bit内存："><a href="#7-现有一字符串”hello-world”，使用哈夫曼编码最少使用多少bit内存：" class="headerlink" title="7.现有一字符串”hello world”，使用哈夫曼编码最少使用多少bit内存："></a>7.现有一字符串”hello world”，使用哈夫曼编码最少使用多少bit内存：</h5><p>A. 4</p><p>B. 32</p><p>C. 64</p><p>D. 88</p><p>正确答案：B</p><hr><h5 id="8-已知现有一个大小为4初始状态为空的栈，现在有一组数据经过这个栈后，最终的数据顺序是-2-5-4-1-3-问原始的进栈数据不可能是以下的哪组"><a href="#8-已知现有一个大小为4初始状态为空的栈，现在有一组数据经过这个栈后，最终的数据顺序是-2-5-4-1-3-问原始的进栈数据不可能是以下的哪组" class="headerlink" title="8.已知现有一个大小为4初始状态为空的栈，现在有一组数据经过这个栈后，最终的数据顺序是:2 5 4 1 3,问原始的进栈数据不可能是以下的哪组"></a>8.已知现有一个大小为4初始状态为空的栈，现在有一组数据经过这个栈后，最终的数据顺序是:2 5 4 1 3,问原始的进栈数据不可能是以下的哪组</h5><p>A. 1 4 5 2 3</p><p>B. 5 2 3 1 4</p><p>C. 3 4 5 2 1</p><p>D. 4 1 3 5 2</p><p>正确答案：D</p><hr><h5 id="9-假设有一张表test-表中存放着全国的城市信息以及其所在的省份-现在要以每个省份包含名称以’州’为结尾的城市数量降序排序-包含相同数量的省份以省份名称降序拍戏-最终输出第二多以及第三多的省份以及数量-那么下面正确的sql语句是："><a href="#9-假设有一张表test-表中存放着全国的城市信息以及其所在的省份-现在要以每个省份包含名称以’州’为结尾的城市数量降序排序-包含相同数量的省份以省份名称降序拍戏-最终输出第二多以及第三多的省份以及数量-那么下面正确的sql语句是：" class="headerlink" title="9.假设有一张表test,表中存放着全国的城市信息以及其所在的省份,现在要以每个省份包含名称以’州’为结尾的城市数量降序排序,包含相同数量的省份以省份名称降序拍戏,最终输出第二多以及第三多的省份以及数量,那么下面正确的sql语句是："></a>9.假设有一张表test,表中存放着全国的城市信息以及其所在的省份,现在要以每个省份包含名称以’州’为结尾的城市数量降序排序,包含相同数量的省份以省份名称降序拍戏,最终输出第二多以及第三多的省份以及数量,那么下面正确的sql语句是：</h5><blockquote><p>create table <code>test</code>(</p><p>  <code>id</code> int(11) not null auto_increment,</p><p>  <code>province</code> char(50) not null comment ‘省份名称’,</p><p>  <code>city</code> char(50) not null comment ‘城市名称’,</p><p>  primary key(<code>id</code>),</p><p>  unique key <code>idx</code>(<code>province</code>, <code>city</code>)</p><p>)engine = innodb;</p></blockquote><p>A. select province, count(*) c from test where city like ‘%州’ group by province order by c desc, province desc limit 2,1</p><p>B. select province, count(*) c from test where city like ‘%州’ group by province order by c desc, province desc limit 1,2</p><p>C. select province, count(*) c from test where city like ‘州%’ group by province order by c desc, province desc limit 2,1</p><p>D. select province, count(*) c from test where city like ‘州%’ group by province order by c desc, province desc limit 1,2</p><p>正确答案：B</p><hr><h5 id="10-假设有必修课成绩表course-每位学生的期末考试成绩以及补考成绩都录入到course表中-学号为20190001的同学想查询一下自己未通过的课程的课程编号与课程名称-那么下面正确的sql语句是："><a href="#10-假设有必修课成绩表course-每位学生的期末考试成绩以及补考成绩都录入到course表中-学号为20190001的同学想查询一下自己未通过的课程的课程编号与课程名称-那么下面正确的sql语句是：" class="headerlink" title="10.假设有必修课成绩表course,每位学生的期末考试成绩以及补考成绩都录入到course表中,学号为20190001的同学想查询一下自己未通过的课程的课程编号与课程名称,那么下面正确的sql语句是："></a>10.假设有必修课成绩表course,每位学生的期末考试成绩以及补考成绩都录入到course表中,学号为20190001的同学想查询一下自己未通过的课程的课程编号与课程名称,那么下面正确的sql语句是：</h5><blockquote><p>create table <code>course</code>(</p><p>  <code>id</code> int(11) not null auto_increment,</p><p>  <code>sid</code> int(11) not null comment ‘学号’,</p><p>  <code>cid</code> int(11) not null comment ‘课程编号’,</p><p>  <code>cname</code> char(50) not null comment ‘课程名称’,</p><p>  <code>score</code> int(11) not null comment ‘分数’,</p><p>  primary key(<code>id</code>) </p><p>)engine = innodb;</p></blockquote><p>A. select distinct cid,cname from course where cid not in (select cid from course where score &gt; 60 and sid=20190001)</p><p>B. select distinct cid,cname from course where cid in (select cid from course where score &lt; 60) and sid=20190001</p><p>C. select distinct cid,cname from course where cid not in (select cid from course where score &gt; 60) and sid=20190001</p><p>D. select distinct cid,cname from course where cid in (select cid from course where score &lt; 60 and sid=20190001)</p><hr><h5 id="11-序列-20-23-28-41-61-31-71-76-15-30-构造为完全二叉树，完全二叉树再变为最小堆后，堆所对应的的中序遍历序列可能为"><a href="#11-序列-20-23-28-41-61-31-71-76-15-30-构造为完全二叉树，完全二叉树再变为最小堆后，堆所对应的的中序遍历序列可能为" class="headerlink" title="11.序列{20, 23, 28, 41, 61, 31, 71, 76, 15, 30}构造为完全二叉树，完全二叉树再变为最小堆后，堆所对应的的中序遍历序列可能为"></a>11.序列{20, 23, 28, 41, 61, 31, 71, 76, 15, 30}构造为完全二叉树，完全二叉树再变为最小堆后，堆所对应的的中序遍历序列可能为</h5><p>A. 76, 23, 41, 61, 20, 30, 31, 15, 28, 71</p><p>B. 76, 23, 41, 20, 61, 30, 15, 31, 28, 71</p><p>C. 76, 20, 41, 23, 30, 61, 15, 31, 28, 71</p><p>D. 76, 23, 20, 41, 61, 15, 31, 20, 28, 71</p><p>正确答案：B</p><hr><h5 id="12-有如下递归函数-test-n-，其时间复杂度为多少？"><a href="#12-有如下递归函数-test-n-，其时间复杂度为多少？" class="headerlink" title="12.有如下递归函数 test(n)，其时间复杂度为多少？"></a>12.有如下递归函数 test(n)，其时间复杂度为多少？</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>  <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> *  test(n - <span class="hljs-number">1</span>) + <span class="hljs-number">3</span> *  test(n - <span class="hljs-number">2</span>));<br>}<br></code></pre></td></tr></tbody></table></figure><p>A. O(logn)</p><p>B. O(nlogn)</p><p>C. O(n^2)</p><p>D. O(n^3)</p><p>E. O(2^n)</p><p>正确答案：E</p><figure class="highlight cos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">每一层递归调用两次递归，所以是<span class="hljs-number">2</span><span class="hljs-symbol">^n</span><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="13-假设磁头当前位于116道，正在向磁道序号增加的方向移动。现有一个磁道访问请求序列为48-59-37-81-125-195-185-205采用电梯调度SCAN算法得到的磁道访问序列是："><a href="#13-假设磁头当前位于116道，正在向磁道序号增加的方向移动。现有一个磁道访问请求序列为48-59-37-81-125-195-185-205采用电梯调度SCAN算法得到的磁道访问序列是：" class="headerlink" title="13.假设磁头当前位于116道，正在向磁道序号增加的方向移动。现有一个磁道访问请求序列为48, 59, 37, 81, 125, 195, 185, 205采用电梯调度SCAN算法得到的磁道访问序列是："></a>13.假设磁头当前位于116道，正在向磁道序号增加的方向移动。现有一个磁道访问请求序列为48, 59, 37, 81, 125, 195, 185, 205采用电梯调度SCAN算法得到的磁道访问序列是：</h5><p>A. 125, 185, 195, 205, 81, 59, 48, 37</p><p>B. 125, 185, 195, 205, 37, 48, 59, 81</p><p>C. 37, 48, 59, 81, 125, 185, 195, 205</p><p>D. 125, 195, 185, 205, 48, 59, 37, 81</p><p>正确答案：A</p><hr><ol start="14"><li></li></ol><p>属于同一进程的两个线程 T1和 T2并发执行，共享初值为 0 的全局变量 X。T1和 T2实现对全局变量 x 加 1 的伪代码分别如下:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">T1：<br><br>temp1=X;<br><br>temp1=temp1+<span class="hljs-number">1</span>;<br><br>X=temp1;<br><br>T2：<br><br>temp2=X;<br><br>temp2=temp2+<span class="hljs-number">1</span>;<br><br>X=temp2;<br></code></pre></td></tr></tbody></table></figure><p>2个线程进行到任意一步都能被对方打断，执行另外一个线程的代码，请问在所有可能的执行序列中，使 x 的值为 2 的序列个数有几种？</p><p>A. 1</p><p>B. 2</p><p>C. 3</p><p>D. 4</p><p>正确答案：B</p><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">T1</span>优先，<span class="hljs-built_in">T2</span>优先<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="15-shell脚本中，需求如下：如果-ls-x2F-tmp-执行成功输出True，否则输出Fail，下列哪项正确"><a href="#15-shell脚本中，需求如下：如果-ls-x2F-tmp-执行成功输出True，否则输出Fail，下列哪项正确" class="headerlink" title="15.shell脚本中，需求如下：如果 ls /tmp 执行成功输出True，否则输出Fail，下列哪项正确"></a>15.shell脚本中，需求如下：如果 ls /tmp 执行成功输出True，否则输出Fail，下列哪项正确</h5><p>A. ls /tmp; [[ $# -eq 0 ]] &amp;&amp; echo True || echo Fail</p><p>B. ls /tmp; [[ $* -eq 0 ]] &amp;&amp; echo True || echo Fail</p><p>C. ls /tmp; [[ $0 -eq 0 ]] &amp;&amp; echo True || echo Fail</p><p>D. ls /tmp; [[ $? -eq 0 ]] &amp;&amp; echo True || echo Fail</p><p>正确答案：D</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">选项 A 中的<span class="hljs-variable">$</span><span class="hljs-comment">#表示命令行参数个数，而不是上一条命令执行结果的状态码。</span><br>选项 B 中的<span class="hljs-variable">$</span>*表示所有命令行参数的字符串，而不是上一条命令执行结果的状态码。<br>选项 C 中的<span class="hljs-variable">$0</span>表示脚本名字，而不是上一条命令执行结果的状态码。<br>选项 D 中的<span class="hljs-variable">$</span>?表示上一条命令执行的状态码，如果状态码为 <span class="hljs-number">0</span>，表示命令执行成功，否则表示执行失败。<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="16-nginx-log是一个日志文件，现在想将日志的最新输出实时打印在屏幕上，用哪个命令可以实现："><a href="#16-nginx-log是一个日志文件，现在想将日志的最新输出实时打印在屏幕上，用哪个命令可以实现：" class="headerlink" title="16.nginx.log是一个日志文件，现在想将日志的最新输出实时打印在屏幕上，用哪个命令可以实现："></a>16.nginx.log是一个日志文件，现在想将日志的最新输出实时打印在屏幕上，用哪个命令可以实现：</h5><p>A. cat -f nginx.log</p><p>B. tee -f nginx.log</p><p>C. head -f nginx.log</p><p>D. tail -f nginx.log</p><p>正确答案：D</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">linux命令中<span class="hljs-built_in">cat</span>、more、less、<span class="hljs-built_in">tail</span>、<span class="hljs-built_in">head</span>均可用来查看文件内容，主要区别有：<br><br><span class="hljs-built_in">cat</span>是一次性显示整个文件的内容，适用于文件内容少的情况；<br>more和less一般用于显示文件内容超过一屏的内容，并且提供翻页的功能。<br><span class="hljs-built_in">tail</span> 和 <span class="hljs-built_in">head</span>分别显示文件的后几行和前几行内容。常用于大文件的截取。<br><br><span class="hljs-built_in">tail</span> 用来显示文件的最后几行内容，当文件内容有更新时，<span class="hljs-built_in">tail</span>会自己主动刷新，确保一直显示最新的文件内容。<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="17-由于前端直接可被用户访问，攻击者可以轻易得到页面和通讯过程中的相关信息，进而进行恶意的攻击，关于其攻击的方式描述正确的有哪些？"><a href="#17-由于前端直接可被用户访问，攻击者可以轻易得到页面和通讯过程中的相关信息，进而进行恶意的攻击，关于其攻击的方式描述正确的有哪些？" class="headerlink" title="17.由于前端直接可被用户访问，攻击者可以轻易得到页面和通讯过程中的相关信息，进而进行恶意的攻击，关于其攻击的方式描述正确的有哪些？"></a>17.由于前端直接可被用户访问，攻击者可以轻易得到页面和通讯过程中的相关信息，进而进行恶意的攻击，关于其攻击的方式描述正确的有哪些？</h5><p>A. 假定站点 foo.com 的服务器架设在公司内网，提供了任意站点截图服务 foo.com/screenshot?url=xxx，恶意修改 url 中的值为内网地址，构成 SSRF 攻击，进而造成数据泄露的风险</p><p>B. 网站 foo.com 提供 POST 方法的 /tansfer/to/xxx 的转账服务，由于未做 CSRF 的防范，被攻击者重复伪造该请求，形成重放攻击，造成经济损失</p><p>C. 网站 foo.com 使用了非安全的 HTTP 协议，其中转账服务 POST /transfer/to/xxx，转账金额 money 在 payload 上，假定接口层面采用了随机 token 来防范 csrf 攻击，接口参数未做签名校验，此时攻击者通过篡改 money 的数值，构成中间人攻击</p><p>D. 借助社会工程学的理论基础，基于用户的贪婪等心理，制作一个 qq.com 的”冒牌”中奖页面，诱导用户输入账号密码进行登录，造成隐私的泄露，属于”钓鱼”的网络欺诈行为</p><p>正确答案：ABCD</p><hr><h5 id="18-假设一个数组采用快速排序，则下面的选项中，不可能是第3趟排序结果的是"><a href="#18-假设一个数组采用快速排序，则下面的选项中，不可能是第3趟排序结果的是" class="headerlink" title="18.假设一个数组采用快速排序，则下面的选项中，不可能是第3趟排序结果的是"></a>18.假设一个数组采用快速排序，则下面的选项中，不可能是第3趟排序结果的是</h5><p>A. 4, 8, 6, 10, 12, 16, 14</p><p>B. 10, 4, 6, 8, 12, 14, 16</p><p>C. 8, 4, 6, 12, 10, 14, 16</p><p>D. 4, 8, 6, 12, 10, 16, 14</p><p>正确答案：ACD</p><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">快速排序一趟确定<span class="hljs-number">1</span>个或者<span class="hljs-number">2</span>个点的最终位置，如果是第一次，确定<span class="hljs-number">1</span>个。<br>第二次以后，如果基点在最左边或者最右边确定<span class="hljs-number">1</span>个点最终位置。<br>如果在中间，那么确定<span class="hljs-number">2</span>个点的最终位置，所以ACD全错<br>只有<span class="hljs-keyword">B</span> 选项，<span class="hljs-number">3</span>个点依次都是在最左边，快速排序可能退化成冒泡排序，是正确的<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="19-某进程创建的若干个线程，这些线程不能共享的是"><a href="#19-某进程创建的若干个线程，这些线程不能共享的是" class="headerlink" title="19.某进程创建的若干个线程，这些线程不能共享的是"></a>19.某进程创建的若干个线程，这些线程不能共享的是</h5><p>A. 程序计数器</p><p>B. 某线程的栈指针</p><p>C. 进程打开的文件</p><p>D. 全局变量</p><p>E. 进程的堆空间</p><p>正确答案：AB</p><hr><h5 id="20-tcp发送报文数据时，可能将多个数据包合并成一个大的数据包发送，就有可能发生粘包问题。以下可以用来解决这个问题的是？"><a href="#20-tcp发送报文数据时，可能将多个数据包合并成一个大的数据包发送，就有可能发生粘包问题。以下可以用来解决这个问题的是？" class="headerlink" title="20.tcp发送报文数据时，可能将多个数据包合并成一个大的数据包发送，就有可能发生粘包问题。以下可以用来解决这个问题的是？"></a>20.tcp发送报文数据时，可能将多个数据包合并成一个大的数据包发送，就有可能发生粘包问题。以下可以用来解决这个问题的是？</h5><p>A. 发送固定长度的消息</p><p>B. 包结尾增加分隔符</p><p>C. 慢开始算法</p><p>D. 把消息分成消息头和消息体，其中消息头上包含长度</p><p>E. 利用滑动窗口实现控制</p><p>正确答案：ABD</p><hr><h5 id="21-最小公倍数与最大公约数"><a href="#21-最小公倍数与最大公约数" class="headerlink" title="21.最小公倍数与最大公约数"></a>21.最小公倍数与最大公约数</h5><p>度度熊请你找出两个数<em>a</em>,<em>b</em>，满足1≤<em>a</em>,<em>b</em>≤<em>n</em>且<em>l<strong>c</strong>m</em>(<em>a</em>,<em>b</em>)−<em>g<strong>c</strong>d</em>(<em>a</em>,<em>b</em>)尽量大。输出最大的l<strong>c</strong>m*(<em>a</em>,<em>b</em>)−<em>g<strong>c</strong>d</em>(<em>a</em>,<em>b</em>).<br>其中l<strong>c</strong>m*(<em>a</em>,<em>b</em>)表示<em>a</em>和<em>b</em>的最小公倍数，g<strong>c</strong>d*(<em>a</em>,<em>b</em>)表示a<em>和</em>b*的最大公约数。</p><p>示例1</p><p>输入</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">19<br></code></pre></td></tr></tbody></table></figure><p>示例2</p><p>输入</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></tbody></table></figure><p>正确答案：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextLong();<br>        System.out.println(a*(a-<span class="hljs-number">1</span>)-<span class="hljs-number">1</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="22-还原数列"><a href="#22-还原数列" class="headerlink" title="22.还原数列"></a>22.还原数列</h5><p>老板给度度熊n<em>个数， 每一次从a</em>[<em>i</em>]中取出一个最大的减去<em>n</em>， 其他的n<em>−1个数加上1， 一直重复直到最大的a</em>[<em>i</em>]&lt;<em>n</em>， 执行次数记为<em>k</em>。<br>老板想知道最少执行多少次操作使得n<em>个数都小于n</em>呢？</p><p>示例1</p><p>输入</p><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></tbody></table></figure><p>正确答案：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>sc.nextInt();<br>        <span class="hljs-type">long</span> [] arr =<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span> [n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;n;i++){<br>            arr[i]=sc.nextLong();<br>        }<br>        <span class="hljs-type">long</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len=arr.length;<br>        <span class="hljs-keyword">while</span>(!isVaild(arr)){<br>            <span class="hljs-type">long</span> max=<span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;arr.length;i++){<br>                <span class="hljs-keyword">if</span>(arr[i]&gt;max){<br>                    max=arr[i];<br>                    index=i;<br>                }<br>            }<br>            count+=max/n;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++){<br>                arr[i]+=max/n;<br>            }<br>            arr[index]=max%n;<br>        }<br>        System.out.println(count);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVaild</span><span class="hljs-params">(<span class="hljs-type">long</span> [] arr)</span>{<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">falg</span> <span class="hljs-operator">=</span><span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i:arr){<br>            <span class="hljs-keyword">if</span>(i&gt;=arr.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> falg;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="23-树上上升序列"><a href="#23-树上上升序列" class="headerlink" title="23.树上上升序列"></a>23.树上上升序列</h5><p>度度熊给定一棵树，树上的第u<em>个节点有点权a**u</em>。请你找出一条最长的路径(<em>u</em>,<em>v</em>)，使得从u<em>沿着唯一路径走到v</em>的途中，点权不断严格递增。<br>换句话说，设路径为(<em>u</em>,<em>p</em>1​,<em>p</em>2​,…,<em>p**m</em>​,<em>v</em>)，则需要满足a<strong>u*​&lt;<em>a**p</em>1​​&lt;*a</strong>p*2​​⋯&lt;<em>a<strong>p</strong>m</em>​​&lt;<em>a**v</em>​。输出最长满足条件的路径的长度。</p><p>示例1</p><p>输入</p><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></tbody></table></figure><p>示例2</p><p>输入</p><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></tbody></table></figure><p>正确答案：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//邻接表</span><br><span class="hljs-keyword">import</span> java.util.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br>    <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) {<br>            num[i] = sc.nextInt();<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num.length; i++) {<br>            graph.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        }<br>        <span class="hljs-comment">// 构建图,邻接矩阵</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> sc.nextInt() - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sc.nextInt() - <span class="hljs-number">1</span>;<br>            graph.get(a).add(b);<br>            graph.get(b).add(a);<br>        }<br> <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num.length - <span class="hljs-number">1</span>; i++) {<br>            dfs(num, i, <span class="hljs-number">1</span>);<br>        }<br>        System.out.println(max);<br> <br>    }<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] num, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> wayNum)</span> {<br>        max = Math.max(max, wayNum);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : graph.get(start)) {<br>            <span class="hljs-keyword">if</span> (num[i] &gt; num[start]) {<br>                dfs(num, i, wayNum + <span class="hljs-number">1</span>);<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;百度校招Java研发工程师笔试卷&quot;&gt;&lt;a href=&quot;#百度校招Java研发工程师笔试卷&quot; class=&quot;headerlink&quot; title=&quot;百度校招Java研发工程师笔试卷&quot;&gt;&lt;/a&gt;百度校招Java研发工程师笔试卷&lt;/h1&gt;&lt;h5 id=&quot;1-当请求过多，超</summary>
      
    
    
    
    <category term="笔试" scheme="http://example.com/categories/%E7%AC%94%E8%AF%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="分布式锁" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    <category term="哈夫曼编码" scheme="http://example.com/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼编码</title>
    <link href="http://example.com/2023/03/29/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <id>http://example.com/2023/03/29/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</id>
    <published>2023-03-29T07:01:40.875Z</published>
    <updated>2023-03-29T07:19:43.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1.统计频率（空格也要统计）</p><p>2.排序</p><p>哈夫曼树是一个带权的二叉树，而在哈夫曼编码中，字符的出现频率就是字符的权重。因此要根据字符的频率放入优先队列中进行排序。然后根据这些字符构建一棵哈夫曼树</p><p>3.合并</p><p>进行迭代，每次都去除队列中的前面两个元素，也就是权值最小的两棵子树进行合并成一棵子树。直到最终所有的元素合并成一棵树。这棵树就是哈夫曼树。</p><p>4.进行编码</p><p>已知字符集{ a, b, c, d, e, f }，若各字符出现的次数分别为{ 6, 3, 8, 2, 10, 4 }，则对应字符集中各字符的哈夫曼编码可能是：</p><p>A. 00, 1011, 01, 1010, 11, 100</p><p>B. 00, 100, 110, 000, 0010, 01</p><p>C. 10, 1011, 11, 0011, 00, 010</p><p>D. 0011, 10, 11, 0010, 01, 000</p><p><img src="/image/Snipaste_2023-03-29_11-55-37.png"></p><hr><p>先排序</p><p><img src="/image/Snipaste_2023-03-29_11-56-35.png"></p><hr><p>两个权小的合并</p><p><img src="/image/Snipaste_2023-03-29_14-37-11.png"></p><hr><p><img src="/image/Snipaste_2023-03-29_14-39-27.png"></p><hr><p><img src="/image/Snipaste_2023-03-29_14-42-55.png"></p><hr><p>进行编码</p><p><img src="/image/Snipaste_2023-03-29_14-44-03.png"></p><p>最后结果：</p><table><thead><tr><th>字符</th><th>哈夫曼编码</th></tr></thead><tbody><tr><td>a</td><td>00</td></tr><tr><td>b</td><td>1011</td></tr><tr><td>c</td><td>01</td></tr><tr><td>d</td><td>1010</td></tr><tr><td>e</td><td>11</td></tr><tr><td>f</td><td>100</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;哈夫曼编码&quot;&gt;&lt;a href=&quot;#哈夫曼编码&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼编码&quot;&gt;&lt;/a&gt;哈夫曼编码&lt;/h1&gt;&lt;h4 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="哈夫曼树" scheme="http://example.com/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>磁盘调度算法</title>
    <link href="http://example.com/2023/03/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/03/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</id>
    <published>2023-03-29T03:45:56.635Z</published>
    <updated>2023-03-29T03:47:06.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h1><p>原文出处:<a href="https://xiaolincoding.com/os/5_schedule/schedule.html#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">小林coding</a></p><p>磁盘的结构，如下图：</p><p><img src="/image/%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.webp" alt="磁盘结构"></p><p>常见的机械磁盘是上图左边的样子，中间圆的部分是磁盘的盘片，一般会有多个盘片，每个盘面都有自己的磁头。右边的图就是一个盘片的结构，盘片中的每一层分为多个磁道，每个磁道分多个扇区，每个扇区是 <code>512</code> 字节。那么，多个具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面，如上图里中间的样子。</p><p>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的。</p><p>寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</p><p>假设有下面一个请求序列，每个数字代表磁道的位置：</p><p>98，183，37，122，14，124，65，67</p><p>初始磁头当前的位置是在第 <code>53</code> 磁道。</p><p>接下来，分别对以上的序列，作为每个调度算法的例子，那常见的磁盘调度算法有：</p><ul><li>先来先服务算法</li><li>最短寻道时间优先算法</li><li>扫描算法</li><li>循环扫描算法</li><li>LOOK 与 C-LOOK 算法</li></ul><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>先来先服务（<em>First-Come，First-Served，FCFS</em>），顾名思义，先到来的请求，先被服务。</p><p>那按照这个序列的话：</p><p>98，183，37，122，14，124，65，67</p><p>那么，磁盘的写入顺序是从左到右，如下图：</p><p><img src="/image/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1.webp" alt="磁盘调度-先来先服务"></p><p>先来先服务算法总共移动了 <code>640</code> 个磁道的距离，这么一看这种算法，比较简单粗暴，但是如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</p><h3 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h3><p>最短寻道时间优先（<em>Shortest Seek First，SSF</em>）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子：</p><p>98，183，37，122，14，124，65，67</p><p>那么，那么根据距离磁头（ 53 位置）最近的请求的算法，具体的请求则会是下列从左到右的顺序：</p><p>65，67，37，14，98，122，124，183</p><p><img src="/image/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.webp" alt="磁盘调度-最短寻道时间优先"></p><p>磁头移动的总距离是 <code>236</code> 磁道，相比先来先服务性能提高了不少。</p><p>但这个算法可能存在某些请求的<strong>饥饿</strong>，因为本次例子我们是静态的序列，看不出问题，假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里<strong>产生饥饿的原因是磁头在一小块区域来回移动</strong>。</p><h3 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h3><p>最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。</p><p>为了防止这个问题，可以规定：<strong>磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（*Scan*）算法</strong>。</p><p>这种算法也叫做电梯算法，比如电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</p><p>还是以这个序列为例子，磁头的初始位置是 53：</p><p>98，183，37，122，14，124，65，67</p><p>那么，假设扫描调度算先朝磁道号减少的方向移动，具体请求则会是下列从左到右的顺序：</p><p>37，14，<code>0</code>，65，67，98，122，124，183</p><p><img src="/image/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95.webp" alt="磁盘调度-扫描算法"></p><p>磁头先响应左边的请求，直到到达最左端（ 0 磁道）后，才开始反向移动，响应右边的请求。</p><p>扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题，中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。</p><h3 id="循环扫描算法"><a href="#循环扫描算法" class="headerlink" title="循环扫描算法"></a>循环扫描算法</h3><p>扫描算法使得每个磁道响应的频率存在差异，那么要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。</p><p>循环扫描（<em>Circular Scan, CSCAN</em> ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</p><p>还是以这个序列为例子，磁头的初始位置是 53：</p><p>98，183，37，122，14，124，65，67</p><p>那么，假设循环扫描调度算先朝磁道增加的方向移动，具体请求会是下列从左到右的顺序：</p><p>65，67，98，122，124，183，<code>199</code>，<code>0</code>，14，37</p><p><img src="/image/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-C-SCAN%E7%AE%97%E6%B3%95.webp" alt="磁盘调度-C-SCAN算法"></p><p>磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。</p><p>循环扫描算法相比于扫描算法，对于各个位置磁道响应频率相对比较平均。</p><h3 id="LOOK-与-C-LOOK算法"><a href="#LOOK-与-C-LOOK算法" class="headerlink" title="LOOK 与 C-LOOK算法"></a>LOOK 与 C-LOOK算法</h3><p>我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。</p><p>那这其实是可以优化的，优化的思路就是<strong>磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></p><p>那针对 SCAN 算法的优化则叫 LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong>。</p><p><img src="/image/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-LOOK%E7%AE%97%E6%B3%95.webp" alt="磁盘调度-LOOK算法"></p><p>而针 C-SCAN 算法的优化则叫 C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</p><p><img src="/image/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-C-LOOK%E7%AE%97%E6%B3%95.webp" alt="磁盘调度-C-LOOK算法"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;磁盘调度算法&quot;&gt;&lt;a href=&quot;#磁盘调度算法&quot; class=&quot;headerlink&quot; title=&quot;磁盘调度算法&quot;&gt;&lt;/a&gt;磁盘调度算法&lt;/h1&gt;&lt;p&gt;原文出处:&lt;a href=&quot;https://xiaolincoding.com/os/5_schedule/</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="磁盘" scheme="http://example.com/tags/%E7%A3%81%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>凹凸科技2017秋招java工程师笔试</title>
    <link href="http://example.com/2023/03/23/%E7%AC%94%E8%AF%95/%E5%87%B9%E5%87%B8%E7%A7%91%E6%8A%802017%E7%A7%8B%E6%8B%9Bjava%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95/"/>
    <id>http://example.com/2023/03/23/%E7%AC%94%E8%AF%95/%E5%87%B9%E5%87%B8%E7%A7%91%E6%8A%802017%E7%A7%8B%E6%8B%9Bjava%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95/</id>
    <published>2023-03-23T12:03:10.614Z</published>
    <updated>2023-03-27T10:46:50.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="凹凸科技2017秋招java工程师笔试"><a href="#凹凸科技2017秋招java工程师笔试" class="headerlink" title="凹凸科技2017秋招java工程师笔试"></a>凹凸科技2017秋招java工程师笔试</h1><h5 id="1-GC是什么？为什么要有GC？"><a href="#1-GC是什么？为什么要有GC？" class="headerlink" title="1.GC是什么？为什么要有GC？"></a>1.GC是什么？为什么要有GC？</h5><p>正确答案：</p><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">在<span class="hljs-keyword">java语言中，垃圾回收（Garbage </span>Collection，GC）的主要作用是回收程序中不再使用的内存。 <br>为了减轻开发人员的工作，同时增加系统的安全性和稳定性，<span class="hljs-keyword">java语言提供了垃圾回收器来自动检测对象的作用域，</span><br><span class="hljs-keyword"></span>可自动地把不再被使用的存储空间释放掉。主要的任务是：分配内存，回收不再被引用的对象的内存空间。 <br>垃圾回收器提高了开发人员的开发效率，保证程序的稳定性，但是也带来了问题，为了处理垃圾回收，<br>垃圾回收器必须跟踪内存的使用情况，释放没用的对象，在完成内存的释放后还需要处理堆中的碎片，<br>这些操作增加<span class="hljs-keyword">JVM的负担，从而降低了程序的执行效率。</span><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="2-简述final，finalize，finally的区别？"><a href="#2-简述final，finalize，finally的区别？" class="headerlink" title="2.简述final，finalize，finally的区别？"></a>2.简述final，finalize，finally的区别？</h5><p>正确答案：</p><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-number">1.</span> <span class="hljs-keyword">final</span>是关键字，<span class="hljs-keyword">final</span>可以修饰类、方法、属性。<br>    如果一个类被<span class="hljs-keyword">final</span>修饰，那么这个类就是最终类，不能派生出新的子类，不能作为父类被继承，该类中的所有方法都不能被重写，但是<span class="hljs-keyword">final</span>类中的成员变量是可以改变的，要想<span class="hljs-keyword">final</span>类中的成员变量的不可以改变，必须给成员变量添加<span class="hljs-keyword">final</span>修饰。因此，一个类不能同时被<span class="hljs-keyword">final</span>和<span class="hljs-keyword">abstract</span>修饰，这两个关键字相互矛盾。<br>    如果<span class="hljs-keyword">final</span>修饰方法，那么这个方法是最终方法，不允许任何子类重写该方法，但子类仍可以使用该方法，注意：<span class="hljs-keyword">final</span>参数用来表示这个参数在这个函数内部不允许被修改。<br>    <span class="hljs-keyword">final</span>修饰属性，被<span class="hljs-keyword">final</span>修饰的变量不可变。这里的不可变有两重含义：引用不可变和对象不可变。<span class="hljs-keyword">final</span>指的是引用不可变，即它只能指向初始化时指向的那个对象，而不关心指向对象内容的变化。因此，被<span class="hljs-keyword">final</span>修饰的变量必须初始化，该变量其实就是常量。<br><span class="hljs-number">2.</span> <span class="hljs-keyword">finally</span>作为异常处理的一部分，只能用在<span class="hljs-keyword">try</span>/<span class="hljs-keyword">catch</span>语句快中，<span class="hljs-keyword">finally</span>代码块中的语句一定会被执行，经常被用来释放资源，如IO流和数据库资源的释放。<br><span class="hljs-number">3.</span> finalize是<span class="hljs-built_in">Object</span>类的一个方法，该方法在<span class="hljs-built_in">Object</span>类中声明：<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span>() <span class="hljs-keyword">throws</span> Throwable { } <br>    在垃圾回收器执行时会调用被回收对象的<span class="hljs-title function_">finalize</span>()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放某个对象占用的空间，将首先调该对象的<br><span class="hljs-title function_">finalize</span>()方法，并且在下一次垃圾回收动作发生时，才真正将该对象占用的内存回收。<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="3-Abstract-class和interface有什么区别？"><a href="#3-Abstract-class和interface有什么区别？" class="headerlink" title="3.Abstract class和interface有什么区别？"></a>3.Abstract class和interface有什么区别？</h5><p>正确答案：</p><table><thead><tr><th></th><th>Abstract class</th><th>Interface</th></tr></thead><tbody><tr><td>实例化</td><td>不能</td><td>不能</td></tr><tr><td>类</td><td>一种继承关系，一个类只能使用一次继承关系。可以通过继承多个接口实现多重继承</td><td>一个类可以实现多个interface</td></tr><tr><td>数据成员</td><td>可有自己的</td><td>静态的不能被修改即必须是static final，一般不在此定义</td></tr><tr><td>方法</td><td>可以私有的，非abstract方法，必须实现</td><td>不可有私有的，默认是public，abstract 类型</td></tr><tr><td>变量</td><td>可有私有的，默认是friendly 型，其值可以在子类中重新定义，也可以重新赋值</td><td>不可有私有的，默认是public static final 型，且必须给其初值，实现类中不能重新定义，不能改变其值。</td></tr><tr><td>设计理念</td><td>表示的是“is-a”关系</td><td>表示的是“like-a”关系</td></tr><tr><td>实现</td><td>需要继承，要用extends</td><td>要用implements</td></tr></tbody></table><p>扩展：java8的接口新特性（可以有方法体的接口）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span>{<br>    String <span class="hljs-title function_">myNewName</span><span class="hljs-params">(String newName)</span>;<br> <br>    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">myOldName</span><span class="hljs-params">()</span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"chao"</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="4-Java内存管理"><a href="#4-Java内存管理" class="headerlink" title="4.Java内存管理"></a>4.Java内存管理</h5><p>（1）请描述java的内存管理原理 </p><p>（2）请描述java的内存分区 </p><p>（3）请描述java的对象生命周期，以及对象的访问？</p><p>正确答案：</p><p>（1）请描述java的内存管理原理 </p><figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Java的内存管理就是对象的分配和释放</span><br><span class="hljs-keyword"></span>在<span class="hljs-keyword">Java中，内存的分配是由程序完成的，</span><br><span class="hljs-keyword"></span>而内存的释放是由垃圾收集器(Garbage Collection，GC)完成的 <br></code></pre></td></tr></tbody></table></figure><p>（2）请描述java的内存分区 </p><p><img src="/image/v2-7a7c516c0aeb622705c86fd9b5e8c44a_720w.webp"></p><p>（3）请描述java的对象生命周期，以及对象的访问？</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">生命周期：  <br><span class="hljs-number">1</span>.创建阶段(Created)<br><span class="hljs-number">2</span>.应用阶段(In Use)：一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段<br><span class="hljs-number">3</span>.不可见阶段(Invisible)：例如我在for里面定义了<span class="hljs-selector-tag">i</span> for循环break了就不能访问<span class="hljs-selector-tag">i</span><br><span class="hljs-number">4</span>.不可达阶段(Unreachable)：对象处于不可达阶段是指该对象不再被任何强引用所持有。<br><span class="hljs-number">5</span>.收集阶段(Collected)：当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。<br><span class="hljs-number">6</span>.终结阶段(Finalized)：当对象执行完<span class="hljs-built_in">finalize</span>()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。<br><span class="hljs-number">7</span>.对象空间重分配阶段(De-allocated)：垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”<br></code></pre></td></tr></tbody></table></figure><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">句柄访问方式：java堆中将划分出一块内存来作为句柄池，<span class="hljs-built_in">ref</span>erence中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。 指针访问方式：<span class="hljs-built_in">ref</span>erence变量中直接存储的就是对象的地址，而java堆对象一部分存储了对象实例数据，另外一部分存储了对象类型数据<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="5-指出以下程序的输出或错误。"><a href="#5-指出以下程序的输出或错误。" class="headerlink" title="5.指出以下程序的输出或错误。"></a>5.指出以下程序的输出或错误。</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>{<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> b)</span>{<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">long</span> b)</span>{<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>{<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">char</span> b)</span>{<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>正确答案：</p><figure class="highlight wren"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs wren">    <span class="hljs-title function_">publicvoidmethod</span>(<span class="hljs-params">inta</span>){<br>    }<br>    <span class="hljs-title function_">publicvoidmethod</span>(<span class="hljs-params">intb</span>){<br>    }<br>   <br>方法重载不以返回值类型为判断，重载通过不同的方法参数来区分，如不同的参数个数，不同的参数类型，不同的参数顺序；这<span class="hljs-number">2</span>个方法错误。<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="6-指出以下程序的输出或者错误"><a href="#6-指出以下程序的输出或者错误" class="headerlink" title="6.指出以下程序的输出或者错误"></a>6.指出以下程序的输出或者错误</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>{<br> Person(){<br>   System.out.println(<span class="hljs-string">"create person"</span>);  <br> }<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>{<br>   <span class="hljs-keyword">return</span><span class="hljs-string">"Person"</span>;<br> }<br>}<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>{<br> Teacher(){<br>   System.out.println(<span class="hljs-string">"create teacher"</span>);  <br>   <span class="hljs-built_in">super</span>();<br> }<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>{<br>   <span class="hljs-keyword">return</span><span class="hljs-string">"Teacher"</span>;<br> }<br>}<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>{<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{<br>   <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>   <span class="hljs-type">Person</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>   System.out.println(person.getName());<br>   System.out.println(teacher.getName());<br> }<br>}<br></code></pre></td></tr></tbody></table></figure><p>正确答案：</p><figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">super</span>要在构造函数第一行使用<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="7-假设树的节点的data类型为int型，请实现两棵树是否相等的比较？"><a href="#7-假设树的节点的data类型为int型，请实现两棵树是否相等的比较？" class="headerlink" title="7.假设树的节点的data类型为int型，请实现两棵树是否相等的比较？"></a>7.假设树的节点的data类型为int型，请实现两棵树是否相等的比较？</h5><p> 注:A,B两棵树相等且当rootA-&gt;data==rootB-&gt;data，而且A和B的左右子树相等或者左右互换后相等。</p><p> （1）给出树节点的结构定义 </p><p>（2）写出实现思路，以及复杂度估计 </p><p>（3）用你习惯的语言或者伪代码实现该算法</p><p>正确答案：</p><p>（1）给出树节点的结构定义 </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> {<br>    <span class="hljs-type">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br><br>    TreeNode() {<br>    }<br><br>    TreeNode(<span class="hljs-type">int</span> val) {<br>        <span class="hljs-built_in">this</span>.val = val;<br>    }<br><br>    TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) {<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>（3）用你习惯的语言或者伪代码实现该算法</p><p>与LeetCode<a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a>相识</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equation</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> {<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span> &amp;&amp; root2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span> || root2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> (root1.val == root2.val)<br>                &amp;&amp; equation(root1.left,root2.left)<br>                &amp;&amp; equation(root1.right,root2.right);<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="8-假设基本数据为整型，输入为一串无序的整数，请用堆排序的方式对该整数串排序（增序），有重复时保留重复的数。"><a href="#8-假设基本数据为整型，输入为一串无序的整数，请用堆排序的方式对该整数串排序（增序），有重复时保留重复的数。" class="headerlink" title="8.假设基本数据为整型，输入为一串无序的整数，请用堆排序的方式对该整数串排序（增序），有重复时保留重复的数。"></a>8.假设基本数据为整型，输入为一串无序的整数，请用堆排序的方式对该整数串排序（增序），有重复时保留重复的数。</h5><p> 测试数据:[3,6,23,4,3,2,9,10,18,11] </p><p>（1）堆排序的思想，使用情况一般是什么？</p><p>（2）算法所需要的数据结构？ </p><p>（3）用你习惯的语言或者伪代码实现你的算法？</p><p>正确答案：</p><p>（1）堆排序的思想，使用情况一般是什么？</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。<br><br>每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。<br></code></pre></td></tr></tbody></table></figure><p>（2）算法所需要的数据结构？</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">使用线性数据结构比如数组就可以实现堆排序<br></code></pre></td></tr></tbody></table></figure><p>（3）用你习惯的语言或者伪代码实现你的算法？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSort</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">int</span>[] arr = {<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>};<br>        sort(arr);<br>        System.out.println(Arrays.toString(arr));<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {<br>            adjustHeap(arr, i, arr.length);<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) {<br>            swap(arr, <span class="hljs-number">0</span>, j);<br>            adjustHeap(arr, <span class="hljs-number">0</span>, j);<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> length)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; k &lt; length; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) {<br>            <span class="hljs-keyword">if</span> (k + <span class="hljs-number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="hljs-number">1</span>]) {<br>                k++;<br>            }<br>            <span class="hljs-keyword">if</span> (arr[k] &gt; temp) <br>                arr[i] = arr[k];<br>                i = k;<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>        arr[i] = temp;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[a];<br>        arr[a] = arr[b];<br>        arr[b] = temp;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="9-输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和是输入的那个数字，要求时间复杂度为O-n-，如果有多对数字的和等于输入的数字，输出任意一对即可。"><a href="#9-输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和是输入的那个数字，要求时间复杂度为O-n-，如果有多对数字的和等于输入的数字，输出任意一对即可。" class="headerlink" title="9.输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和是输入的那个数字，要求时间复杂度为O(n)，如果有多对数字的和等于输入的数字，输出任意一对即可。"></a>9.输入一个已经按升序排序过的数组和一个数字，在数组中查找两个数，使得它们的和是输入的那个数字，要求时间复杂度为O(n)，如果有多对数字的和等于输入的数字，输出任意一对即可。</h5><p>正确答案：</p><p>同LeetCode<a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a>，因题目比LeetCode多一个条件，可用以下方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findAns</span><span class="hljs-params">(<span class="hljs-type">int</span>[] data, <span class="hljs-type">int</span> sum)</span> {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> data.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> size-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (begin &lt; size &amp;&amp; end &gt;=<span class="hljs-number">0</span> &amp;&amp; begin &lt; end) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cu</span> <span class="hljs-operator">=</span> data[begin] + data[end];<br>        <span class="hljs-keyword">if</span> (cu &gt; sum) {<br>            end --;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cu &lt; sum) {<br>            begin ++;<br>        } <span class="hljs-keyword">else</span> {<br>            System.out.println(data[begin] + <span class="hljs-string">" "</span> + data[end]);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>    }<br>    System.out.println(<span class="hljs-string">"无匹配项"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>LeetCode<a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a>解法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) {<br>        HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) {<br>            <span class="hljs-keyword">if</span> (map.containsKey(target-nums[i])) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{map.get(target-nums[i]),i};<br>            }<br>            map.put(nums[i],i);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{};<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="10-输入一个英文句子，翻转句子中的顺序，但单词内字符的顺序不变，句子中单词以空格隔开，为简单起见。标点符号和普通字母一样处理，例如输入”i-am-a-student”-则输出”student-a-am-I”"><a href="#10-输入一个英文句子，翻转句子中的顺序，但单词内字符的顺序不变，句子中单词以空格隔开，为简单起见。标点符号和普通字母一样处理，例如输入”i-am-a-student”-则输出”student-a-am-I”" class="headerlink" title="10.输入一个英文句子，翻转句子中的顺序，但单词内字符的顺序不变，句子中单词以空格隔开，为简单起见。标点符号和普通字母一样处理，例如输入”i am a student”.则输出”student a am I”"></a>10.输入一个英文句子，翻转句子中的顺序，但单词内字符的顺序不变，句子中单词以空格隔开，为简单起见。标点符号和普通字母一样处理，例如输入”i am a student”.则输出”student a am I”</h5><p>正确答案：</p><p>同LeetCode<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> trimSpaces(s);<br>        <span class="hljs-comment">// 翻转字符串</span><br>        reverse(sb, <span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 翻转每个单词</span><br>        reverseEachWord(sb);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    }<br><br>    <span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title function_">trimSpaces</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = s.length() - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="hljs-string">' '</span>) {<br>            ++left;<br>        }<br>        <br>        <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="hljs-string">' '</span>) {<br>            --right;<br>        }<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (left &lt;= right) {<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(left);<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">' '</span>) {<br>                sb.append(c);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sb.charAt(sb.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">' '</span>) {<br>                sb.append(c);<br>            }<br><br>            ++left;<br>        }<br>        <span class="hljs-keyword">return</span> sb;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(StringBuilder sb, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> {<br>        <span class="hljs-keyword">while</span> (left &lt; right) {<br>            <span class="hljs-type">char</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> sb.charAt(left);<br>            sb.setCharAt(left++, sb.charAt(right));<br>            sb.setCharAt(right--, tmp);<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(StringBuilder sb)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sb.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (start &lt; n) {<br>            <span class="hljs-keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="hljs-string">' '</span>) {<br>                ++end;<br>            }<br>            reverse(sb, start, end - <span class="hljs-number">1</span>);<br>            start = end + <span class="hljs-number">1</span>;<br>            ++end;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="11-请用java，实现Stack类或者Queue类，支持该数据结构的基本操作。"><a href="#11-请用java，实现Stack类或者Queue类，支持该数据结构的基本操作。" class="headerlink" title="11.请用java，实现Stack类或者Queue类，支持该数据结构的基本操作。"></a>11.请用java，实现Stack类或者Queue类，支持该数据结构的基本操作。</h5><p>正确答案：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> {  <br>         <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">LinkedList</span> <span class="hljs-variable">ll</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();  <br>         <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(Object obj)</span>{  <br>                ll.addFirst(obj);  <br>        }  <br>         <br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>{  <br>                <span class="hljs-keyword">return</span> ll.removeFirst();  <br>        }  <br>         <br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>{  <br>                <span class="hljs-keyword">return</span> ll.getFirst();  <br>        }  <br>         <br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span>{  <br>                <span class="hljs-keyword">return</span> ll.isEmpty();  <br>        }  <br>} <br></code></pre></td></tr></tbody></table></figure><hr><h5 id="12-设计线程类WorkThead，其构造函数接收一个message字符串作为参数，把该字符串打印到console上，同时，在WorkThread的main函数中启动该线程"><a href="#12-设计线程类WorkThead，其构造函数接收一个message字符串作为参数，把该字符串打印到console上，同时，在WorkThread的main函数中启动该线程" class="headerlink" title="12.设计线程类WorkThead，其构造函数接收一个message字符串作为参数，把该字符串打印到console上，同时，在WorkThread的main函数中启动该线程"></a>12.设计线程类WorkThead，其构造函数接收一个message字符串作为参数，把该字符串打印到console上，同时，在WorkThread的main函数中启动该线程</h5><p>正确答案：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class WorkThead <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>{<br>    String message;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WorkThead</span><span class="hljs-params">(Stirng message)</span>{<br>        <span class="hljs-built_in">this</span>.message=message;<br>        System.Out.PrintIn(message);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>{<br>         <br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span>{<br>        WorkThead（<span class="hljs-string">"hello world!"</span>）.start();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;凹凸科技2017秋招java工程师笔试&quot;&gt;&lt;a href=&quot;#凹凸科技2017秋招java工程师笔试&quot; class=&quot;headerlink&quot; title=&quot;凹凸科技2017秋招java工程师笔试&quot;&gt;&lt;/a&gt;凹凸科技2017秋招java工程师笔试&lt;/h1&gt;&lt;h5 i</summary>
      
    
    
    
    <category term="笔试" scheme="http://example.com/categories/%E7%AC%94%E8%AF%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="GC" scheme="http://example.com/tags/GC/"/>
    
    <category term="interface" scheme="http://example.com/tags/interface/"/>
    
    <category term="abstract" scheme="http://example.com/tags/abstract/"/>
    
    <category term="线程类" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>点我达2019届校招Java开发笔试</title>
    <link href="http://example.com/2023/03/21/%E7%AC%94%E8%AF%95/%E7%82%B9%E6%88%91%E8%BE%BE2019%E5%B1%8A%E6%A0%A1%E6%8B%9BJava%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%95/"/>
    <id>http://example.com/2023/03/21/%E7%AC%94%E8%AF%95/%E7%82%B9%E6%88%91%E8%BE%BE2019%E5%B1%8A%E6%A0%A1%E6%8B%9BJava%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%95/</id>
    <published>2023-03-21T11:14:07.098Z</published>
    <updated>2023-03-21T11:25:00.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="点我达2019届校招Java开发笔试"><a href="#点我达2019届校招Java开发笔试" class="headerlink" title="点我达2019届校招Java开发笔试"></a>点我达2019届校招Java开发笔试</h1><h5 id="1-统计各部门平均年龄，其中三部门人员平均年龄分别为38岁、24岁、42岁。A和B-两部门人员平均年龄为30岁，B和C两部门人员平均年龄为34岁。这三个部门全体人员的平均年龄为多少岁？"><a href="#1-统计各部门平均年龄，其中三部门人员平均年龄分别为38岁、24岁、42岁。A和B-两部门人员平均年龄为30岁，B和C两部门人员平均年龄为34岁。这三个部门全体人员的平均年龄为多少岁？" class="headerlink" title="1.统计各部门平均年龄，其中三部门人员平均年龄分别为38岁、24岁、42岁。A和B 两部门人员平均年龄为30岁，B和C两部门人员平均年龄为34岁。这三个部门全体人员的平均年龄为多少岁？"></a>1.统计各部门平均年龄，其中三部门人员平均年龄分别为38岁、24岁、42岁。A和B 两部门人员平均年龄为30岁，B和C两部门人员平均年龄为34岁。这三个部门全体人员的平均年龄为多少岁？</h5><p>A. 34</p><p>B. 35</p><p>C. 36</p><p>D. 37</p><p>正确答案：B</p><p>本题考查计算中的平均数。依题设A部门x人,B部门y人, C部门z人，根据“A和B两部门人员平均年龄为30岁”可得：38x+24y=30(x+y)，求得x：y=3：4，x=0.75y;又根据“B和C两部门人员平均年龄为34岁”可得：24y+42z=34(y+z)，求得y：z=4：5，那么，x：y：z=3：4：5，那么设三者人数分别是3a、4a、5a，部门总人数=12a，平均年龄=(38×3a + 24×4a + 42×5a)÷12a，利用尾数法可知，括号内各项相加后尾数为0，只有35乘以12尾数为0。</p><hr><h5 id="2-以下数据结构的说法，错误的是"><a href="#2-以下数据结构的说法，错误的是" class="headerlink" title="2.以下数据结构的说法，错误的是"></a>2.以下数据结构的说法，错误的是</h5><p>A. 红黑树插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn)</p><p>B. B+树插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn)</p><p>C. Hash表插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(n)</p><p>D. 排序链表插入操作的平均时间复杂度为O(n)，最坏时间复杂度为O(n)</p><p>正确答案：C</p><p><img src="/image/105_1411202746369_3.png"></p><p>哈希表插入的时间复杂度与冲突次数有关，O(冲突次数/n)，最好的情况冲突次数为0,直接插入，时间复杂度为O(1)。最坏情况是所有值对应同一个键值，这是冲突次数最多，为0+1+2+3+4+…+(n-1)=n*(n-1)/2,平均比较次数为(n-1)/2,时间复杂度为O(n)</p><hr><h5 id="3-用直接插入排序方法对下面4个序列进行排序-由小到大-元素比较次数最少的是"><a href="#3-用直接插入排序方法对下面4个序列进行排序-由小到大-元素比较次数最少的是" class="headerlink" title="3.用直接插入排序方法对下面4个序列进行排序(由小到大),元素比较次数最少的是"></a>3.用直接插入排序方法对下面4个序列进行排序(由小到大),元素比较次数最少的是</h5><p>A. 88,95,12,88,21,54,23,79</p><p>B. 95,21,79,88,54,23,39,12</p><p>C. 39,54,21,79,88,23,95,12</p><p>D. 12,21,23,39,79,54,88,95</p><p>正确答案：D</p><p>逆序越少的序列，在 直接插入排序 中比较次数是越少的</p><hr><h5 id="4-三个进程A，B，C。单核CPU执行时，需要以下资源。其中优先级高的进程可以抢占CPU资源但不能抢占IO资源。所有任务执行完毕时候，需要多长时间？"><a href="#4-三个进程A，B，C。单核CPU执行时，需要以下资源。其中优先级高的进程可以抢占CPU资源但不能抢占IO资源。所有任务执行完毕时候，需要多长时间？" class="headerlink" title="4.三个进程A，B，C。单核CPU执行时，需要以下资源。其中优先级高的进程可以抢占CPU资源但不能抢占IO资源。所有任务执行完毕时候，需要多长时间？"></a>4.三个进程A，B，C。单核CPU执行时，需要以下资源。其中优先级高的进程可以抢占CPU资源但不能抢占IO资源。所有任务执行完毕时候，需要多长时间？</h5><p><img src="/image/Snipaste_2023-03-21_17-58-02.png"></p><p>A. 170ms</p><p>B. 200ms</p><p>C. 240ms</p><p>D. 270ms</p><p>正确答案：B</p><p><img src="/image/1328940_1521735302471_425DB0E95E3B0B63D006DBDB55AA7538.png">优先级：A&gt;B&gt;C </p><p>  A先I/O后CPU，这时候CPU是空闲的。B先CPU后I/O，C先CPU后I/O，B的优先级比C高，B先进行CPU操作； </p><p>  B执行完CPU操作以后A还在进行I/O操作，这时候C进行CPU操作，B等A的I/O执行完以后再进行操作； </p><p>  C执行完CPU操作以后，A还没执行完I/O操作，C也等着； </p><p>  A执行完I/O操作以后，B比C的优先级高，B进行I/O操作，A进行CPU操作，C等候。 </p><p>  B执行完I/O操作以后，C再操作</p><hr><h5 id="5-针对二分查找算法，假设一个有序数组有-136-个元素，那么要查找到第-10-个元素，-需要比较的元素为"><a href="#5-针对二分查找算法，假设一个有序数组有-136-个元素，那么要查找到第-10-个元素，-需要比较的元素为" class="headerlink" title="5.针对二分查找算法，假设一个有序数组有 136 个元素，那么要查找到第 10 个元素， 需要比较的元素为"></a>5.针对二分查找算法，假设一个有序数组有 136 个元素，那么要查找到第 10 个元素， 需要比较的元素为</h5><p>A. 68,34,17,9,13,11,10</p><p>B. 68,34,17,8,12,10</p><p>C. 69,35,18,10</p><p>D. 68,34,18,9,13,11,10</p><p>正确答案：B</p><p><img src="/image/7670357_1535630115432_53CEA007563557CCA6E2FD0CDA1861DB.jpg"></p><hr><h5 id="6-入栈序列是：a1-a3-a5-a2-a4-a6-出栈序列是：a5-a4-a2-a6-a3-a1，则栈的容量最小是"><a href="#6-入栈序列是：a1-a3-a5-a2-a4-a6-出栈序列是：a5-a4-a2-a6-a3-a1，则栈的容量最小是" class="headerlink" title="6.入栈序列是：a1,a3,a5,a2,a4,a6,出栈序列是：a5,a4,a2,a6,a3,a1，则栈的容量最小是"></a>6.入栈序列是：a1,a3,a5,a2,a4,a6,出栈序列是：a5,a4,a2,a6,a3,a1，则栈的容量最小是</h5><p>A. 5</p><p>B. 3</p><p>C. 6</p><p>D. 4</p><p>正确答案：D</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">1                         1<br>3                        <span class="hljs-number"> 1 </span>3<br>5                        <span class="hljs-number"> 1 </span>3 5<br>-                        <span class="hljs-number"> 1 </span>3                     5<br>2                        <span class="hljs-number"> 1 </span>3 2<br>4                        <span class="hljs-number"> 1 </span>3<span class="hljs-number"> 2 </span>4<br>-                        <span class="hljs-number"> 1 </span>3<span class="hljs-number"> 2 </span>                  4<br>-                        <span class="hljs-number"> 1 </span>3                     2<br>6                        <span class="hljs-number"> 1 </span>3<span class="hljs-number"> 6 </span>             <br>-                        <span class="hljs-number"> 1 </span>3                     6<br>-                        <span class="hljs-number"> 1 </span>                      3<br>-                                                 1<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="7-在现代计算机上，即使是单核单CPU系统，一个程序的死循环bug，也不会导致别的程序完全得不到时间运行，这跟哪些因素有关？"><a href="#7-在现代计算机上，即使是单核单CPU系统，一个程序的死循环bug，也不会导致别的程序完全得不到时间运行，这跟哪些因素有关？" class="headerlink" title="7.在现代计算机上，即使是单核单CPU系统，一个程序的死循环bug，也不会导致别的程序完全得不到时间运行，这跟哪些因素有关？"></a>7.在现代计算机上，即使是单核单CPU系统，一个程序的死循环bug，也不会导致别的程序完全得不到时间运行，这跟哪些因素有关？</h5><p>A. 时钟中断</p><p>B. OS进程（线程）时间片划分</p><p>C. 虚拟内存机制</p><p>D. OS抢占式调度</p><p>正确答案：ABD</p><hr><h5 id="8-Linux-系统中列出当前占用8080端口进程的命令1"><a href="#8-Linux-系统中列出当前占用8080端口进程的命令1" class="headerlink" title="8.Linux 系统中列出当前占用8080端口进程的命令1"></a>8.Linux 系统中列出当前占用8080端口进程的命令1</h5><p>正确答案：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lsof -i:8080<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="9-21点是一种扑克游戏。如果玩家拿到扑克牌的点数总和超过21点则称为爆点，被判失败。其中A牌可以被记为11点或者1点，J-Q-K-都记为10点。如果用一副牌玩游戏（52张牌），玩家手上拿到一个K和6。那他再抽两张牌会爆点的可能性约有多大？"><a href="#9-21点是一种扑克游戏。如果玩家拿到扑克牌的点数总和超过21点则称为爆点，被判失败。其中A牌可以被记为11点或者1点，J-Q-K-都记为10点。如果用一副牌玩游戏（52张牌），玩家手上拿到一个K和6。那他再抽两张牌会爆点的可能性约有多大？" class="headerlink" title="9.21点是一种扑克游戏。如果玩家拿到扑克牌的点数总和超过21点则称为爆点，被判失败。其中A牌可以被记为11点或者1点，J, Q, K 都记为10点。如果用一副牌玩游戏（52张牌），玩家手上拿到一个K和6。那他再抽两张牌会爆点的可能性约有多大？"></a>9.21点是一种扑克游戏。如果玩家拿到扑克牌的点数总和超过21点则称为爆点，被判失败。其中A牌可以被记为11点或者1点，J, Q, K 都记为10点。如果用一副牌玩游戏（52张牌），玩家手上拿到一个K和6。那他再抽两张牌会爆点的可能性约有多大？</h5><p>正确答案：</p><p>93.7% 或 93.8% </p><hr><h5 id="10-已知二叉树的中序遍历结果为MFLEDABKCGHJI，后序遍历结果为FELMDKHGJICBA，则其先序遍历结果为"><a href="#10-已知二叉树的中序遍历结果为MFLEDABKCGHJI，后序遍历结果为FELMDKHGJICBA，则其先序遍历结果为" class="headerlink" title="10.已知二叉树的中序遍历结果为MFLEDABKCGHJI，后序遍历结果为FELMDKHGJICBA，则其先序遍历结果为"></a>10.已知二叉树的中序遍历结果为MFLEDABKCGHJI，后序遍历结果为FELMDKHGJICBA，则其先序遍历结果为</h5><p>正确答案：</p><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ADMLFEBCKIJGH</span><br></code></pre></td></tr></tbody></table></figure><p><img src="/image/794224367_1552819658034_46AB337EAF03E990FA44D325F26F96CF.png"></p><hr><h5 id="11-为了解决进程间的同步和互斥问题，通常采用一种称为信号量机制的方法。若系统中有7个进程共享若干个资源R，每个进程都需要6个资源R，那么使系统不发生死锁的资源R的最少数目是"><a href="#11-为了解决进程间的同步和互斥问题，通常采用一种称为信号量机制的方法。若系统中有7个进程共享若干个资源R，每个进程都需要6个资源R，那么使系统不发生死锁的资源R的最少数目是" class="headerlink" title="11.为了解决进程间的同步和互斥问题，通常采用一种称为信号量机制的方法。若系统中有7个进程共享若干个资源R，每个进程都需要6个资源R，那么使系统不发生死锁的资源R的最少数目是"></a>11.为了解决进程间的同步和互斥问题，通常采用一种称为信号量机制的方法。若系统中有7个进程共享若干个资源R，每个进程都需要6个资源R，那么使系统不发生死锁的资源R的最少数目是</h5><p>正确答案：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">36<br></code></pre></td></tr></tbody></table></figure><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">用银行家算法计算死锁时，假设有m个共享资源，n个进程，每个进程所需的最大资源数为w，那么仅是m&gt;n*(w-<span class="hljs-number">1</span>)时，才会不死锁。如果每个进程所需的资源数不同，则先平均分配，只要有一个进程满足了资源要求，就不会死锁。<br><br>不会发生死锁的资源数m &gt; n * (w-<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-number">7</span> * (<span class="hljs-number">6</span> - <span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-number">7</span> * <span class="hljs-number">5</span> <span class="hljs-operator">=</span> <span class="hljs-number">35</span><br>最少： <span class="hljs-number">36</span>个<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="12-假设某一虚拟存储系统采用先进先出（FIFO）页面淘汰算法，有一个进程在内存中占3页（开始时内存为空），当访问如下页面序列号后1-2-3-1-2-4-2-3-5-3-4-5-6会产生几次缺页"><a href="#12-假设某一虚拟存储系统采用先进先出（FIFO）页面淘汰算法，有一个进程在内存中占3页（开始时内存为空），当访问如下页面序列号后1-2-3-1-2-4-2-3-5-3-4-5-6会产生几次缺页" class="headerlink" title="12.假设某一虚拟存储系统采用先进先出（FIFO）页面淘汰算法，有一个进程在内存中占3页（开始时内存为空），当访问如下页面序列号后1,2,3,1,2,4,2,3,5,3,4,5,6会产生几次缺页"></a>12.假设某一虚拟存储系统采用先进先出（FIFO）页面淘汰算法，有一个进程在内存中占3页（开始时内存为空），当访问如下页面序列号后1,2,3,1,2,4,2,3,5,3,4,5,6会产生几次缺页</h5><p>正确答案：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></tbody></table></figure><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> 依次进入缺页产生次数为<span class="hljs-number">3</span>  接下来<span class="hljs-number">1</span> <span class="hljs-number">2</span> 存在，<span class="hljs-number">4</span>没有 则<span class="hljs-number">1</span>出 现在为<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> ，次数加<span class="hljs-number">1</span>则为<span class="hljs-number">4</span> ，<span class="hljs-number">2</span> <span class="hljs-number">3</span> 存在 <span class="hljs-number">5</span>没有则 <span class="hljs-number">2</span>出，缺页次数加<span class="hljs-number">1</span>后为<span class="hljs-number">5</span>，现在为 <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> ，<span class="hljs-number">5</span>存在，<span class="hljs-number">6</span>没有则<span class="hljs-number">3</span>出现在为 <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> ，缺页次数加<span class="hljs-number">1</span> 为<span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure><hr><h5 id="13-若磁头的当前位置在第100磁道，现在有一磁盘读写请求序列如下：32-286-125-192-28-41-297-413-29-64-80-4。若采用最短寻道时间优先算法，则平均寻道长度是多少？"><a href="#13-若磁头的当前位置在第100磁道，现在有一磁盘读写请求序列如下：32-286-125-192-28-41-297-413-29-64-80-4。若采用最短寻道时间优先算法，则平均寻道长度是多少？" class="headerlink" title="13.若磁头的当前位置在第100磁道，现在有一磁盘读写请求序列如下：32,286,125,192,28,41,297,413,29,64,80,4。若采用最短寻道时间优先算法，则平均寻道长度是多少？"></a>13.若磁头的当前位置在第100磁道，现在有一磁盘读写请求序列如下：32,286,125,192,28,41,297,413,29,64,80,4。若采用最短寻道时间优先算法，则平均寻道长度是多少？</h5><p>正确答案：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">42</span>.<span class="hljs-number">08</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">磁盘最短寻道时间优先算法：<br>从100开始依次搜索顺序：80，64，41，32，29，28，4，125，192，286，297，413<br> 寻道长：20<span class="hljs-string">+16</span><span class="hljs-string">+23</span><span class="hljs-string">+9</span><span class="hljs-string">+3</span><span class="hljs-string">+1</span><span class="hljs-string">+24</span><span class="hljs-string">+121</span><span class="hljs-string">+67</span><span class="hljs-string">+94</span><span class="hljs-string">+11</span><span class="hljs-string">+116</span> <br>                / 12 = 42.08<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="14-用两个栈来实现一个队列，完成队列的Push和Pop操作。-队列中的元素为int类型。"><a href="#14-用两个栈来实现一个队列，完成队列的Push和Pop操作。-队列中的元素为int类型。" class="headerlink" title="14.用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。"></a>14.用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</h5><p>同LeetCode <a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> {<br>    Stack&lt;Integer&gt; sta1,sta2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> {<br>        sta1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        sta2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> {<br>        sta1.push(x);<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (sta2.isEmpty()) {<br>            <span class="hljs-keyword">while</span> (!sta1.isEmpty()) {<br>                sta2.push(sta1.pop());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> sta2.pop();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (sta2.isEmpty()) {<br>            <span class="hljs-keyword">while</span> (!sta1.isEmpty()) {<br>                sta2.push(sta1.pop());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> sta2.peek();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> sta1.isEmpty() &amp;&amp; sta2.isEmpty();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="15-把只包含因子2、3和5的数称作丑数（Ugly-Number）。例如6、8都是丑数，但14不是，因为它包含因子7。-习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。"><a href="#15-把只包含因子2、3和5的数称作丑数（Ugly-Number）。例如6、8都是丑数，但14不是，因为它包含因子7。-习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。" class="headerlink" title="15.把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。"></a>15.把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</h5><p>同LeetCode <a href="https://leetcode.cn/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> dp[a] * <span class="hljs-number">2</span>,n2 = dp[b] * <span class="hljs-number">3</span>,n3 = dp[c] * <span class="hljs-number">5</span>;<br>            dp[i] = Math.min(Math.min(n1,n2),n3);<br>            <span class="hljs-keyword">if</span> (dp[i] == n1) a ++;<br>            <span class="hljs-keyword">if</span> (dp[i] == n2) b ++;<br>            <span class="hljs-keyword">if</span> (dp[i] == n3) c ++;<br>        }<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="16-现在一副54张的扑克牌（2个大王-2个小王），任意抽五张牌，判断是不是顺子。其中A看作1-J为11-Q为12-K为13。另外这里还有个“癞子”规则，就是大王和小王可以代替任何牌。比如：“红心A-黑桃3-小王-大王-方片5”-上面的5张牌就可以变成“1-2-3-4-5”-大小王分别看作2和4-。现在我们要用程序来判断5张牌是不是顺子。为了方便起见-你可以认为大小王是0。"><a href="#16-现在一副54张的扑克牌（2个大王-2个小王），任意抽五张牌，判断是不是顺子。其中A看作1-J为11-Q为12-K为13。另外这里还有个“癞子”规则，就是大王和小王可以代替任何牌。比如：“红心A-黑桃3-小王-大王-方片5”-上面的5张牌就可以变成“1-2-3-4-5”-大小王分别看作2和4-。现在我们要用程序来判断5张牌是不是顺子。为了方便起见-你可以认为大小王是0。" class="headerlink" title="16.现在一副54张的扑克牌（2个大王,2个小王），任意抽五张牌，判断是不是顺子。其中A看作1,J为11,Q为12,K为13。另外这里还有个“癞子”规则，就是大王和小王可以代替任何牌。比如：“红心A,黑桃3,小王,大王,方片5”, 上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4)。现在我们要用程序来判断5张牌是不是顺子。为了方便起见,你可以认为大小王是0。"></a>16.现在一副54张的扑克牌（2个大王,2个小王），任意抽五张牌，判断是不是顺子。其中A看作1,J为11,Q为12,K为13。另外这里还有个“癞子”规则，就是大王和小王可以代替任何牌。比如：“红心A,黑桃3,小王,大王,方片5”, 上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4)。现在我们要用程序来判断5张牌是不是顺子。为了方便起见,你可以认为大小王是0。</h5><p>同LeetCode <a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">面试题61. 扑克牌中的顺子</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isStraight</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">joker</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) joker++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == nums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[joker] &lt; <span class="hljs-number">5</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="17-代码能否保证所有Hello-DWD一定在Done-All-DWD之前输出？如果不能，请尽可能多的提供方法来保证"><a href="#17-代码能否保证所有Hello-DWD一定在Done-All-DWD之前输出？如果不能，请尽可能多的提供方法来保证" class="headerlink" title="17.代码能否保证所有Hello, DWD一定在Done All DWD之前输出？如果不能，请尽可能多的提供方法来保证"></a>17.代码能否保证所有Hello, DWD一定在Done All DWD之前输出？如果不能，请尽可能多的提供方法来保证</h5><p><img src="/image/305066_1534750392503_B5EDEED71BFBF89B70B287FD212A36B7.png"></p><p>正确答案：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">不能。CountDownLatch<span class="hljs-regexp">/线程池await/</span>共享变量等<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="18-代码的输出结果是："><a href="#18-代码的输出结果是：" class="headerlink" title="18.代码的输出结果是："></a>18.代码的输出结果是：</h5><p><img src="/image/305066_1534750278152_FEE897EE5CCF6E31EDE586CBBB9A27C9.png"></p><p>正确答案：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></tbody></table></figure><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">此题考察的是<span class="hljs-keyword">finally</span>抢占<span class="hljs-keyword">return</span>的知识点。<br>当<span class="hljs-keyword">finally</span>里面有<span class="hljs-keyword">return</span>语句时，会执行<span class="hljs-keyword">finally</span>里的<span class="hljs-keyword">return</span>语句而忽略<span class="hljs-keyword">try</span>，<span class="hljs-keyword">catch</span>代码块里的<span class="hljs-keyword">return</span>语句。<br>所以这里不管抛不抛出异常都会执行<span class="hljs-keyword">finally</span>里的<span class="hljs-keyword">return</span>语句。<br></code></pre></td></tr></tbody></table></figure><hr><h5 id="19-代码的输出结果是："><a href="#19-代码的输出结果是：" class="headerlink" title="19.代码的输出结果是："></a>19.代码的输出结果是：</h5><p><img src="/image/305066_1534750195915_7E8C99BB2BBEE41E7A3647118425284E.png"></p><p>正确答案：</p><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">AS</span> <br><span class="hljs-keyword">BS</span> <br><span class="hljs-keyword">AC</span> <br>BC <br><span class="hljs-keyword">AC</span> <br>BC<br></code></pre></td></tr></tbody></table></figure><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">静态语句块、构造语句块和构造函数的执行顺序 <br>静态语句块：在类加载的时候执行（从父类到子类） <br>静态语句块执行完，执行main方法 <br><span class="hljs-keyword">new</span><span class="hljs-type"></span>对象，从上到下先执行构造代码块在执行构造器<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;点我达2019届校招Java开发笔试&quot;&gt;&lt;a href=&quot;#点我达2019届校招Java开发笔试&quot; class=&quot;headerlink&quot; title=&quot;点我达2019届校招Java开发笔试&quot;&gt;&lt;/a&gt;点我达2019届校招Java开发笔试&lt;/h1&gt;&lt;h5 id=&quot;1</summary>
      
    
    
    
    <category term="笔试" scheme="http://example.com/categories/%E7%AC%94%E8%AF%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="智力题" scheme="http://example.com/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
    <category term="红黑树" scheme="http://example.com/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
    <category term="b+数" scheme="http://example.com/tags/b-%E6%95%B0/"/>
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="银行家算法" scheme="http://example.com/tags/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的迭代遍历</title>
    <link href="http://example.com/2023/03/20/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2023/03/20/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86/</id>
    <published>2023-03-20T07:26:28.537Z</published>
    <updated>2023-03-20T07:27:34.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h1><h3 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="前序遍历（迭代法）"></a>前序遍历（迭代法）</h3><p>想出栈为左右，入栈得为右左</p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> {<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>){<br>            <span class="hljs-keyword">return</span> result;<br>        }<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()){<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            result.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>){<br>                stack.push(node.right);<br>            }<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>){<br>                stack.push(node.left);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="后序遍历（迭代法）"><a href="#后序遍历（迭代法）" class="headerlink" title="后序遍历（迭代法）"></a>后序遍历（迭代法）</h3><p>后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> {<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>){<br>            <span class="hljs-keyword">return</span> result;<br>        }<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()){<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>            result.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>){<br>                stack.push(node.left);<br>            }<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>){<br>                stack.push(node.right);<br>            }<br>        }<br>        Collections.reverse(result);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="中序遍历（迭代法）"><a href="#中序遍历（迭代法）" class="headerlink" title="中序遍历（迭代法）"></a>中序遍历（迭代法）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> {<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>){<br>            <span class="hljs-keyword">return</span> result;<br>        }<br>        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> || !stack.isEmpty()){<br>           <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>){<br>               stack.push(cur);<br>               cur = cur.left;<br>           }<span class="hljs-keyword">else</span>{<br>               cur = stack.pop();<br>               result.add(cur.val);<br>               cur = cur.right;<br>           }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的迭代遍历&quot;&gt;&lt;a href=&quot;#二叉树的迭代遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的迭代遍历&quot;&gt;&lt;/a&gt;二叉树的迭代遍历&lt;/h1&gt;&lt;h3 id=&quot;前序遍历（迭代法）&quot;&gt;&lt;a href=&quot;#前序遍历（迭代法）&quot; class=&quot;he</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="广度优先搜索" scheme="http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>并发类问题3</title>
    <link href="http://example.com/2023/03/12/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%983/"/>
    <id>http://example.com/2023/03/12/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%983/</id>
    <published>2023-03-12T08:25:11.698Z</published>
    <updated>2023-03-12T08:27:48.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发类问题3"><a href="#并发类问题3" class="headerlink" title="并发类问题3"></a>并发类问题3</h1><h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><ul><li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；（单位）</li><li>线程共享本进程的地址空间，而进程之间是独立的地址空间；（地址空间）</li><li>每个进程具备各自的数据空间，进程之间的切换会有较大的开销。进程的上下文切换时间开销远远大于线程上下文切换时间,耗费资源较大,效率要差一些；（资源开销）</li><li>进程的并发性较低,线程的并发性较高；（并发性）</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；（拥有的资源）</li><li>一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮；（崩溃）</li><li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言,除了 CPU 外,系统不会为线程分配内存，线程组之间只能共享资源；（内存空间）</li></ul><h3 id="并行和并发的区别？"><a href="#并行和并发的区别？" class="headerlink" title="并行和并发的区别？"></a>并行和并发的区别？</h3><ul><li>并行：单位时间多个处理器同时处理多个任务。 </li><li>并发：一个处理器处理多个任务，按时间片轮流处理多个任务。</li></ul><h3 id="线程的上下文切换"><a href="#线程的上下文切换" class="headerlink" title="线程的上下文切换"></a>线程的上下文切换</h3><p>即便是单核的处理器也会支持多线程，处理器会给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给每个线程的执行时间，一般来说时间片非常的短，所以处理器会不停地切换线程。 </p><p>CPU会通过时间片分配算法来循环执行任务，当前任务执行完一个时间片后会切换到下一个任务，但切换前会保存上一个任务的状态，因为下次切换回这个任务时还要加载这个任务的状态继续执行，从任务保存到在加载的过程就是一次上下文切换。</p><h3 id="Java中守护线程和用户线程的区别？"><a href="#Java中守护线程和用户线程的区别？" class="headerlink" title="Java中守护线程和用户线程的区别？"></a>Java中守护线程和用户线程的区别？</h3><p>任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on) 设置，true则是将该线程设置为守护线程，false则是将该线程设置为用户线程。同时，Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。 </p><p>用户线程：平时使用到的线程均为用户线程。 </p><p>守护线程：用来服务用户线程的线程，例如垃圾回收线程。 </p><p>守护线程和用户线程的区别主要在于Java虚拟机何时离开。 </p><p>用户线程：当任何一个用户线程未结束，Java虚拟机是不会结束的。 </p><p>守护线程：如何只剩守护线程未结束，Java虚拟机结束。</p><h3 id="Java中的死锁、活锁、饥饿有什么区别？"><a href="#Java中的死锁、活锁、饥饿有什么区别？" class="headerlink" title="Java中的死锁、活锁、饥饿有什么区别？"></a>Java中的死锁、活锁、饥饿有什么区别？</h3><p>活锁：任务或者执行者没有被阻塞，由于某些条件没有被满足，导致线程一直重复尝试、失败、尝试、失败。例如，线程1和线程2都需要获取一个资源，但他们同时让其他线程先获取该资源，两个线程一直谦让，最后都无法获取 </p><p>活锁和死锁的区别： </p><ul><li>活锁是在不断地尝试、死锁是在一直等待。 </li><li>活锁有可能自行解开、死锁无法自行解开。</li></ul><p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源， 导致一直无法执行的状态。以打印机打印文件为例，当有多个线程需要打印文件，系统按照短文件优先的策略进行打印，但当短文件的打印任务一直不间断地出现，那长文件的打印任务会被一直推迟，导致饥饿。活锁就是在忙式等待条件下发生的饥饿，忙式等待就是不进入等待状态的等待。 </p><p>产生饥饿的原因： </p><ul><li>高优先级的线程占用了低优先级线程的CPU时间 </li><li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。 </li><li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait()方法)，因为其他线程总是被持续地获得唤醒。 死锁、饥饿的区别：饥饿可自行解开，死锁不行。</li></ul><h3 id="创建线程一共有哪几种方法？"><a href="#创建线程一共有哪几种方法？" class="headerlink" title="创建线程一共有哪几种方法？"></a>创建线程一共有哪几种方法？</h3><ul><li>继承Thread类创建线程 </li><li>实现Runnable接口创建线程 </li><li>使用Callable和Future创建线程 </li><li>使用线程池例如用Executor框架</li></ul><h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3><ul><li>中断：Interrupt方法中断线程 </li><li>使用volatile boolean标志位停止线程：在线程中设置一个boolean标志位，同时用volatile修饰保证可见性，在线程里不断地读取这个值，其他地方可以修改这个boolean值。 </li><li>使用stop()方法停止线程，但该方法已经被废弃。因为这样线程不能在停止前保存数据，会出现数据完整性问题。</li></ul><h3 id="同步方法和同步方法块哪个效果更好？"><a href="#同步方法和同步方法块哪个效果更好？" class="headerlink" title="同步方法和同步方法块哪个效果更好？"></a>同步方法和同步方法块哪个效果更好？</h3><p>同步块更好些，因为它锁定的范围更灵活些，只在需要锁住的代码块锁住相应的对象，而同步方法会锁住整个对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发类问题3&quot;&gt;&lt;a href=&quot;#并发类问题3&quot; class=&quot;headerlink&quot; title=&quot;并发类问题3&quot;&gt;&lt;/a&gt;并发类问题3&lt;/h1&gt;&lt;h3 id=&quot;线程与进程的比较&quot;&gt;&lt;a href=&quot;#线程与进程的比较&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="进程" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发类问题2</title>
    <link href="http://example.com/2023/03/10/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%982/"/>
    <id>http://example.com/2023/03/10/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%982/</id>
    <published>2023-03-10T09:39:32.248Z</published>
    <updated>2023-03-11T09:18:35.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发类问题"><a href="#并发类问题" class="headerlink" title="并发类问题"></a>并发类问题</h1><h3 id="runnable-和-callable-有什么区别？"><a href="#runnable-和-callable-有什么区别？" class="headerlink" title="runnable 和 callable 有什么区别？"></a>runnable 和 callable 有什么区别？</h3><p>相同点： </p><ul><li>两者都是接口 </li><li>两者都需要调用Thread.start启动线程</li></ul><p>不同点： </p><ul><li>callable的核心是call()方法，允许返回值，runnable的核心是run()方法，没有返回值 </li><li>call()方法可以抛出异常，但是run()方法不行 </li><li>callable和runnable都可以应用于executors，thread类只支持runnable</li></ul><h3 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h3><ul><li>调用 start() 方法是用来启动线程的，轮到该线程执行时，会自动调用 run()；直接调用 run() 方法，无法达到启动多线程的目的，相当于主线程线性执行 Thread 对象的 run() 方法。</li><li>一个线程对线的 start() 方法只能调用一次，多次调用会抛出 java.lang.IllegalThreadStateException 异常；run() 方法没有限制。</li></ul><h3 id="线程同步以及线程调度相关的方法有哪些？"><a href="#线程同步以及线程调度相关的方法有哪些？" class="headerlink" title="线程同步以及线程调度相关的方法有哪些？"></a>线程同步以及线程调度相关的方法有哪些？</h3><ul><li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒 某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是 让它们竞争，只有获得锁的线程才能进入就绪状态；</li><li>join()：与sleep()方法一样，是一个可中断的方法，在一个线程中调用另一个线程的join()方法，会使得当前的线程挂起，知直到执行join()方法的线程结束。例如在B线程中调用A线程的join()方法，B线程进入阻塞状态，直到A线程结束或者到达指定的时间。 </li><li>yield()：暂停当前线程，以便其他线程有机会执行，不过不能指定暂停的时间，并且也不能保证当前线程马上停止。yield方法只是将Running状态转变为Runnable状态。</li></ul><h3 id="线程的sleep-方法和yield-方法有什么不同？"><a href="#线程的sleep-方法和yield-方法有什么不同？" class="headerlink" title="线程的sleep()方法和yield()方法有什么不同？"></a>线程的sleep()方法和yield()方法有什么不同？</h3><ul><li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给优先级低的线程以运行的机会，而yield()方法只会给相同优先级或者更高优先级的线程以运行机会。</li><li>线程执行sleep()方法后会转入阻塞状态，所以，执行sleep()方法的线程在指定的时间内肯定不会被执行，而yield()方法只是使当前线程重新回到可执行状态，所以执行yield()方法的线程有可能在进入到可执行状态后马上又被执行。</li><li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常。</li></ul><h3 id="sleep-方法和wait-方法的区别？"><a href="#sleep-方法和wait-方法的区别？" class="headerlink" title="sleep()方法和wait()方法的区别？"></a>sleep()方法和wait()方法的区别？</h3><p>相同点： </p><ul><li>wait()方法和sleep()方法都可以使得线程进入到阻塞状态。 </li><li>wait()和sleep()方法都是可中断方法，被中断后都会收到中断异常。</li></ul><p>不同点： </p><ul><li>wait()是Object的方法，sleep()是Thread的方法。 </li><li>wait()必须在同步方法中进行，sleep()方法不需要。 </li><li>线程在同步方法中执行sleep()方法，不会释放monitor的锁，而wait()方法会释放monitor的锁。 </li><li>sleep()方法在短暂的休眠之后会主动退出阻塞，而wait()方法在没有指定wait时间的情况下需要被其他线程中断才可以退出阻塞。</li></ul><h3 id="wait-方法一般在循环块中使用还是if块中使用？"><a href="#wait-方法一般在循环块中使用还是if块中使用？" class="headerlink" title="wait()方法一般在循环块中使用还是if块中使用？"></a>wait()方法一般在循环块中使用还是if块中使用？</h3><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。</p><h3 id="为什么wait-，notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么wait-，notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么wait()，notify()和notifyAll()必须在同步方法或者同步块中被调用？</h3><p>因为wait()暂停的是持有锁的对象，notify()或notifyAll()唤醒的是等待锁的对象。所以wait()、notify()、notifyAll()都需要线程持有锁的对象，进而需要在同步方法或者同步块中被调用。</p><h3 id="为什么Thread类的sleep和yield方法是静态的？"><a href="#为什么Thread类的sleep和yield方法是静态的？" class="headerlink" title="为什么Thread类的sleep和yield方法是静态的？"></a>为什么Thread类的sleep和yield方法是静态的？</h3><p>如果sleep和yield是静态方法，那么不管哪个线程，只要一调用就把自己给sleep、yield了。</p><p>如果sleep和yield是实例方法，一个线程可以获取其他线程对象的引用，然后通过引用调要其他线程的sleep和yield方法，让其他线程让出CPU使用权。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发类问题&quot;&gt;&lt;a href=&quot;#并发类问题&quot; class=&quot;headerlink&quot; title=&quot;并发类问题&quot;&gt;&lt;/a&gt;并发类问题&lt;/h1&gt;&lt;h3 id=&quot;runnable-和-callable-有什么区别？&quot;&gt;&lt;a href=&quot;#runnable-和-call</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>死锁定义及发生的条件</title>
    <link href="http://example.com/2023/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%8F%91%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6/"/>
    <id>http://example.com/2023/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%8F%91%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6/</id>
    <published>2023-03-08T07:20:27.984Z</published>
    <updated>2023-03-08T09:38:16.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁定义及发生的条件"><a href="#死锁定义及发生的条件" class="headerlink" title="死锁定义及发生的条件"></a>死锁定义及发生的条件</h1><p><strong>死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</strong></p><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ul><li>互斥条件；</li><li>持有并等待条件；</li><li>不可剥夺条件；</li><li>环路等待条件；</li></ul><h4 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h4><p>互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</p><p><img src="/image/%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6.webp" alt="互斥条件"></p><h4 id="持有并等待条件"><a href="#持有并等待条件" class="headerlink" title="持有并等待条件"></a>持有并等待条件</h4><p>持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</p><p><img src="/image/%E6%8C%81%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6.webp"></p><h4 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h4><p>不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</p><p><img src="/image/%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6.webp"></p><h4 id="环路等待条件"><a href="#环路等待条件" class="headerlink" title="环路等待条件"></a>环路等待条件</h4><p>环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</p><p>比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。</p><p><img src="/image/%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6.webp" alt="环路等待条件"></p><h3 id="避免死锁问题的发生"><a href="#避免死锁问题的发生" class="headerlink" title="避免死锁问题的发生"></a>避免死锁问题的发生</h3><p>那么避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。</p><p>那什么是资源有序分配法呢？</p><p>线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</p><p>我们使用资源有序分配法的方式来修改前面发生死锁的代码，我们可以不改动线程 A 的代码。</p><p>我们先要清楚线程 A 获取资源的顺序，它是先获取互斥锁 A，然后获取互斥锁 B。</p><p>所以我们只需将线程 B 改成以相同顺序的获取资源，就可以打破死锁了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;死锁定义及发生的条件&quot;&gt;&lt;a href=&quot;#死锁定义及发生的条件&quot; class=&quot;headerlink&quot; title=&quot;死锁定义及发生的条件&quot;&gt;&lt;/a&gt;死锁定义及发生的条件&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="http://example.com/2023/03/07/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/03/07/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2023-03-07T12:51:50.993Z</published>
    <updated>2023-03-08T06:46:38.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><p><img src="/image/v2-7a7c516c0aeb622705c86fd9b5e8c44a_720w.webp"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><p>Program Counter Register 程序计数器（寄存器）<br>作用：是记录下一条 jvm 指令的执行地址行号。<br>特点：</p><ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul><h4 id="2）作用"><a href="#2）作用" class="headerlink" title="2）作用"></a>2）作用</h4><ul><li>解释器会解释指令为机器码交给 cpu 执行，程序计数器会记录下一条指令的地址行号，这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</li><li>多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行。</li></ul><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h4 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li>每个线程运行需要的内存空间，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li></ul><h5 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h5><p>不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</p><h5 id="栈内存分配越大越好吗？"><a href="#栈内存分配越大越好吗？" class="headerlink" title="栈内存分配越大越好吗？"></a>栈内存分配越大越好吗？</h5><p>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</p><h5 id="方法呢的局部变量是否线程安全"><a href="#方法呢的局部变量是否线程安全" class="headerlink" title="方法呢的局部变量是否线程安全"></a>方法呢的局部变量是否线程安全</h5><p>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的<br>如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。</p><h4 id="2）栈内存溢出"><a href="#2）栈内存溢出" class="headerlink" title="2）栈内存溢出"></a>2）栈内存溢出</h4><p>栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 java.lang.stackOverflowError ，使用 -Xss256k 指定栈内存大小！</p><h4 id="3）线程运行诊断"><a href="#3）线程运行诊断" class="headerlink" title="3）线程运行诊断"></a>3）线程运行诊断</h4><p>案例一：cpu 占用过多<br>解决方法：Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高，这时需要定位占用 CPU 过高的线程</p><p>top 命令，查看是哪个进程占用 CPU 过高<br>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过 top 查到的进程号 通过 ps 命令进一步查看是哪个线程占用 CPU 过高<br>jstack 进程 id 通过查看进程中的线程的 nid ，刚才通过 ps 命令看到的 tid 来对比定位，注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>一些带有 native 关键字的方法就是需要 JAVA 去调用本地的C或者C++方法，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h4 id="1）定义-2"><a href="#1）定义-2" class="headerlink" title="1）定义"></a>1）定义</h4><p>Heap 堆</p><ul><li>通过new关键字创建的对象都会被放在堆内存</li></ul><p>特点</p><ul><li>它是线程共享，堆内存中的对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h4 id="2）堆内存溢出"><a href="#2）堆内存溢出" class="headerlink" title="2）堆内存溢出"></a>2）堆内存溢出</h4><p>java.lang.OutofMemoryError ：java heap space. 堆内存溢出<br>可以使用 -Xmx8m 来指定堆内存大小。</p><h4 id="2）堆内存诊断"><a href="#2）堆内存诊断" class="headerlink" title="2）堆内存诊断"></a>2）堆内存诊断</h4><ol><li>jps 工具<br>查看当前系统中有哪些 java 进程</li><li>jmap 工具<br>查看堆内存占用情况 jmap - heap 进程id</li><li>jconsole 工具<br>图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm 工具</li></ol><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h4 id="1）定义-3"><a href="#1）定义-3" class="headerlink" title="1）定义"></a>1）定义</h4><p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区域。方法区域类似于用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它。此规范不强制指定方法区的位置或用于管理已编译代码的策略。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的！</p><h4 id="2）组成"><a href="#2）组成" class="headerlink" title="2）组成"></a>2）组成</h4><p>Hotspot 虚拟机 jdk1.6 1.7 1.8 内存结构图</p><p><img src="/image/20210208112903305.png"></p><h4 id="3）方法区内存溢出"><a href="#3）方法区内存溢出" class="headerlink" title="3）方法区内存溢出"></a>3）方法区内存溢出</h4><ul><li>1.8 之前会导致永久代内存溢出<ul><li>使用 -XX:MaxPermSize=8m 指定永久代内存大小</li></ul></li><li>1.8 之后会导致元空间内存溢出<ul><li>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</li></ul></li></ul><h4 id="4）运行时常量池"><a href="#4）运行时常量池" class="headerlink" title="4）运行时常量池"></a>4）运行时常量池</h4><p>二进制字节码包含（类的基本信息，常量池，类方法定义，包含了虚拟机的指令）<br>首先看看常量池是什么，编译如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>然后使用 javap -v Test.class 命令反编译查看结果。</p><p><img src="/image/20210208124448238.png"></p><p>每条指令都会对应常量池表中一个地址，常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p><p><img src="/image/20210208124525875.png"></p><p><strong>常量池</strong>：<br>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息<br><strong>运行时常量池</strong>：<br>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><h4 id="5）StringTable"><a href="#5）StringTable" class="headerlink" title="5）StringTable"></a>5）StringTable</h4><ul><li>常量池中的字符串仅是符号，只有在被用到时才会转化为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</li></ul><p><strong>intern方法 1.8</strong><br>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败<br>无论放入是否成功，都会返回串池中的字符串对象</li></ul><p>注意：此时如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTable</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"a"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"b"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"b"</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s3.intern();<br>        System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br>        System.out.println(s5 == s3); <span class="hljs-comment">// false</span><br>        System.out.println(s6 == s5); <span class="hljs-comment">// true</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br><span class="hljs-comment">// "a" "b" 被放入串池中，str 则存在于堆内存之中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"b"</span>);<br><span class="hljs-comment">// 调用 str 的 intern 方法，这时串池中没有 "ab" ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 "ab" 是同一个对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">st2</span> <span class="hljs-operator">=</span> str.intern();<br><span class="hljs-comment">// 给 str3 赋值，因为此时串池中已有 "ab" ，则直接将串池中的内容返回</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br><span class="hljs-comment">// 因为堆内存与串池中的 "ab" 是同一个对象，所以以下两条语句打印的都为 true</span><br>System.out.println(str == st2); <span class="hljs-comment">// true</span><br>System.out.println(str == str3); <span class="hljs-comment">// true</span><br>}<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// 此处创建字符串对象 "ab" ，因为串池中还没有 "ab" ，所以将其放入串池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br>        <span class="hljs-comment">// "a" "b" 被放入串池中，str 则存在于堆内存之中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"b"</span>);<br>        <span class="hljs-comment">// 此时因为在创建 str3 时，"ab" 已存在与串池中，所以放入失败，但是会返回串池中的 "ab" </span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str.intern();<br>System.out.println(str == str2); <span class="hljs-comment">// false</span><br>System.out.println(str == str3); <span class="hljs-comment">// false</span><br>System.out.println(str2 == str3); <span class="hljs-comment">// true</span><br>}<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="6）StringTable-的位置"><a href="#6）StringTable-的位置" class="headerlink" title="6）StringTable 的位置"></a>6）StringTable 的位置</h4><p>jdk1.6 StringTable 位置是在永久代中，1.8 StringTable 位置是在堆中。</p><h4 id="7）StringTable-垃圾回收"><a href="#7）StringTable-垃圾回收" class="headerlink" title="7）StringTable 垃圾回收"></a>7）StringTable 垃圾回收</h4><p>-Xmx10m 指定堆内存大小<br>-XX:+PrintStringTableStatistics 打印字符串常量池信息<br>-XX:+PrintGCDetails<br>-verbose:gc 打印 gc 的次数，耗费时间等信息</p><h4 id="8）StringTable-性能调优"><a href="#8）StringTable-性能调优" class="headerlink" title="8）StringTable 性能调优"></a>8）StringTable 性能调优</h4><ul><li>因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间</li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">StringTableSize</span>=桶个数（最少设置为 1009 以上）<br></code></pre></td></tr></tbody></table></figure><ul><li>考虑是否需要将字符串对象入池<br>可以通过 intern 方法减少重复入池</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h4 id="1）定义-4"><a href="#1）定义-4" class="headerlink" title="1）定义"></a>1）定义</h4><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul><h4 id="2）使用直接内存的好处"><a href="#2）使用直接内存的好处" class="headerlink" title="2）使用直接内存的好处"></a>2）使用直接内存的好处</h4><p>文件读写流程：</p><p><img src="/image/20210208180041113.png"></p><p>因为 java 不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 然后在将系统缓冲区数据，复制到 java 堆内存中。缺点是数据存储了两份，在系统内存中有一份，java 堆中有一份，造成了不必要的复制。</p><p><strong>使用了 DirectBuffer 文件读取流程</strong></p><p><img src="/image/20210208181022863.png"></p><p>直接内存是操作系统和 Java 代码都可以访问的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。</p><h4 id="3）直接内存的回收机制总结"><a href="#3）直接内存的回收机制总结" class="headerlink" title="3）直接内存的回收机制总结"></a>3）直接内存的回收机制总结</h4><ul><li><p>使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用freeMemory 方法</p></li><li><p>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存</p></li></ul><p><strong>注意：</strong></p><p>一般用 jvm 调优时，会加上下面的参数：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-XX:+DisableExplicitGC  <span class="hljs-regexp">//</span> 静止显示的 GC<br></code></pre></td></tr></tbody></table></figure><p>意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构&quot;&gt;&lt;/a&gt;JVM内存结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/image/v2-7a7c516c0aeb622705c86fd9b5e8c4</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>进程间的通信方式</title>
    <link href="http://example.com/2023/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2023/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2023-03-06T12:28:36.396Z</published>
    <updated>2023-03-08T09:37:55.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>分为<strong>匿名管道</strong>和<strong>命名管道</strong></p><p><strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p><p><strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。它的好处，就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p><p><strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，<strong>管道传输的数据是无格式的流且大小受限</strong>。</p><p><strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p><strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。</p><p><strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以<strong>每个消息体都是固定大小的存储块</strong>，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><p>需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>进程有三种方式响应信号</strong></p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 <strong>TCP 协议</strong>的通信方式，一个是基于 <strong>UDP 协议</strong>的通信方式，一个是<strong>本地进程间</strong>通信方式。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程间的通信方式&quot;&gt;&lt;a href=&quot;#进程间的通信方式&quot; class=&quot;headerlink&quot; title=&quot;进程间的通信方式&quot;&gt;&lt;/a&gt;进程间的通信方式&lt;/h1&gt;&lt;h2 id=&quot;管道&quot;&gt;&lt;a href=&quot;#管道&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="进程" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发类问题</title>
    <link href="http://example.com/2023/02/26/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/02/26/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%98/</id>
    <published>2023-02-26T13:03:50.024Z</published>
    <updated>2023-03-11T09:17:52.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发类问题"><a href="#并发类问题" class="headerlink" title="并发类问题"></a>并发类问题</h1><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><h5 id="六种状态及转换"><a href="#六种状态及转换" class="headerlink" title="六种状态及转换"></a>六种状态及转换</h5><p><img src="/image/image-20210831090722658.png"></p><ul><li>新建<ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></li><li>可运行<ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></li><li>终结<ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li><li>此时会取消与底层线程关联</li></ul></li><li>阻塞<ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></li><li>等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></li><li>有时限等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></li></ul><p><em><strong>其它情况（了解）</strong></em></p><ul><li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li><li>park，unpark 等方法也可以让线程等待和唤醒</li></ul><h5 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h5><p>五种状态的说法来自于操作系统层面的划分</p><p><img src="/image/Snipaste_2023-02-26_17-30-45.png"></p><p><img src="/image/image-20210831092652602.png"></p><ul><li>运行态：分到 cpu 时间，能真正执行线程内代码的</li><li>就绪态：有资格分到 cpu 时间，但还未轮到它的</li><li>阻塞态：没资格分到 cpu 时间的<ul><li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li><li>多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等</li></ul></li><li>新建与终结态：与 java 中同名状态类似</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>七大参数</strong></p><ol><li>corePoolSize <strong>核心线程数目</strong> - 池中会保留的最多线程数</li><li>maximumPoolSize <strong>最大线程数目</strong> - 核心线程+救急线程的最大数目</li><li>keepAliveTime <strong>生存时间</strong> - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit <strong>时间单位</strong> - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue <strong>阻塞队列</strong> - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory <strong>线程工厂</strong> - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler <strong>拒绝策略</strong> - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol><li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li><li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li><li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li><li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li></ol></li></ol><p><img src="/image/image-20210831093204388.png"></p><h3 id="wait-vs-sleep"><a href="#wait-vs-sleep" class="headerlink" title="wait vs sleep"></a>wait vs sleep</h3><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li><p>语法使用不同</p><ul><li>wait 方法必须配合 synchronized 一起使用，不然在运行时就会抛出 IllegalMonitorStateException 的异常</li></ul></li><li><p>方法归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒。</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同（重点）</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制(同第一条)</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul><h3 id="lock-vs-synchronized"><a href="#lock-vs-synchronized" class="headerlink" title="lock vs synchronized"></a>lock vs synchronized</h3><p><strong>三个层面</strong></p><p>不同点</p><ul><li>语法层面<ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li></ul></li><li>功能层面<ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul></li><li>性能层面<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul></li></ul><p><strong>公平锁</strong></p><ul><li>公平锁的公平体现<ul><li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li><li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li><li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li></ul></li><li>公平锁会降低吞吐量，一般不用</li></ul><p><strong>条件变量</strong></p><ul><li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</li><li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ul><li>掌握线程安全要考虑的三个问题</li><li>掌握 volatile 能解决哪些问题</li></ul><p><strong>原子性</strong></p><ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li></ul><p><strong>可见性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li></ul><p><strong>有序性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li><li>注意：<ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul></li></ul><h3 id="Hashtable-vs-ConcurrentHashMap"><a href="#Hashtable-vs-ConcurrentHashMap" class="headerlink" title="Hashtable vs ConcurrentHashMap"></a>Hashtable vs ConcurrentHashMap</h3><ul><li><p>Hashtable 与 ConcurrentHashMap 的区别</p></li><li><p>ConcurrentHashMap 在不同版本的实现区别</p></li></ul><p><strong>Hashtable 对比 ConcurrentHashMap</strong></p><ul><li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li><li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li><li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li></ul><p><strong>ConcurrentHashMap 1.7</strong></p><ul><li>数据结构：<code>Segment(大数组) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li><li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。<strong>Segment 数组不能扩容</strong>，意味着并发度在 ConcurrentHashMap 创建时就固定了</li><li>索引计算<ul><li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li><li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li></ul></li><li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，<strong>每次扩容翻倍</strong></li><li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li></ul><p><strong>ConcurrentHashMap 1.8</strong></p><ul><li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li><li>并发度：Node 数组有多大，并发度就有多大，<strong>与 1.7 不同，Node 数组可以扩容</strong></li><li>扩容条件：<strong>Node 数组满 3/4 时就会扩容</strong></li><li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode</li><li>扩容时并发 get<ul><li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li><li>如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变</li><li>如果链表最后几个元素扩容后索引不变，则节点无需复制</li></ul></li><li>扩容时并发 put<ul><li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li><li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li><li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li></ul></li><li>与 1.7 相比是懒惰初始化</li><li>capacity 代表预估的元素个数，capacity / factory 来计算出初始数组大小，需要贴近 $2^n$ </li><li>loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3/4</li><li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul><li>ThreadLocal 的作用与原理</li><li>ThreadLocal 的内存释放时机</li></ul><p><strong>作用</strong></p><ul><li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ul><p><strong>原理</strong></p><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p>ThreadLocalMap 的一些特点</p><ul><li>key 的 hash 值统一分配</li><li><strong>初始容量 16，扩容因子 2/3，扩容容量翻倍</strong></li><li>key 索引冲突后用开放寻址法解决冲突</li></ul><p><strong>弱引用 key</strong></p><p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p><ul><li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li></ul><p><strong>内存释放时机</strong></p><ul><li>被动 GC 释放 key<ul><li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li></ul></li><li>懒惰被动释放 value<ul><li>get key 时，发现是 null key，则释放其 value 内存</li><li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li></ul></li><li>主动 remove 释放 key，value<ul><li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li><li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发类问题&quot;&gt;&lt;a href=&quot;#并发类问题&quot; class=&quot;headerlink&quot; title=&quot;并发类问题&quot;&gt;&lt;/a&gt;并发类问题&lt;/h1&gt;&lt;h3 id=&quot;线程状态&quot;&gt;&lt;a href=&quot;#线程状态&quot; class=&quot;headerlink&quot; title=&quot;线程状态&quot;</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://example.com/2023/02/23/%E5%9F%BA%E7%A1%80/HashMap/"/>
    <id>http://example.com/2023/02/23/%E5%9F%BA%E7%A1%80/HashMap/</id>
    <published>2023-02-23T05:36:17.271Z</published>
    <updated>2023-03-11T09:13:49.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h4 id="底层数据结构，1-7与1-8有何不同？"><a href="#底层数据结构，1-7与1-8有何不同？" class="headerlink" title="底层数据结构，1.7与1.8有何不同？"></a>底层数据结构，1.7与1.8有何不同？</h4><p>1.7数组+链表，1.8数组+（链表|红黑树）</p><h4 id="为何要用红黑树，为何一上来不树化？"><a href="#为何要用红黑树，为何一上来不树化？" class="headerlink" title="为何要用红黑树，为何一上来不树化？"></a>为何要用红黑树，为何一上来不树化？</h4><p>红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应当是偶然情况<br>hash表的查找，更新的时间复杂度是0(1），而红黑树的查找，更新的时间复杂度是0(log2n)，TreeNode 占用空间也比普通Node的大，如非必要，尽量还是使用链表</p><h4 id="树化阈值为何是8"><a href="#树化阈值为何是8" class="headerlink" title="树化阈值为何是8"></a>树化阈值为何是8</h4><p> hash值如果足够随机，则在hash表内按泊松分布，在负载因子0.75的情况下，长度超过8的链表出现概率是<br>0.00000006，选择8就是为了让树化几率足够小</p><h4 id="何时会树化"><a href="#何时会树化" class="headerlink" title="何时会树化"></a>何时会树化</h4><p>树化两个条件：链表长度超过树化阈值；数组容量 &gt;=64</p><h4 id="何时会退化为链表？"><a href="#何时会退化为链表？" class="headerlink" title="何时会退化为链表？"></a>何时会退化为链表？</h4><p>退化情况1：在扩容时如果拆分树时，树元素个数&lt;=6则会退化链表，<br>退化情况2：remove树节点时，若root、root.left、root.right、root.left.left有一个为 null，也会退化为链表</p><h4 id="索引如何计算？"><a href="#索引如何计算？" class="headerlink" title="索引如何计算？"></a>索引如何计算？</h4><p>计算对象的hashCode()，再进行调用HashMap的hash()方法进行二次哈希，最后&amp;(capacity-1)得到索引</p><h4 id="hashCode都有了，为何还要提供hash-）方法？"><a href="#hashCode都有了，为何还要提供hash-）方法？" class="headerlink" title="hashCode都有了，为何还要提供hash(）方法？"></a>hashCode都有了，为何还要提供hash(）方法？</h4><p>二次hash(）是为了综合高位数据，让哈希分布更为均匀</p><h4 id="数组容量为何是2的n次幂？"><a href="#数组容量为何是2的n次幂？" class="headerlink" title="数组容量为何是2的n次幂？"></a>数组容量为何是2的n次幂？</h4><p>计算索引时，如果是2的n次幂可以使用位与运算代替取模，效率更高；扩容时 hash&amp;oldCap==0的元素留在原来位置，否则新位置=旧位置+oldCap</p><p>都是为了配合容量为2的n次幂时的优化手段，例如Hashtable的容量就不是2的n次幂，并不能说哪种设计更<br>优，应该是设计者综合了各种因素，最终选择了使用2的n次幂作为容量</p><h4 id="介绍一下put方法流程，1-7与1-8有何不同"><a href="#介绍一下put方法流程，1-7与1-8有何不同" class="headerlink" title="介绍一下put方法流程，1.7与1.8有何不同?"></a>介绍一下put方法流程，1.7与1.8有何不同?</h4><p>1.HashMap是懒惰创建数组的，首次使用才创建数组</p><p>2.计算索引(桶下标)</p><p>3.如果桶下标还没人占用，创建Node占位返回</p><p>4.如果桶下标已经有人占用</p><p>​已经是TreeNode走红黑树的添加或更新逻辑</p><p>​是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</p><p>5.返回前检查容量是否超过阈值，一旦超过进行扩容</p><p>6.不同</p><p>​链表插入节点时，1.7是头插法，1.8是尾插法</p><p>​1.7是大于等于阈值且没有空位时才扩容，而1.8是大于阈值就扩容</p><h4 id="1-8在扩容计算Node索引时，会优化加载因子为何默认是0-75f"><a href="#1-8在扩容计算Node索引时，会优化加载因子为何默认是0-75f" class="headerlink" title="1.8在扩容计算Node索引时，会优化加载因子为何默认是0.75f"></a>1.8在扩容计算Node索引时，会优化加载因子为何默认是0.75f</h4><p>在空间占用与查询时间之间取得较好的权衡</p><p>大于这个值，空间节省了，但链表就会比较长影响性能</p><p>小于这个值，冲突减少了，但扩容就会更频繁，空间占用多</p><h4 id="多线程下会有啥问题"><a href="#多线程下会有啥问题" class="headerlink" title="多线程下会有啥问题?"></a>多线程下会有啥问题?</h4><p>扩容死链（1.7)</p><p>数据错乱（1.7，1.8)</p><h4 id="key能否为null，作为key的对象有什么要求"><a href="#key能否为null，作为key的对象有什么要求" class="headerlink" title="key能否为null，作为key的对象有什么要求?"></a>key能否为null，作为key的对象有什么要求?</h4><p>1.HashMap 的 key可以为null，但 Map 的其他实现则不然</p><p>2.作为key的对象，必须实现 hashCode和equals，并且 key的内容不能修改（不可变)</p><h4 id="String对象的-hashCode-如何设计的，为啥每次乘的是31"><a href="#String对象的-hashCode-如何设计的，为啥每次乘的是31" class="headerlink" title="String对象的 hashCode()如何设计的，为啥每次乘的是31"></a>String对象的 hashCode()如何设计的，为啥每次乘的是31</h4><p>目标是达到较为均匀的散列效果，每个字符串的hashCode足够独特</p><p>1.字符串中的每个字符都可以表现为一个数字，称为Sj，其中i的范围是0~n - 1</p><p>2.散列公式为:So* 31n-1+ S1* 31n-2+ … Si * 31n-1-i + …Sn-1 * 310</p><p>3.31代入公式有较好的散列特性，并且31*h可以被优化为</p><p>​即32 * h - h</p><p>​即25 * h - h</p><p>​即h &lt;&lt; 5 - h</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h1&gt;&lt;h4 id=&quot;底层数据结构，1-7与1-8有何不同？&quot;&gt;&lt;a href=&quot;#底层数据结构，1-7与1-8</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="HashMap" scheme="http://example.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList的扩容规则,FailFast与FailSafe</title>
    <link href="http://example.com/2023/02/21/%E5%9F%BA%E7%A1%80/ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99,FailFast%E4%B8%8EFailSafe/"/>
    <id>http://example.com/2023/02/21/%E5%9F%BA%E7%A1%80/ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99,FailFast%E4%B8%8EFailSafe/</id>
    <published>2023-02-21T12:43:04.840Z</published>
    <updated>2023-03-11T09:15:22.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList的扩容规则-FailFast与FailSafe"><a href="#ArrayList的扩容规则-FailFast与FailSafe" class="headerlink" title="ArrayList的扩容规则,FailFast与FailSafe"></a>ArrayList的扩容规则,FailFast与FailSafe</h1><h2 id="ArrayList的扩容规则"><a href="#ArrayList的扩容规则" class="headerlink" title="ArrayList的扩容规则"></a>ArrayList的扩容规则</h2><p><img src="/image/Snipaste_2023-02-21_20-18-44.png"></p><p>ArrayList无参构造源码</p><p>创建时是一个为空的数组，第一次添加元素的时候才分配容量为10的内存</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>}<br></code></pre></td></tr></tbody></table></figure><p>ArrayList有参构造源码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> {<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) {<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"Illegal Capacity: "</span>+<br>                                           initialCapacity);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>add()扩容不是直接乘以1.5，先用位运算&gt;&gt;1，然后加上本身</p><figure class="highlight node-repl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">15</span>*<span class="hljs-number">1.5</span></span><br>&lt; 22.5<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">15</span>&gt;&gt;<span class="hljs-number">1</span></span><br>&lt; 7<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">7</span>+<span class="hljs-number">15</span></span><br>&lt; 22<br></code></pre></td></tr></tbody></table></figure><h2 id="FailFast与FailSafe"><a href="#FailFast与FailSafe" class="headerlink" title="FailFast与FailSafe"></a>FailFast与FailSafe</h2><p><img src="/image/Snipaste_2023-02-22_16-18-08.png"></p><h3 id="FailFast"><a href="#FailFast" class="headerlink" title="FailFast:"></a>FailFast:</h3><p>ArrayList源码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; {<br>    <span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> cursor != size;<br>    }<br><br>    <span class="hljs-meta">@SuppressWarnings("unchecked")</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> {<br>        checkForComodification();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        checkForComodification();<br><br>        <span class="hljs-keyword">try</span> {<br>            ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>            cursor = lastRet;<br>            lastRet = -<span class="hljs-number">1</span>;<br>            expectedModCount = modCount;<br>        } <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        }<br>    }<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>checkForComodification这个方法，它是在<strong>modCount != expectedModCount的时候抛出的异常</strong>，而在next方法中第一句就是checkForComodification，所以遍历集合才会可能抛出并发修改异常。</p><p>而且，在创建一个迭代器后，expectedModCount的初始值就是modCount了，对集合修改只会改变modCount，expectedModCount只会在迭代器的remove方法中被修改为modCountt</p><p>ArrayList的其他方法</p><p>remove：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> {<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) {<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) {<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>fastRemove中对modCount++了，所以后面modCount会和expectedModCount不相等，进而抛出并发修改异常。</p><p>add：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> {<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在ensureCapacityInternal方法里对modCount++了。</p><p>set：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> {<br>    rangeCheck(index);<br><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    elementData[index] = element;<br>    <span class="hljs-keyword">return</span> oldValue;<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看出set方法并没有对modCount++，所以对集合的某个元素进行修改并不会fail-fast</p><h3 id="FailSafe"><a href="#FailSafe" class="headerlink" title="FailSafe:"></a>FailSafe:</h3><p>ArrayList使用fail-fast机制自然是因为它增强了数据的安全性。但在某些场景，我们可能想避免fail-fast机制抛出的异常，这时我们就要将ArrayList替换为使用fail-safe机制的CopyOnWriteArrayList。</p><p><strong>写时复制</strong>，简单理解就是，当我们往一个容器添加元素的时候，先将当前容器复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> {<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> {<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    } <span class="hljs-keyword">finally</span> {<br>        lock.unlock();<br>    }<br>}<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArray</span><span class="hljs-params">(Object[] a)</span> {<br>    array = a;<br>}<br></code></pre></td></tr></tbody></table></figure><p>添加的时候是需要加锁的，否则多线程写的时候会复制出N个副本出来……</p><p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p><p>CopyOnWrite的应用场景：CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p><p>CopyOnWrite的缺点：CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下：</p><h3 id="如何避免fail-fast抛异常？"><a href="#如何避免fail-fast抛异常？" class="headerlink" title="如何避免fail-fast抛异常？"></a><strong>如何避免fail-fast抛异常？</strong></h3><p>1.如果非要在遍历的时候修改集合，那么建议用迭代器的remove等方法，而不是用集合的remove等方法。</p><p>2.如果是并发的环境，那还要对Iterator对象加锁；也可以直接使用Collections.synchronizedList。</p><p>3.CopyOnWriteArrayList（采用fail-safe）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ArrayList的扩容规则-FailFast与FailSafe&quot;&gt;&lt;a href=&quot;#ArrayList的扩容规则-FailFast与FailSafe&quot; class=&quot;headerlink&quot; title=&quot;ArrayList的扩容规则,FailFast与Fail</summary>
      
    
    
    
    <category term="基础" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="ArrayList" scheme="http://example.com/tags/ArrayList/"/>
    
    <category term="迭代器" scheme="http://example.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
    <category term="CopyOnWrite" scheme="http://example.com/tags/CopyOnWrite/"/>
    
  </entry>
  
  <entry>
    <title>位运算技巧</title>
    <link href="http://example.com/2023/02/05/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2023/02/05/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/</id>
    <published>2023-02-05T05:18:38.235Z</published>
    <updated>2023-02-05T05:20:41.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算技巧"><a href="#位运算技巧" class="headerlink" title="位运算技巧"></a>位运算技巧</h1><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><ul><li><p>&amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0，如<br>  1 0 0 1 1<br>&amp;  1 1 0 0 1<br><code>------------------------------</code><br>  1 0 0 0 1 </p></li><li><p>| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如<br>  1 0 0 1 1<br>|   1 1 0 0 1<br><code>------------------------------</code><br>  1 1 0 1 1 </p></li><li><p>^ 异或运算，两个位相同则为 0，不同则为 1，如<br>  1 0 0 1 1<br>^  1 1 0 0 1<br><code>-----------------------------</code><br>  0 1 0 1 0 </p></li><li><p>~ 取反运算，0 则变为 1，1 则变为 0，如<br>~   1 0 0 1 1<br><code>-----------------------------</code><br>   0 1 1 0 0 </p></li><li><p>&lt;&lt; 左移运算，向左进行移位操作，高位丢弃，低位补 0，如</p></li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">int a = 8;<br>a &lt;&lt; 3;<br>移位前：0000 0000 0000 0000 0000 0000 0000 1000<br>移位后：0000 0000 0000 0000 0000 0000 0100 0000<br></code></pre></td></tr></tbody></table></figure><p>&gt;&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，</p><p>无符号右移：&gt;&gt;&gt;，将二进制向右移动1位，最左边用0填补如</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">unsigned int a = 8;<br>a &gt;&gt; 3;<br>移位前：0000 0000 0000 0000 0000 0000 0000 1000<br>移位后：0000 0000 0000 0000 0000 0000 0000 0001<br><br>int a = -8;<br>a &gt;&gt; 3;<br>移位前：1111 1111 1111 1111 1111 1111 1111 1000<br>移位前：1111 1111 1111 1111 1111 1111 1111 1111<br></code></pre></td></tr></tbody></table></figure><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><h3 id="1-位操作实现乘除法"><a href="#1-位操作实现乘除法" class="headerlink" title="1. 位操作实现乘除法"></a>1. 位操作实现乘除法</h3><ul><li>数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">int a = 2;<br>a &gt;&gt; 1; ---&gt; 1<br>a &lt;&lt; 1; ---&gt; 4<br></code></pre></td></tr></tbody></table></figure><h3 id="2-位操作交货两数"><a href="#2-位操作交货两数" class="headerlink" title="2. 位操作交货两数"></a>2. 位操作交货两数</h3><ul><li>位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">//普通操作<br>void swap(int &amp;a, int &amp;b) {<br>  a = a + b;<br>  b = a - b;<br>  a = a - b;<br>}<br><br>//位与操作<br>void swap(int &amp;a, int &amp;b) {<br>  a ^= b;<br>  b ^= a;<br>  a ^= b;<br>}<br></code></pre></td></tr></tbody></table></figure><p>位与操作解释：第一步：a ^= b —&gt; a = (a^b); </p><p>第二步：b ^= a —&gt; b = b^(a^b) —&gt; b = (b^b)^a = a</p><p>第三步：a ^= b —&gt; a = (a^b)^a = (a^a)^b = b</p><h3 id="3-位操作判断奇偶数"><a href="#3-位操作判断奇偶数" class="headerlink" title="3. 位操作判断奇偶数"></a>3. 位操作判断奇偶数</h3><ul><li>只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if(0 == (a &amp; 1)) {<br> //偶数<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-位操作交换符号"><a href="#4-位操作交换符号" class="headerlink" title="4. 位操作交换符号"></a>4. 位操作交换符号</h3><ul><li>交换符号将正数变成负数，负数变成正数</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">int reversal(int a) {<br>  return ~a + 1;<br>}<br></code></pre></td></tr></tbody></table></figure><p>整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</p><h3 id="5-位操作求绝对值"><a href="#5-位操作求绝对值" class="headerlink" title="5. 位操作求绝对值"></a>5. 位操作求绝对值</h3><ul><li>整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 <strong>0xffffffff</strong>），然后根据符号进行相应的操作</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">int abs(int a) {<br>  int i = a &gt;&gt; 31;<br>  return i == 0 ? a : (~a + 1);<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面的操作可以进行优化，可以将 i == 0 的<strong>条件判断</strong>语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">int abs2(int a) {<br>  int i = a &gt;&gt; 31;<br>  return ((a^i) - i);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="6-利用或操作-和空格将英文字符转换为小写"><a href="#6-利用或操作-和空格将英文字符转换为小写" class="headerlink" title="6.利用或操作 | 和空格将英文字符转换为小写"></a>6.利用或操作 <code>|</code> 和空格将英文字符转换为小写</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-string">'a'</span> | <span class="hljs-string">' '</span>) = <span class="hljs-string">'a'</span><br>(<span class="hljs-string">'A'</span> | <span class="hljs-string">' '</span>) = <span class="hljs-string">'a'</span><br></code></pre></td></tr></tbody></table></figure><h3 id="7-利用与操作-amp-和下划线将英文字符转换为大写"><a href="#7-利用与操作-amp-和下划线将英文字符转换为大写" class="headerlink" title="7.利用与操作 &amp; 和下划线将英文字符转换为大写"></a>7.利用与操作 <code>&amp;</code> 和下划线将英文字符转换为大写</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-string">'b'</span> &amp; <span class="hljs-string">'_'</span>) = <span class="hljs-string">'B'</span><br>(<span class="hljs-string">'B'</span> &amp; <span class="hljs-string">'_'</span>) = <span class="hljs-string">'B'</span><br></code></pre></td></tr></tbody></table></figure><h3 id="8-利用异或操作-和空格进行英文字符大小写互换"><a href="#8-利用异或操作-和空格进行英文字符大小写互换" class="headerlink" title="8.利用异或操作 ^ 和空格进行英文字符大小写互换"></a>8.利用异或操作 <code>^</code> 和空格进行英文字符大小写互换</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-string">'d'</span> ^ <span class="hljs-string">' '</span>) = <span class="hljs-string">'D'</span><br>(<span class="hljs-string">'D'</span> ^ <span class="hljs-string">' '</span>) = <span class="hljs-string">'d'</span><br></code></pre></td></tr></tbody></table></figure><h3 id="9-判断两个数是否异号"><a href="#9-判断两个数是否异号" class="headerlink" title="9.判断两个数是否异号"></a>9.判断两个数是否异号</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ((x ^ y) &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>, y = <span class="hljs-number">2</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ((x ^ y) &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></tbody></table></figure><h3 id="10-加一"><a href="#10-加一" class="headerlink" title="10.加一"></a>10.加一</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>n = -~n;<br><span class="hljs-comment">// 现在 n = 2</span><br></code></pre></td></tr></tbody></table></figure><h3 id="11-减一"><a href="#11-减一" class="headerlink" title="11.减一"></a>11.减一</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>n = ~-n;<br><span class="hljs-comment">// 现在 n = 1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="12-n-amp-n-1"><a href="#12-n-amp-n-1" class="headerlink" title="12.n &amp; (n-1)"></a>12.<em>n &amp; (n-1)</em></h3><p>这个操作是算法中常见的，作用是消除数字 <code>n</code> 的二进制表示中的最后一个 1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;位运算技巧&quot;&gt;&lt;a href=&quot;#位运算技巧&quot; class=&quot;headerlink&quot; title=&quot;位运算技巧&quot;&gt;&lt;/a&gt;位运算技巧&lt;/h1&gt;&lt;h2 id=&quot;位操作符&quot;&gt;&lt;a href=&quot;#位操作符&quot; class=&quot;headerlink&quot; title=&quot;位操作符&quot;</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
</feed>
