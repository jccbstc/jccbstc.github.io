<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>业余的日落患者</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-08T09:38:16.960Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>及川彻</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>死锁定义及发生的条件</title>
    <link href="http://example.com/2023/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%8F%91%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6/"/>
    <id>http://example.com/2023/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%8F%91%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6/</id>
    <published>2023-03-08T07:20:27.984Z</published>
    <updated>2023-03-08T09:38:16.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁定义及发生的条件"><a href="#死锁定义及发生的条件" class="headerlink" title="死锁定义及发生的条件"></a>死锁定义及发生的条件</h1><p><strong>死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</strong></p><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p><ul><li>互斥条件；</li><li>持有并等待条件；</li><li>不可剥夺条件；</li><li>环路等待条件；</li></ul><h4 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h4><p>互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</p><p><img src="/image/%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6.webp" alt="互斥条件"></p><h4 id="持有并等待条件"><a href="#持有并等待条件" class="headerlink" title="持有并等待条件"></a>持有并等待条件</h4><p>持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</p><p><img src="/image/%E6%8C%81%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6.webp"></p><h4 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h4><p>不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</p><p><img src="/image/%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6.webp"></p><h4 id="环路等待条件"><a href="#环路等待条件" class="headerlink" title="环路等待条件"></a>环路等待条件</h4><p>环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</p><p>比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。</p><p><img src="/image/%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6.webp" alt="环路等待条件"></p><h3 id="避免死锁问题的发生"><a href="#避免死锁问题的发生" class="headerlink" title="避免死锁问题的发生"></a>避免死锁问题的发生</h3><p>那么避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。</p><p>那什么是资源有序分配法呢？</p><p>线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</p><p>我们使用资源有序分配法的方式来修改前面发生死锁的代码，我们可以不改动线程 A 的代码。</p><p>我们先要清楚线程 A 获取资源的顺序，它是先获取互斥锁 A，然后获取互斥锁 B。</p><p>所以我们只需将线程 B 改成以相同顺序的获取资源，就可以打破死锁了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;死锁定义及发生的条件&quot;&gt;&lt;a href=&quot;#死锁定义及发生的条件&quot; class=&quot;headerlink&quot; title=&quot;死锁定义及发生的条件&quot;&gt;&lt;/a&gt;死锁定义及发生的条件&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="http://example.com/2023/03/07/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/03/07/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2023-03-07T12:51:50.993Z</published>
    <updated>2023-03-08T06:46:38.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><p><img src="/image/v2-7a7c516c0aeb622705c86fd9b5e8c44a_720w.webp"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h4 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h4><p>Program Counter Register 程序计数器（寄存器）<br>作用：是记录下一条 jvm 指令的执行地址行号。<br>特点：</p><ul><li>是线程私有的</li><li>不会存在内存溢出</li></ul><h4 id="2）作用"><a href="#2）作用" class="headerlink" title="2）作用"></a>2）作用</h4><ul><li>解释器会解释指令为机器码交给 cpu 执行，程序计数器会记录下一条指令的地址行号，这样下一次解释器会从程序计数器拿到指令然后进行解释执行。</li><li>多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行。</li></ul><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h4 id="1）定义-1"><a href="#1）定义-1" class="headerlink" title="1）定义"></a>1）定义</h4><ul><li>每个线程运行需要的内存空间，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</li></ul><h5 id="垃圾回收是否涉及栈内存？"><a href="#垃圾回收是否涉及栈内存？" class="headerlink" title="垃圾回收是否涉及栈内存？"></a>垃圾回收是否涉及栈内存？</h5><p>不会。栈内存是方法调用产生的，方法调用结束后会弹出栈。</p><h5 id="栈内存分配越大越好吗？"><a href="#栈内存分配越大越好吗？" class="headerlink" title="栈内存分配越大越好吗？"></a>栈内存分配越大越好吗？</h5><p>不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</p><h5 id="方法呢的局部变量是否线程安全"><a href="#方法呢的局部变量是否线程安全" class="headerlink" title="方法呢的局部变量是否线程安全"></a>方法呢的局部变量是否线程安全</h5><p>如果方法内部的变量没有逃离方法的作用访问，它是线程安全的<br>如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题。</p><h4 id="2）栈内存溢出"><a href="#2）栈内存溢出" class="headerlink" title="2）栈内存溢出"></a>2）栈内存溢出</h4><p>栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 java.lang.stackOverflowError ，使用 -Xss256k 指定栈内存大小！</p><h4 id="3）线程运行诊断"><a href="#3）线程运行诊断" class="headerlink" title="3）线程运行诊断"></a>3）线程运行诊断</h4><p>案例一：cpu 占用过多<br>解决方法：Linux 环境下运行某些程序的时候，可能导致 CPU 的占用过高，这时需要定位占用 CPU 过高的线程</p><p>top 命令，查看是哪个进程占用 CPU 过高<br>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过 top 查到的进程号 通过 ps 命令进一步查看是哪个线程占用 CPU 过高<br>jstack 进程 id 通过查看进程中的线程的 nid ，刚才通过 ps 命令看到的 tid 来对比定位，注意 jstack 查找出的线程 id 是 16 进制的，需要转换。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>一些带有 native 关键字的方法就是需要 JAVA 去调用本地的C或者C++方法，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h4 id="1）定义-2"><a href="#1）定义-2" class="headerlink" title="1）定义"></a>1）定义</h4><p>Heap 堆</p><ul><li>通过new关键字创建的对象都会被放在堆内存</li></ul><p>特点</p><ul><li>它是线程共享，堆内存中的对象都需要考虑线程安全问题</li><li>有垃圾回收机制</li></ul><h4 id="2）堆内存溢出"><a href="#2）堆内存溢出" class="headerlink" title="2）堆内存溢出"></a>2）堆内存溢出</h4><p>java.lang.OutofMemoryError ：java heap space. 堆内存溢出<br>可以使用 -Xmx8m 来指定堆内存大小。</p><h4 id="2）堆内存诊断"><a href="#2）堆内存诊断" class="headerlink" title="2）堆内存诊断"></a>2）堆内存诊断</h4><ol><li>jps 工具<br>查看当前系统中有哪些 java 进程</li><li>jmap 工具<br>查看堆内存占用情况 jmap - heap 进程id</li><li>jconsole 工具<br>图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm 工具</li></ol><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h4 id="1）定义-3"><a href="#1）定义-3" class="headerlink" title="1）定义"></a>1）定义</h4><p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区域。方法区域类似于用于传统语言的编译代码的存储区域，或者类似于操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法，用于类和实例初始化以及接口初始化方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但简单的实现可能不会选择垃圾收集或压缩它。此规范不强制指定方法区的位置或用于管理已编译代码的策略。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果不需要更大的方法区域，则可以收缩。方法区域的内存不需要是连续的！</p><h4 id="2）组成"><a href="#2）组成" class="headerlink" title="2）组成"></a>2）组成</h4><p>Hotspot 虚拟机 jdk1.6 1.7 1.8 内存结构图</p><p><img src="/image/20210208112903305.png"></p><h4 id="3）方法区内存溢出"><a href="#3）方法区内存溢出" class="headerlink" title="3）方法区内存溢出"></a>3）方法区内存溢出</h4><ul><li>1.8 之前会导致永久代内存溢出<ul><li>使用 -XX:MaxPermSize=8m 指定永久代内存大小</li></ul></li><li>1.8 之后会导致元空间内存溢出<ul><li>使用 -XX:MaxMetaspaceSize=8m 指定元空间大小</li></ul></li></ul><h4 id="4）运行时常量池"><a href="#4）运行时常量池" class="headerlink" title="4）运行时常量池"></a>4）运行时常量池</h4><p>二进制字节码包含（类的基本信息，常量池，类方法定义，包含了虚拟机的指令）<br>首先看看常量池是什么，编译如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        System.out.println(<span class="hljs-string">"Hello World!"</span>);<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>然后使用 javap -v Test.class 命令反编译查看结果。</p><p><img src="/image/20210208124448238.png"></p><p>每条指令都会对应常量池表中一个地址，常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。</p><p><img src="/image/20210208124525875.png"></p><p><strong>常量池</strong>：<br>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息<br><strong>运行时常量池</strong>：<br>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><h4 id="5）StringTable"><a href="#5）StringTable" class="headerlink" title="5）StringTable"></a>5）StringTable</h4><ul><li>常量池中的字符串仅是符号，只有在被用到时才会转化为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</li></ul><p><strong>intern方法 1.8</strong><br>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败<br>无论放入是否成功，都会返回串池中的字符串对象</li></ul><p>注意：此时如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTable</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">"a"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">"b"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1 + s2;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"b"</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> s3.intern();<br>        System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br>        System.out.println(s5 == s3); <span class="hljs-comment">// false</span><br>        System.out.println(s6 == s5); <span class="hljs-comment">// true</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br><span class="hljs-comment">// "a" "b" 被放入串池中，str 则存在于堆内存之中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"b"</span>);<br><span class="hljs-comment">// 调用 str 的 intern 方法，这时串池中没有 "ab" ，则会将该字符串对象放入到串池中，此时堆内存与串池中的 "ab" 是同一个对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">st2</span> <span class="hljs-operator">=</span> str.intern();<br><span class="hljs-comment">// 给 str3 赋值，因为此时串池中已有 "ab" ，则直接将串池中的内容返回</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br><span class="hljs-comment">// 因为堆内存与串池中的 "ab" 是同一个对象，所以以下两条语句打印的都为 true</span><br>System.out.println(str == st2); <span class="hljs-comment">// true</span><br>System.out.println(str == str3); <span class="hljs-comment">// true</span><br>}<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">// 此处创建字符串对象 "ab" ，因为串池中还没有 "ab" ，所以将其放入串池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ab"</span>;<br>        <span class="hljs-comment">// "a" "b" 被放入串池中，str 则存在于堆内存之中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">"b"</span>);<br>        <span class="hljs-comment">// 此时因为在创建 str3 时，"ab" 已存在与串池中，所以放入失败，但是会返回串池中的 "ab" </span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> str.intern();<br>System.out.println(str == str2); <span class="hljs-comment">// false</span><br>System.out.println(str == str3); <span class="hljs-comment">// false</span><br>System.out.println(str2 == str3); <span class="hljs-comment">// true</span><br>}<br>}<br><br></code></pre></td></tr></tbody></table></figure><h4 id="6）StringTable-的位置"><a href="#6）StringTable-的位置" class="headerlink" title="6）StringTable 的位置"></a>6）StringTable 的位置</h4><p>jdk1.6 StringTable 位置是在永久代中，1.8 StringTable 位置是在堆中。</p><h4 id="7）StringTable-垃圾回收"><a href="#7）StringTable-垃圾回收" class="headerlink" title="7）StringTable 垃圾回收"></a>7）StringTable 垃圾回收</h4><p>-Xmx10m 指定堆内存大小<br>-XX:+PrintStringTableStatistics 打印字符串常量池信息<br>-XX:+PrintGCDetails<br>-verbose:gc 打印 gc 的次数，耗费时间等信息</p><h4 id="8）StringTable-性能调优"><a href="#8）StringTable-性能调优" class="headerlink" title="8）StringTable 性能调优"></a>8）StringTable 性能调优</h4><ul><li>因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间</li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">StringTableSize</span>=桶个数（最少设置为 1009 以上）<br></code></pre></td></tr></tbody></table></figure><ul><li>考虑是否需要将字符串对象入池<br>可以通过 intern 方法减少重复入池</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h4 id="1）定义-4"><a href="#1）定义-4" class="headerlink" title="1）定义"></a>1）定义</h4><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul><h4 id="2）使用直接内存的好处"><a href="#2）使用直接内存的好处" class="headerlink" title="2）使用直接内存的好处"></a>2）使用直接内存的好处</h4><p>文件读写流程：</p><p><img src="/image/20210208180041113.png"></p><p>因为 java 不能直接操作文件管理，需要切换到内核态，使用本地方法进行操作，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 然后在将系统缓冲区数据，复制到 java 堆内存中。缺点是数据存储了两份，在系统内存中有一份，java 堆中有一份，造成了不必要的复制。</p><p><strong>使用了 DirectBuffer 文件读取流程</strong></p><p><img src="/image/20210208181022863.png"></p><p>直接内存是操作系统和 Java 代码都可以访问的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。</p><h4 id="3）直接内存的回收机制总结"><a href="#3）直接内存的回收机制总结" class="headerlink" title="3）直接内存的回收机制总结"></a>3）直接内存的回收机制总结</h4><ul><li><p>使用了 Unsafe 类来完成直接内存的分配回收，回收需要主动调用freeMemory 方法</p></li><li><p>ByteBuffer 的实现内部使用了 Cleaner（虚引用）来检测 ByteBuffer 。一旦ByteBuffer 被垃圾回收，那么会由 ReferenceHandler（守护线程） 来调用 Cleaner 的 clean 方法调用 freeMemory 来释放内存</p></li></ul><p><strong>注意：</strong></p><p>一般用 jvm 调优时，会加上下面的参数：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">-XX:+DisableExplicitGC  <span class="hljs-regexp">//</span> 静止显示的 GC<br></code></pre></td></tr></tbody></table></figure><p>意思就是禁止我们手动的 GC，比如手动 System.gc() 无效，它是一种 full gc，会回收新生代、老年代，会造成程序执行的时间比较长。所以我们就通过 unsafe 对象调用 freeMemory 的方式释放内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构&quot;&gt;&lt;/a&gt;JVM内存结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/image/v2-7a7c516c0aeb622705c86fd9b5e8c4</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>进程间的通信方式</title>
    <link href="http://example.com/2023/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2023/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2023-03-06T12:28:36.396Z</published>
    <updated>2023-03-08T09:37:55.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>分为<strong>匿名管道</strong>和<strong>命名管道</strong></p><p><strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p><p><strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。它的好处，就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了。</p><p><strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，<strong>管道传输的数据是无格式的流且大小受限</strong>。</p><p><strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</p><p><strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。</p><p>同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。</p><p><strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以<strong>每个消息体都是固定大小的存储块</strong>，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p>存在不足的地方有两点，<strong>一是通信不及时，二是附件也有大小限制</strong>。</p><p><strong>消息队列不适合比较大数据的传输</strong>，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。</p><p><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><p><strong>消息队列</strong>克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong></p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><p><strong>共享内存</strong>可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，<strong>它直接分配一个共享空间，每个进程都可以直接访问</strong>，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有<strong>最快</strong>的进程间通信方式之名。但是便捷高效的共享内存通信，<strong>带来新的问题，多进程竞争同个共享资源会造成数据的错乱。</strong></p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，控制信号量的方式有两种原子操作：</p><ul><li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>信号初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p><p>信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执行。</p><p>需要<strong>信号量</strong>来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。<strong>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步</strong>，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>上面说的进程间通信，都是常规状态下的工作模式。<strong>对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。</strong></p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><p><strong>进程有三种方式响应信号</strong></p><p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p><p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p><p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想<strong>跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。</strong></p><p>Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 <strong>TCP 协议</strong>的通信方式，一个是基于 <strong>UDP 协议</strong>的通信方式，一个是<strong>本地进程间</strong>通信方式。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong>，这也就是它们之间的最大区别。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程间的通信方式&quot;&gt;&lt;a href=&quot;#进程间的通信方式&quot; class=&quot;headerlink&quot; title=&quot;进程间的通信方式&quot;&gt;&lt;/a&gt;进程间的通信方式&lt;/h1&gt;&lt;h2 id=&quot;管道&quot;&gt;&lt;a href=&quot;#管道&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="进程" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发类问题</title>
    <link href="http://example.com/2023/02/26/%E9%9D%A2%E8%AF%95/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/02/26/%E9%9D%A2%E8%AF%95/%E5%B9%B6%E5%8F%91%E7%B1%BB%E9%97%AE%E9%A2%98/</id>
    <published>2023-02-26T13:03:50.024Z</published>
    <updated>2023-03-03T13:24:29.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发类问题"><a href="#并发类问题" class="headerlink" title="并发类问题"></a>并发类问题</h1><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><h5 id="六种状态及转换"><a href="#六种状态及转换" class="headerlink" title="六种状态及转换"></a>六种状态及转换</h5><p><img src="/image/image-20210831090722658.png"></p><ul><li>新建<ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></li><li>可运行<ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></li><li>终结<ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li><li>此时会取消与底层线程关联</li></ul></li><li>阻塞<ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></li><li>等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></li><li>有时限等待<ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></li></ul><p><em><strong>其它情况（了解）</strong></em></p><ul><li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li><li>park，unpark 等方法也可以让线程等待和唤醒</li></ul><h5 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h5><p>五种状态的说法来自于操作系统层面的划分</p><p><img src="/image/Snipaste_2023-02-26_17-30-45.png"></p><p><img src="/image/image-20210831092652602.png"></p><ul><li>运行态：分到 cpu 时间，能真正执行线程内代码的</li><li>就绪态：有资格分到 cpu 时间，但还未轮到它的</li><li>阻塞态：没资格分到 cpu 时间的<ul><li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li><li>多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等</li></ul></li><li>新建与终结态：与 java 中同名状态类似</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>七大参数</strong></p><ol><li>corePoolSize <strong>核心线程数目</strong> - 池中会保留的最多线程数</li><li>maximumPoolSize <strong>最大线程数目</strong> - 核心线程+救急线程的最大数目</li><li>keepAliveTime <strong>生存时间</strong> - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit <strong>时间单位</strong> - 救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue <strong>阻塞队列</strong> - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory <strong>线程工厂</strong> - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler <strong>拒绝策略</strong> - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol><li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li><li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li><li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li><li>丢弃最早排队任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li></ol></li></ol><p><img src="/image/image-20210831093204388.png"></p><h3 id="wait-vs-sleep"><a href="#wait-vs-sleep" class="headerlink" title="wait vs sleep"></a>wait vs sleep</h3><p>共同点</p><ul><li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li></ul><p>不同点</p><ul><li><p>语法使用不同</p><ul><li>wait 方法必须配合 synchronized 一起使用，不然在运行时就会抛出 IllegalMonitorStateException 的异常</li></ul></li><li><p>方法归属不同</p><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li></ul></li><li><p>醒来时机不同</p><ul><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>sleep 方法具有主动唤醒功能，而不传递任何参数的 wait 方法只能被动的被唤醒。</li><li>它们都可以被打断唤醒</li></ul></li><li><p>锁特性不同（重点）</p><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制(同第一条)</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></li></ul><h3 id="lock-vs-synchronized"><a href="#lock-vs-synchronized" class="headerlink" title="lock vs synchronized"></a>lock vs synchronized</h3><p><strong>三个层面</strong></p><p>不同点</p><ul><li>语法层面<ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li></ul></li><li>功能层面<ul><li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul></li><li>性能层面<ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul></li></ul><p><strong>公平锁</strong></p><ul><li>公平锁的公平体现<ul><li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li><li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li><li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li></ul></li><li>公平锁会降低吞吐量，一般不用</li></ul><p><strong>条件变量</strong></p><ul><li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</li><li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ul><li>掌握线程安全要考虑的三个问题</li><li>掌握 volatile 能解决哪些问题</li></ul><p><strong>原子性</strong></p><ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li></ul><p><strong>可见性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li></ul><p><strong>有序性</strong></p><ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li><li>注意：<ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul></li></ul><h3 id="Hashtable-vs-ConcurrentHashMap"><a href="#Hashtable-vs-ConcurrentHashMap" class="headerlink" title="Hashtable vs ConcurrentHashMap"></a>Hashtable vs ConcurrentHashMap</h3><ul><li><p>Hashtable 与 ConcurrentHashMap 的区别</p></li><li><p>ConcurrentHashMap 在不同版本的实现区别</p></li></ul><p><strong>Hashtable 对比 ConcurrentHashMap</strong></p><ul><li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li><li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li><li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li></ul><p><strong>ConcurrentHashMap 1.7</strong></p><ul><li>数据结构：<code>Segment(大数组) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li><li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。<strong>Segment 数组不能扩容</strong>，意味着并发度在 ConcurrentHashMap 创建时就固定了</li><li>索引计算<ul><li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li><li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li></ul></li><li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，<strong>每次扩容翻倍</strong></li><li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li></ul><p><strong>ConcurrentHashMap 1.8</strong></p><ul><li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li><li>并发度：Node 数组有多大，并发度就有多大，<strong>与 1.7 不同，Node 数组可以扩容</strong></li><li>扩容条件：<strong>Node 数组满 3/4 时就会扩容</strong></li><li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode</li><li>扩容时并发 get<ul><li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li><li>如果链表长度超过 1，则需要对节点进行复制（创建新节点），怕的是节点迁移后 next 指针改变</li><li>如果链表最后几个元素扩容后索引不变，则节点无需复制</li></ul></li><li>扩容时并发 put<ul><li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li><li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li><li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li></ul></li><li>与 1.7 相比是懒惰初始化</li><li>capacity 代表预估的元素个数，capacity / factory 来计算出初始数组大小，需要贴近 $2^n$ </li><li>loadFactor 只在计算初始数组大小时被使用，之后扩容固定为 3/4</li><li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul><li>ThreadLocal 的作用与原理</li><li>ThreadLocal 的内存释放时机</li></ul><p><strong>作用</strong></p><ul><li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li><li>ThreadLocal 同时实现了线程内的资源共享</li></ul><p><strong>原理</strong></p><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p><ul><li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li><li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li><li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li></ul><p>ThreadLocalMap 的一些特点</p><ul><li>key 的 hash 值统一分配</li><li><strong>初始容量 16，扩容因子 2/3，扩容容量翻倍</strong></li><li>key 索引冲突后用开放寻址法解决冲突</li></ul><p><strong>弱引用 key</strong></p><p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p><ul><li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存</li></ul><p><strong>内存释放时机</strong></p><ul><li>被动 GC 释放 key<ul><li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li></ul></li><li>懒惰被动释放 value<ul><li>get key 时，发现是 null key，则释放其 value 内存</li><li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li></ul></li><li>主动 remove 释放 key，value<ul><li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li><li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发类问题&quot;&gt;&lt;a href=&quot;#并发类问题&quot; class=&quot;headerlink&quot; title=&quot;并发类问题&quot;&gt;&lt;/a&gt;并发类问题&lt;/h1&gt;&lt;h3 id=&quot;线程状态&quot;&gt;&lt;a href=&quot;#线程状态&quot; class=&quot;headerlink&quot; title=&quot;线程状态&quot;</summary>
      
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="线程" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://example.com/2023/02/23/%E9%9D%A2%E8%AF%95/HashMap/"/>
    <id>http://example.com/2023/02/23/%E9%9D%A2%E8%AF%95/HashMap/</id>
    <published>2023-02-23T05:36:17.271Z</published>
    <updated>2023-02-26T13:07:47.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h4 id="底层数据结构，1-7与1-8有何不同？"><a href="#底层数据结构，1-7与1-8有何不同？" class="headerlink" title="底层数据结构，1.7与1.8有何不同？"></a>底层数据结构，1.7与1.8有何不同？</h4><p>1.7数组+链表，1.8数组+（链表|红黑树）</p><h4 id="为何要用红黑树，为何一上来不树化？"><a href="#为何要用红黑树，为何一上来不树化？" class="headerlink" title="为何要用红黑树，为何一上来不树化？"></a>为何要用红黑树，为何一上来不树化？</h4><p>红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应当是偶然情况<br>hash表的查找，更新的时间复杂度是0(1），而红黑树的查找，更新的时间复杂度是0(log2n)，TreeNode 占用空间也比普通Node的大，如非必要，尽量还是使用链表</p><h4 id="树化阈值为何是8"><a href="#树化阈值为何是8" class="headerlink" title="树化阈值为何是8"></a>树化阈值为何是8</h4><p> hash值如果足够随机，则在hash表内按泊松分布，在负载因子0.75的情况下，长度超过8的链表出现概率是<br>0.00000006，选择8就是为了让树化几率足够小</p><h4 id="何时会树化"><a href="#何时会树化" class="headerlink" title="何时会树化"></a>何时会树化</h4><p>树化两个条件：链表长度超过树化阈值；数组容量 &gt;=64</p><h4 id="何时会退化为链表？"><a href="#何时会退化为链表？" class="headerlink" title="何时会退化为链表？"></a>何时会退化为链表？</h4><p>退化情况1：在扩容时如果拆分树时，树元素个数&lt;=6则会退化链表，<br>退化情况2：remove树节点时，若root、root.left、root.right、root.left.left有一个为 null，也会退化为链表</p><h4 id="索引如何计算？"><a href="#索引如何计算？" class="headerlink" title="索引如何计算？"></a>索引如何计算？</h4><p>计算对象的hashCode()，再进行调用HashMap的hash()方法进行二次哈希，最后&amp;(capacity-1)得到索引</p><h4 id="hashCode都有了，为何还要提供hash-）方法？"><a href="#hashCode都有了，为何还要提供hash-）方法？" class="headerlink" title="hashCode都有了，为何还要提供hash(）方法？"></a>hashCode都有了，为何还要提供hash(）方法？</h4><p>二次hash(）是为了综合高位数据，让哈希分布更为均匀</p><h4 id="数组容量为何是2的n次幂？"><a href="#数组容量为何是2的n次幂？" class="headerlink" title="数组容量为何是2的n次幂？"></a>数组容量为何是2的n次幂？</h4><p>计算索引时，如果是2的n次幂可以使用位与运算代替取模，效率更高；扩容时 hash&amp;oldCap==0的元素留在原来位置，否则新位置=旧位置+oldCap</p><p>都是为了配合容量为2的n次幂时的优化手段，例如Hashtable的容量就不是2的n次幂，并不能说哪种设计更<br>优，应该是设计者综合了各种因素，最终选择了使用2的n次幂作为容量</p><h4 id="介绍一下put方法流程，1-7与1-8有何不同"><a href="#介绍一下put方法流程，1-7与1-8有何不同" class="headerlink" title="介绍一下put方法流程，1.7与1.8有何不同?"></a>介绍一下put方法流程，1.7与1.8有何不同?</h4><p>1.HashMap是懒惰创建数组的，首次使用才创建数组</p><p>2.计算索引(桶下标)</p><p>3.如果桶下标还没人占用，创建Node占位返回</p><p>4.如果桶下标已经有人占用</p><p>​已经是TreeNode走红黑树的添加或更新逻辑</p><p>​是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</p><p>5.返回前检查容量是否超过阈值，一旦超过进行扩容</p><p>6.不同</p><p>​链表插入节点时，1.7是头插法，1.8是尾插法</p><p>​1.7是大于等于阈值且没有空位时才扩容，而1.8是大于阈值就扩容</p><h4 id="1-8在扩容计算Node索引时，会优化加载因子为何默认是0-75f"><a href="#1-8在扩容计算Node索引时，会优化加载因子为何默认是0-75f" class="headerlink" title="1.8在扩容计算Node索引时，会优化加载因子为何默认是0.75f"></a>1.8在扩容计算Node索引时，会优化加载因子为何默认是0.75f</h4><p>在空间占用与查询时间之间取得较好的权衡</p><p>大于这个值，空间节省了，但链表就会比较长影响性能</p><p>小于这个值，冲突减少了，但扩容就会更频繁，空间占用多</p><h4 id="多线程下会有啥问题"><a href="#多线程下会有啥问题" class="headerlink" title="多线程下会有啥问题?"></a>多线程下会有啥问题?</h4><p>扩容死链（1.7)</p><p>数据错乱（1.7，1.8)</p><h4 id="key能否为null，作为key的对象有什么要求"><a href="#key能否为null，作为key的对象有什么要求" class="headerlink" title="key能否为null，作为key的对象有什么要求?"></a>key能否为null，作为key的对象有什么要求?</h4><p>1.HashMap 的 key可以为null，但 Map 的其他实现则不然</p><p>2.作为key的对象，必须实现 hashCode和equals，并且 key的内容不能修改（不可变)</p><h4 id="String对象的-hashCode-如何设计的，为啥每次乘的是31"><a href="#String对象的-hashCode-如何设计的，为啥每次乘的是31" class="headerlink" title="String对象的 hashCode()如何设计的，为啥每次乘的是31"></a>String对象的 hashCode()如何设计的，为啥每次乘的是31</h4><p>目标是达到较为均匀的散列效果，每个字符串的hashCode足够独特</p><p>1.字符串中的每个字符都可以表现为一个数字，称为Sj，其中i的范围是0~n - 1</p><p>2.散列公式为:So* 31n-1+ S1* 31n-2+ … Si * 31n-1-i + …Sn-1 * 310</p><p>3.31代入公式有较好的散列特性，并且31*h可以被优化为</p><p>​即32 * h - h</p><p>​即25 * h - h</p><p>​即h &lt;&lt; 5 - h</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h1&gt;&lt;h4 id=&quot;底层数据结构，1-7与1-8有何不同？&quot;&gt;&lt;a href=&quot;#底层数据结构，1-7与1-8</summary>
      
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="HashMap" scheme="http://example.com/tags/HashMap/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList的扩容规则,FailFast与FailSafe</title>
    <link href="http://example.com/2023/02/21/%E9%9D%A2%E8%AF%95/ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99,FailFast%E4%B8%8EFailSafe/"/>
    <id>http://example.com/2023/02/21/%E9%9D%A2%E8%AF%95/ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99,FailFast%E4%B8%8EFailSafe/</id>
    <published>2023-02-21T12:43:04.840Z</published>
    <updated>2023-02-26T13:08:01.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList的扩容规则-FailFast与FailSafe"><a href="#ArrayList的扩容规则-FailFast与FailSafe" class="headerlink" title="ArrayList的扩容规则,FailFast与FailSafe"></a>ArrayList的扩容规则,FailFast与FailSafe</h1><h2 id="ArrayList的扩容规则"><a href="#ArrayList的扩容规则" class="headerlink" title="ArrayList的扩容规则"></a>ArrayList的扩容规则</h2><p><img src="/image/Snipaste_2023-02-21_20-18-44.png"></p><p>ArrayList无参构造源码</p><p>创建时是一个为空的数组，第一次添加元素的时候才分配容量为10的内存</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>}<br></code></pre></td></tr></tbody></table></figure><p>ArrayList有参构造源码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> {<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) {<br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"Illegal Capacity: "</span>+<br>                                           initialCapacity);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>add()扩容不是直接乘以1.5，先用位运算&gt;&gt;1，然后加上本身</p><figure class="highlight node-repl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">15</span>*<span class="hljs-number">1.5</span></span><br>&lt; 22.5<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">15</span>&gt;&gt;<span class="hljs-number">1</span></span><br>&lt; 7<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">7</span>+<span class="hljs-number">15</span></span><br>&lt; 22<br></code></pre></td></tr></tbody></table></figure><h2 id="FailFast与FailSafe"><a href="#FailFast与FailSafe" class="headerlink" title="FailFast与FailSafe"></a>FailFast与FailSafe</h2><p><img src="/image/Snipaste_2023-02-22_16-18-08.png"></p><h3 id="FailFast"><a href="#FailFast" class="headerlink" title="FailFast:"></a>FailFast:</h3><p>ArrayList源码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; {<br>    <span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> cursor != size;<br>    }<br><br>    <span class="hljs-meta">@SuppressWarnings("unchecked")</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> {<br>        checkForComodification();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        checkForComodification();<br><br>        <span class="hljs-keyword">try</span> {<br>            ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>            cursor = lastRet;<br>            lastRet = -<span class="hljs-number">1</span>;<br>            expectedModCount = modCount;<br>        } <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) {<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        }<br>    }<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>checkForComodification这个方法，它是在<strong>modCount != expectedModCount的时候抛出的异常</strong>，而在next方法中第一句就是checkForComodification，所以遍历集合才会可能抛出并发修改异常。</p><p>而且，在创建一个迭代器后，expectedModCount的初始值就是modCount了，对集合修改只会改变modCount，expectedModCount只会在迭代器的remove方法中被修改为modCountt</p><p>ArrayList的其他方法</p><p>remove：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> {<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) {<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) {<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> {<br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>fastRemove中对modCount++了，所以后面modCount会和expectedModCount不相等，进而抛出并发修改异常。</p><p>add：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> {<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>在ensureCapacityInternal方法里对modCount++了。</p><p>set：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> {<br>    rangeCheck(index);<br><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    elementData[index] = element;<br>    <span class="hljs-keyword">return</span> oldValue;<br>}<br></code></pre></td></tr></tbody></table></figure><p>可以看出set方法并没有对modCount++，所以对集合的某个元素进行修改并不会fail-fast</p><h3 id="FailSafe"><a href="#FailSafe" class="headerlink" title="FailSafe:"></a>FailSafe:</h3><p>ArrayList使用fail-fast机制自然是因为它增强了数据的安全性。但在某些场景，我们可能想避免fail-fast机制抛出的异常，这时我们就要将ArrayList替换为使用fail-safe机制的CopyOnWriteArrayList。</p><p><strong>写时复制</strong>，简单理解就是，当我们往一个容器添加元素的时候，先将当前容器复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> {<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> {<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    } <span class="hljs-keyword">finally</span> {<br>        lock.unlock();<br>    }<br>}<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArray</span><span class="hljs-params">(Object[] a)</span> {<br>    array = a;<br>}<br></code></pre></td></tr></tbody></table></figure><p>添加的时候是需要加锁的，否则多线程写的时候会复制出N个副本出来……</p><p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p><p>CopyOnWrite的应用场景：CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p><p>CopyOnWrite的缺点：CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下：</p><h3 id="如何避免fail-fast抛异常？"><a href="#如何避免fail-fast抛异常？" class="headerlink" title="如何避免fail-fast抛异常？"></a><strong>如何避免fail-fast抛异常？</strong></h3><p>1.如果非要在遍历的时候修改集合，那么建议用迭代器的remove等方法，而不是用集合的remove等方法。</p><p>2.如果是并发的环境，那还要对Iterator对象加锁；也可以直接使用Collections.synchronizedList。</p><p>3.CopyOnWriteArrayList（采用fail-safe）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ArrayList的扩容规则-FailFast与FailSafe&quot;&gt;&lt;a href=&quot;#ArrayList的扩容规则-FailFast与FailSafe&quot; class=&quot;headerlink&quot; title=&quot;ArrayList的扩容规则,FailFast与Fail</summary>
      
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="ArrayList" scheme="http://example.com/tags/ArrayList/"/>
    
    <category term="迭代器" scheme="http://example.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>位运算技巧</title>
    <link href="http://example.com/2023/02/05/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2023/02/05/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/</id>
    <published>2023-02-05T05:18:38.235Z</published>
    <updated>2023-02-05T05:20:41.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算技巧"><a href="#位运算技巧" class="headerlink" title="位运算技巧"></a>位运算技巧</h1><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><ul><li><p>&amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0，如<br>  1 0 0 1 1<br>&amp;  1 1 0 0 1<br><code>------------------------------</code><br>  1 0 0 0 1 </p></li><li><p>| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如<br>  1 0 0 1 1<br>|   1 1 0 0 1<br><code>------------------------------</code><br>  1 1 0 1 1 </p></li><li><p>^ 异或运算，两个位相同则为 0，不同则为 1，如<br>  1 0 0 1 1<br>^  1 1 0 0 1<br><code>-----------------------------</code><br>  0 1 0 1 0 </p></li><li><p>~ 取反运算，0 则变为 1，1 则变为 0，如<br>~   1 0 0 1 1<br><code>-----------------------------</code><br>   0 1 1 0 0 </p></li><li><p>&lt;&lt; 左移运算，向左进行移位操作，高位丢弃，低位补 0，如</p></li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">int a = 8;<br>a &lt;&lt; 3;<br>移位前：0000 0000 0000 0000 0000 0000 0000 1000<br>移位后：0000 0000 0000 0000 0000 0000 0100 0000<br></code></pre></td></tr></tbody></table></figure><p>&gt;&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，</p><p>无符号右移：&gt;&gt;&gt;，将二进制向右移动1位，最左边用0填补如</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">unsigned int a = 8;<br>a &gt;&gt; 3;<br>移位前：0000 0000 0000 0000 0000 0000 0000 1000<br>移位后：0000 0000 0000 0000 0000 0000 0000 0001<br><br>int a = -8;<br>a &gt;&gt; 3;<br>移位前：1111 1111 1111 1111 1111 1111 1111 1000<br>移位前：1111 1111 1111 1111 1111 1111 1111 1111<br></code></pre></td></tr></tbody></table></figure><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><h3 id="1-位操作实现乘除法"><a href="#1-位操作实现乘除法" class="headerlink" title="1. 位操作实现乘除法"></a>1. 位操作实现乘除法</h3><ul><li>数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">int a = 2;<br>a &gt;&gt; 1; ---&gt; 1<br>a &lt;&lt; 1; ---&gt; 4<br></code></pre></td></tr></tbody></table></figure><h3 id="2-位操作交货两数"><a href="#2-位操作交货两数" class="headerlink" title="2. 位操作交货两数"></a>2. 位操作交货两数</h3><ul><li>位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">//普通操作<br>void swap(int &amp;a, int &amp;b) {<br>  a = a + b;<br>  b = a - b;<br>  a = a - b;<br>}<br><br>//位与操作<br>void swap(int &amp;a, int &amp;b) {<br>  a ^= b;<br>  b ^= a;<br>  a ^= b;<br>}<br></code></pre></td></tr></tbody></table></figure><p>位与操作解释：第一步：a ^= b —&gt; a = (a^b); </p><p>第二步：b ^= a —&gt; b = b^(a^b) —&gt; b = (b^b)^a = a</p><p>第三步：a ^= b —&gt; a = (a^b)^a = (a^a)^b = b</p><h3 id="3-位操作判断奇偶数"><a href="#3-位操作判断奇偶数" class="headerlink" title="3. 位操作判断奇偶数"></a>3. 位操作判断奇偶数</h3><ul><li>只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if(0 == (a &amp; 1)) {<br> //偶数<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="4-位操作交换符号"><a href="#4-位操作交换符号" class="headerlink" title="4. 位操作交换符号"></a>4. 位操作交换符号</h3><ul><li>交换符号将正数变成负数，负数变成正数</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">int reversal(int a) {<br>  return ~a + 1;<br>}<br></code></pre></td></tr></tbody></table></figure><p>整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</p><h3 id="5-位操作求绝对值"><a href="#5-位操作求绝对值" class="headerlink" title="5. 位操作求绝对值"></a>5. 位操作求绝对值</h3><ul><li>整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 <strong>0xffffffff</strong>），然后根据符号进行相应的操作</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">int abs(int a) {<br>  int i = a &gt;&gt; 31;<br>  return i == 0 ? a : (~a + 1);<br>}<br></code></pre></td></tr></tbody></table></figure><p>上面的操作可以进行优化，可以将 i == 0 的<strong>条件判断</strong>语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">int abs2(int a) {<br>  int i = a &gt;&gt; 31;<br>  return ((a^i) - i);<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="6-利用或操作-和空格将英文字符转换为小写"><a href="#6-利用或操作-和空格将英文字符转换为小写" class="headerlink" title="6.利用或操作 | 和空格将英文字符转换为小写"></a>6.利用或操作 <code>|</code> 和空格将英文字符转换为小写</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-string">'a'</span> | <span class="hljs-string">' '</span>) = <span class="hljs-string">'a'</span><br>(<span class="hljs-string">'A'</span> | <span class="hljs-string">' '</span>) = <span class="hljs-string">'a'</span><br></code></pre></td></tr></tbody></table></figure><h3 id="7-利用与操作-amp-和下划线将英文字符转换为大写"><a href="#7-利用与操作-amp-和下划线将英文字符转换为大写" class="headerlink" title="7.利用与操作 &amp; 和下划线将英文字符转换为大写"></a>7.利用与操作 <code>&amp;</code> 和下划线将英文字符转换为大写</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-string">'b'</span> &amp; <span class="hljs-string">'_'</span>) = <span class="hljs-string">'B'</span><br>(<span class="hljs-string">'B'</span> &amp; <span class="hljs-string">'_'</span>) = <span class="hljs-string">'B'</span><br></code></pre></td></tr></tbody></table></figure><h3 id="8-利用异或操作-和空格进行英文字符大小写互换"><a href="#8-利用异或操作-和空格进行英文字符大小写互换" class="headerlink" title="8.利用异或操作 ^ 和空格进行英文字符大小写互换"></a>8.利用异或操作 <code>^</code> 和空格进行英文字符大小写互换</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(<span class="hljs-string">'d'</span> ^ <span class="hljs-string">' '</span>) = <span class="hljs-string">'D'</span><br>(<span class="hljs-string">'D'</span> ^ <span class="hljs-string">' '</span>) = <span class="hljs-string">'d'</span><br></code></pre></td></tr></tbody></table></figure><h3 id="9-判断两个数是否异号"><a href="#9-判断两个数是否异号" class="headerlink" title="9.判断两个数是否异号"></a>9.判断两个数是否异号</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ((x ^ y) &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>, y = <span class="hljs-number">2</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ((x ^ y) &lt; <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></tbody></table></figure><h3 id="10-加一"><a href="#10-加一" class="headerlink" title="10.加一"></a>10.加一</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>n = -~n;<br><span class="hljs-comment">// 现在 n = 2</span><br></code></pre></td></tr></tbody></table></figure><h3 id="11-减一"><a href="#11-减一" class="headerlink" title="11.减一"></a>11.减一</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>n = ~-n;<br><span class="hljs-comment">// 现在 n = 1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="12-n-amp-n-1"><a href="#12-n-amp-n-1" class="headerlink" title="12.n &amp; (n-1)"></a>12.<em>n &amp; (n-1)</em></h3><p>这个操作是算法中常见的，作用是消除数字 <code>n</code> 的二进制表示中的最后一个 1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;位运算技巧&quot;&gt;&lt;a href=&quot;#位运算技巧&quot; class=&quot;headerlink&quot; title=&quot;位运算技巧&quot;&gt;&lt;/a&gt;位运算技巧&lt;/h1&gt;&lt;h2 id=&quot;位操作符&quot;&gt;&lt;a href=&quot;#位操作符&quot; class=&quot;headerlink&quot; title=&quot;位操作符&quot;</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://example.com/2023/02/05/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2023/02/05/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2023-02-05T04:13:36.269Z</published>
    <updated>2023-02-06T05:07:37.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>191.位1的个数</p><p>剑指 Offer 56 - I. 数组中数字出现的次数</p><p>剑指 Offer 56 - II. 数组中数字出现的次数 II</p><p>剑指 Offer 65. 不用加减乘除做加法</p><p>231.2 的幂</p><p>268.丢失的数字</p><h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191.位1的个数"></a>191.位1的个数</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) {<br>            sum += (n &amp; <span class="hljs-number">1</span>);<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">return</span> sum;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a>剑指 Offer 56 - I. 数组中数字出现的次数</h2><p><img src="/image/Snipaste_2023-02-05_12-11-13.png" alt="Snipaste_2023-02-05_12-11-13"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumbers(<span class="hljs-type">int</span>[] nums) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: nums) {<br>            a ^= i;<br>        }<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> ((a &amp; m) == <span class="hljs-number">0</span>) {<br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: nums) {<br>            <span class="hljs-keyword">if</span> ((i &amp; m) == <span class="hljs-number">0</span>) x ^= i;<br>            <span class="hljs-keyword">else</span> y ^= i;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] {x,y};<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a>剑指 Offer 56 - II. 数组中数字出现的次数 II</h2><p><img src="/image/Snipaste_2023-02-05_12-11-38.png" alt="Snipaste_2023-02-05_12-11-38"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">singleNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; ++j) {<br>                count += (nums[j] &gt;&gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            }<br>            <span class="hljs-keyword">if</span> (count % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>) {<br>                result |= <span class="hljs-number">1</span> &lt;&lt; i;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a>剑指 Offer 65. 不用加减乘除做加法</h2><p><img src="/image/Snipaste_2023-02-05_12-11-48.png" alt="Snipaste_2023-02-05_12-11-48"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<br>            a ^= b;<br>            b = c;<br>        }<br>        <span class="hljs-keyword">return</span> a;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231.2 的幂"></a>231.2 的幂</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268.丢失的数字"></a>268.丢失的数字</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">missingNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length + <span class="hljs-number">1</span>; ++i) {<br>            ans ^= i;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) {<br>            ans ^= nums[i];<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h1&gt;&lt;p&gt;191.位1的个数&lt;/p&gt;
&lt;p&gt;剑指 Offer 56 - I. 数组中数字出现的次数&lt;/p&gt;
&lt;p&gt;剑指 Offer 56 - </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法前五种</title>
    <link href="http://example.com/2023/01/05/%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%89%8D%E4%BA%94%E7%A7%8D/"/>
    <id>http://example.com/2023/01/05/%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%89%8D%E4%BA%94%E7%A7%8D/</id>
    <published>2023-01-05T07:22:39.211Z</published>
    <updated>2023-01-05T07:23:54.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十大排序算法前五种"><a href="#十大排序算法前五种" class="headerlink" title="十大排序算法前五种"></a>十大排序算法前五种</h1><p><img src="/image/%E6%8E%92%E5%BA%8F_%E6%80%BB%E7%BB%93.png"></p><h3 id="冒泡排序（Bubble-Sort"><a href="#冒泡排序（Bubble-Sort" class="headerlink" title="冒泡排序（Bubble Sort)"></a>冒泡排序（Bubble Sort)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] arr) {<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) {<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) {<br>               <span class="hljs-keyword">if</span> (arr[j + <span class="hljs-number">1</span>] &lt; arr[j]) {<br>                   <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j + <span class="hljs-number">1</span>];<br>                   arr[j + <span class="hljs-number">1</span>] = arr[j];<br>                   arr[j] = temp;<br>               }<br>           }<br>       }<br>       <span class="hljs-keyword">return</span> arr;<br>   }<br></code></pre></td></tr></tbody></table></figure><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] selectionSort(<span class="hljs-type">int</span>[] arr) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; arr.length; j++) {<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex])<br>                minIndex = j;<br>        }<br>        <span class="hljs-keyword">if</span> (i != minIndex) {<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[minIndex];<br>            arr[minIndex] = arr[i];<br>            arr[i] = temp;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> arr;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] insertionSort(<span class="hljs-type">int</span>[] arr) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; ++i) {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; current &lt; arr[preIndex]) {<br>            arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>            preIndex --;<br>        }<br>        arr[preIndex + <span class="hljs-number">1</span>] = current;<br>    }<br>    <span class="hljs-keyword">return</span> arr;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] shellSort(<span class="hljs-type">int</span>[] arr) {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> temp, gap = len / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; len; i++) {<br>            temp = arr[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; temp) {<br>                arr[preIndex + gap] = arr[preIndex];<br>                preIndex -= gap;<br>            }<br>            arr[preIndex + gap] = temp;<br>        }<br>        gap /= <span class="hljs-number">2</span>;<br>    }<br>    <span class="hljs-keyword">return</span> arr;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] mergeSort(<span class="hljs-type">int</span>[] arr) {<br>    <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span>[] left = Arrays.copyOfRange(arr, <span class="hljs-number">0</span>, mid);<br>    <span class="hljs-type">int</span>[] right = Arrays.copyOfRange(arr, mid, arr.length);<br>    <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));<br>}<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] merge(<span class="hljs-type">int</span>[] left, <span class="hljs-type">int</span>[] right) {<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[left.length + right.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; index &lt; result.length; index++) {<br>        <span class="hljs-keyword">if</span> (i &gt;= left.length)<br>            result[index] = right[j++];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt;= right.length)<br>            result[index] = left[i++];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left[i] &gt; right[j])<br>            result[index] = right[j++];<br>        <span class="hljs-keyword">else</span><br>            result[index] = left[i++];<br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十大排序算法前五种&quot;&gt;&lt;a href=&quot;#十大排序算法前五种&quot; class=&quot;headerlink&quot; title=&quot;十大排序算法前五种&quot;&gt;&lt;/a&gt;十大排序算法前五种&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/image/%E6%8E%92%E5%BA%8F_%E6%80</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>不同路径问题</title>
    <link href="http://example.com/2023/01/02/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/01/02/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-01-02T06:18:23.358Z</published>
    <updated>2023-01-02T06:19:18.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不同路径问题"><a href="#不同路径问题" class="headerlink" title="不同路径问题"></a>不同路径问题</h1><p>62.不同路径</p><p>63.不同路径 II</p><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp.length; ++i) {<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; dp[<span class="hljs-number">0</span>].length; ++i) {<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; dp.length; ++i) {<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; dp[i].length; ++j) {<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63.不同路径 II"></a>63.不同路径 II</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> {<br>        <span class="hljs-keyword">if</span> (obstacleGrid == <span class="hljs-literal">null</span> || obstacleGrid.length == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length, n = obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) {<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) {<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++) {<br>                <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">0</span>) {<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;不同路径问题&quot;&gt;&lt;a href=&quot;#不同路径问题&quot; class=&quot;headerlink&quot; title=&quot;不同路径问题&quot;&gt;&lt;/a&gt;不同路径问题&lt;/h1&gt;&lt;p&gt;62.不同路径&lt;/p&gt;
&lt;p&gt;63.不同路径 II&lt;/p&gt;
&lt;h2 id=&quot;62-不同路径&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="矩阵" scheme="http://example.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>动态规划入门题</title>
    <link href="http://example.com/2023/01/02/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%E9%A2%98/"/>
    <id>http://example.com/2023/01/02/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%E9%A2%98/</id>
    <published>2023-01-02T03:34:42.701Z</published>
    <updated>2023-01-02T03:36:45.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划入门题"><a href="#动态规划入门题" class="headerlink" title="动态规划入门题"></a>动态规划入门题</h1><p>509.斐波那契数</p><p>70.爬楼梯</p><p>746.使用最小花费爬楼梯</p><h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509.斐波那契数"></a>509.斐波那契数</h2><h4 id="用常量"><a href="#用常量" class="headerlink" title="用常量"></a>用常量</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,b = <span class="hljs-number">1</span>,c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++i) {<br>            c = a + b;<br>            a = b;<br>            b = c;<br>        }<br>        <span class="hljs-keyword">return</span> c;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="用数组"><a href="#用数组" class="headerlink" title="用数组"></a>用数组</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++i) {<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><h4 id="用常量-1"><a href="#用常量-1" class="headerlink" title="用常量"></a>用常量</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>,b = <span class="hljs-number">2</span>,c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; ++i) {<br>            c = a + b;<br>            a = b;<br>            b = c;<br>        }<br>        <span class="hljs-keyword">return</span> c;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="用数组-1"><a href="#用数组-1" class="headerlink" title="用数组"></a>用数组</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; ++i) {<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> {<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cost.length];<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; cost.length; ++i) {<br>            dp[i] = Math.min(dp[i - <span class="hljs-number">1</span>],dp[i - <span class="hljs-number">2</span>]) + cost[i];<br>        }<br><br>        <span class="hljs-keyword">return</span> Math.min(dp[cost.length - <span class="hljs-number">1</span>],dp[cost.length - <span class="hljs-number">2</span>]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划入门题&quot;&gt;&lt;a href=&quot;#动态规划入门题&quot; class=&quot;headerlink&quot; title=&quot;动态规划入门题&quot;&gt;&lt;/a&gt;动态规划入门题&lt;/h1&gt;&lt;p&gt;509.斐波那契数&lt;/p&gt;
&lt;p&gt;70.爬楼梯&lt;/p&gt;
&lt;p&gt;746.使用最小花费爬楼梯&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="记忆化搜索" scheme="http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列经典题目</title>
    <link href="http://example.com/2023/01/01/%E7%AE%97%E6%B3%95/%E6%A0%88/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
    <id>http://example.com/2023/01/01/%E7%AE%97%E6%B3%95/%E6%A0%88/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/</id>
    <published>2023-01-01T09:31:40.673Z</published>
    <updated>2023-02-22T11:38:12.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈与队列经典题目"><a href="#栈与队列经典题目" class="headerlink" title="栈与队列经典题目"></a>栈与队列经典题目</h1><p>20.有效的括号</p><p>1047.删除字符串中的所有相邻重复项</p><p>150.逆波兰表达式求值</p><p>239.滑动窗口最大值</p><p>347.前 K 个高频元素</p><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> {<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; s.length();i ++){<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'('</span>){<br>                stack.push(<span class="hljs-string">')'</span>);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'{'</span>){<br>                stack.push(<span class="hljs-string">'}'</span>);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'['</span>){<br>                stack.push(<span class="hljs-string">']'</span>);<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.isEmpty() || stack.pop() != ch){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> stack.isEmpty();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="C:\Users\86173\Desktop\Snipaste_2023-02-22_13-26-29.png"></p><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h2><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String s)</span> {<br>        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">char</span>[] arr = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; arr.length;i ++){<br>            <span class="hljs-keyword">if</span>(stack.isEmpty() || stack.peek() != arr[i]){<br>                stack.push(arr[i]);<br>            } <span class="hljs-keyword">else</span> {<br>                stack.pop();<br>            }<br>        }<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) {<br>            str = stack.pop() + str;<br>        }<br>        <span class="hljs-keyword">return</span> str;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2022-12-31_12-16-07.png"></p><h4 id="StringBuilder模拟栈"><a href="#StringBuilder模拟栈" class="headerlink" title="StringBuilder模拟栈"></a>StringBuilder模拟栈</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); ++i) {<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            <span class="hljs-keyword">if</span> (top &gt;= <span class="hljs-number">0</span> &amp;&amp; str.charAt(top) == c) {<br>                str.deleteCharAt(top);<br>                top --;<br>            } <span class="hljs-keyword">else</span> {<br>                str.append(c);<br>                top ++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> str.toString();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2022-12-31_12-19-29.png"></p><h4 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(String S)</span> {<br>        <span class="hljs-type">char</span>[] s = S.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; S.length(); i++) {<br>            <span class="hljs-keyword">if</span> (top == -<span class="hljs-number">1</span> || s[top] != s[i]) {<br>                s[++top] = s[i];<br>            } <span class="hljs-keyword">else</span> {<br>                top--;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> String.valueOf(s, <span class="hljs-number">0</span>, top + <span class="hljs-number">1</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2022-12-31_12-20-23.png"></p><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">evalRPN</span><span class="hljs-params">(String[] tokens)</span> {<br>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; tokens.length;i ++){<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> tokens[i];<br>            <span class="hljs-keyword">if</span>(isNumber(s)){<br>                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br>                stack.push(j);<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> stack.pop();<br>                <span class="hljs-keyword">switch</span> (s) {<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">"+"</span>:<br>                        stack.push(num1 + num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">"-"</span>:<br>                        stack.push(num1 - num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">"*"</span>:<br>                        stack.push(num1 * num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">"/"</span>:<br>                        stack.push(num1 / num2);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> stack.pop();<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNumber</span><span class="hljs-params">(String token)</span> {<br>        <span class="hljs-keyword">return</span> !(<span class="hljs-string">"+"</span>.equals(token) || <span class="hljs-string">"-"</span>.equals(token) || <span class="hljs-string">"*"</span>.equals(token) || <span class="hljs-string">"/"</span>.equals(token));<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) {<br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums;<br>        <span class="hljs-comment">// 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序</span><br>        LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-comment">// 结果数组</span><br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length-k+<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 遍历nums数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length;i++){<br>            <span class="hljs-comment">// 保证从大到小 如果前面数小则需要依次弹出，直至满足要求</span><br>            <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;= nums[i]){<br>                queue.pollLast();<br>            }<br>            <span class="hljs-comment">// 添加当前值对应的数组下标</span><br>            queue.addLast(i);<br>            <span class="hljs-comment">// 判断当前队列中队首的值是否有效</span><br>            <span class="hljs-keyword">if</span>(queue.peek() &lt;= i-k){<br>                queue.poll();   <br>            } <br>            <span class="hljs-comment">// 当窗口长度为k时 保存当前窗口中最大值</span><br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span> &gt;= k){<br>                result[i+<span class="hljs-number">1</span>-k] = nums[queue.peek()];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-22_19-37-08.png"></p><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347.前 K 个高频元素"></a>347.前 K 个高频元素</h2><h4 id="基于大顶堆实现"><a href="#基于大顶堆实现" class="headerlink" title="基于大顶堆实现"></a>基于大顶堆实现</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) {<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums){<br>            map.put(num,map.getOrDefault(num,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>        }<br>        <br>        <span class="hljs-comment">//PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2)-&gt;pair2[1]-pair1[1]);</span><br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() {<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] m, <span class="hljs-type">int</span>[] n)</span> {<br>                <span class="hljs-keyword">return</span> n[<span class="hljs-number">1</span>] - m[<span class="hljs-number">1</span>];<br>            }<br>        });<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){<br>            pq.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]{entry.getKey(),entry.getValue()});<br>        }<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++){<br>            ans[i] = pq.poll()[<span class="hljs-number">0</span>];<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈与队列经典题目&quot;&gt;&lt;a href=&quot;#栈与队列经典题目&quot; class=&quot;headerlink&quot; title=&quot;栈与队列经典题目&quot;&gt;&lt;/a&gt;栈与队列经典题目&lt;/h1&gt;&lt;p&gt;20.有效的括号&lt;/p&gt;
&lt;p&gt;1047.删除字符串中的所有相邻重复项&lt;/p&gt;
&lt;p&gt;150</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="队列" scheme="http://example.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="堆(优先队列)" scheme="http://example.com/tags/%E5%A0%86-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="单调队列" scheme="http://example.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈与队列的互相实现</title>
    <link href="http://example.com/2022/12/28/%E7%AE%97%E6%B3%95/%E6%A0%88/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/12/28/%E7%AE%97%E6%B3%95/%E6%A0%88/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%92%E7%9B%B8%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-28T03:45:19.998Z</published>
    <updated>2022-12-28T03:47:30.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈与队列的互相实现"><a href="#栈与队列的互相实现" class="headerlink" title="栈与队列的互相实现"></a>栈与队列的互相实现</h1><p>232.用栈实现队列</p><p>225.用队列实现栈</p><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> {<br>    Stack&lt;Integer&gt; stk1 , stk2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyQueue</span><span class="hljs-params">()</span> {<br>        stk1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stk2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> {<br>        stk1.push(x);<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span>(stk2.isEmpty()){<br>            <span class="hljs-keyword">while</span>(!stk1.isEmpty()){<br>                stk2.push(stk1.pop());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> stk2.pop();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">if</span>(stk2.isEmpty()){<br>            <span class="hljs-keyword">while</span>(!stk1.isEmpty()){<br>                stk2.push(stk1.pop());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> stk2.peek();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> stk1.isEmpty() &amp;&amp; stk2.isEmpty();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> {<br><br>    Queue&lt;Integer&gt; queue1;<br>    Queue&lt;Integer&gt; queue2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack</span><span class="hljs-params">()</span> {<br>        queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> {<br>        queue2.offer(x);<br>        <span class="hljs-keyword">while</span> (!queue1.isEmpty()){<br>            queue2.offer(queue1.poll());<br>        }<br>        Queue&lt;Integer&gt; queueTemp;<br>        queueTemp = queue1;<br>        queue1 = queue2;<br>        queue2 = queueTemp; <br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> queue1.poll();<br>    }<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> queue1.peek();<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> {<br>        <span class="hljs-keyword">return</span> queue1.isEmpty();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;栈与队列的互相实现&quot;&gt;&lt;a href=&quot;#栈与队列的互相实现&quot; class=&quot;headerlink&quot; title=&quot;栈与队列的互相实现&quot;&gt;&lt;/a&gt;栈与队列的互相实现&lt;/h1&gt;&lt;p&gt;232.用栈实现队列&lt;/p&gt;
&lt;p&gt;225.用队列实现栈&lt;/p&gt;
&lt;h2 id=&quot;2</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="队列" scheme="http://example.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
    <category term="设计" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>棋盘问题</title>
    <link href="http://example.com/2022/12/27/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/12/27/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-27T03:40:35.859Z</published>
    <updated>2023-02-24T04:59:42.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h1><p>51.N 皇后</p><p>37.解数独</p><h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51.N 皇后"></a>51.N 皇后</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;String&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-type">char</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : arr) {<br>            Arrays.fill(c, <span class="hljs-string">'.'</span>);<br>        }<br>        dfs(n, <span class="hljs-number">0</span>, arr);<br>        <span class="hljs-keyword">return</span> list;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">char</span>[][] arr)</span> {<br>        <span class="hljs-keyword">if</span> (row == n) {<br>            list.add(Array2List(arr));<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; col &lt; n; ++col) {<br>            <span class="hljs-keyword">if</span> (isValid(row, col, n, arr)) {<br>                arr[row][col] = <span class="hljs-string">'Q'</span>;<br>                dfs(n, row+<span class="hljs-number">1</span>, arr);<br>                arr[row][col] = <span class="hljs-string">'.'</span>;<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">public</span> List <span class="hljs-title function_">Array2List</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chessboard)</span> {<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chessboard) {<br>            list.add(String.copyValueOf(c));<br>        }<br>        <span class="hljs-keyword">return</span> list;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span>[][] arr)</span> {<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;row; ++i) {<br>            <span class="hljs-keyword">if</span> (arr[i][col] == <span class="hljs-string">'Q'</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=row-<span class="hljs-number">1</span>, j=col-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&gt;=<span class="hljs-number">0</span>; i--, j--) {<br>            <span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">'Q'</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=row-<span class="hljs-number">1</span>, j=col+<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;=n-<span class="hljs-number">1</span>; i--, j++) {<br>            <span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">'Q'</span>) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-24_12-57-13.png"></p><p><img src="/image/Snipaste_2023-02-24_12-58-37.png"></p><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h2><p>该方法时间复杂度较高</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solveSudoku</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span> {<br>        solveSudokuHelper(board);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">solveSudokuHelper</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board)</span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++){<br>                <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">'.'</span>){<br>                    <span class="hljs-keyword">continue</span>;<br>                }<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-string">'1'</span>; k &lt;= <span class="hljs-string">'9'</span>; k++){ <br>                    <span class="hljs-keyword">if</span> (isValidSudoku(i, j, k, board)){<br>                        board[i][j] = k;<br>                        <span class="hljs-keyword">if</span> (solveSudokuHelper(board)){<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                        }<br>                        board[i][j] = <span class="hljs-string">'.'</span>;<br>                    }<br>                }<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidSudoku</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span> val, <span class="hljs-type">char</span>[][] board)</span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++){<br>            <span class="hljs-keyword">if</span> (board[row][i] == val){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++){<br>            <span class="hljs-keyword">if</span> (board[j][col] == val){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">startRow</span> <span class="hljs-operator">=</span> (row / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">startCol</span> <span class="hljs-operator">=</span> (col / <span class="hljs-number">3</span>) * <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startRow; i &lt; startRow + <span class="hljs-number">3</span>; i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> startCol; j &lt; startCol + <span class="hljs-number">3</span>; j++){<br>                <span class="hljs-keyword">if</span> (board[i][j] == val){<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;棋盘问题&quot;&gt;&lt;a href=&quot;#棋盘问题&quot; class=&quot;headerlink&quot; title=&quot;棋盘问题&quot;&gt;&lt;/a&gt;棋盘问题&lt;/h1&gt;&lt;p&gt;51.N 皇后&lt;/p&gt;
&lt;p&gt;37.解数独&lt;/p&gt;
&lt;h2 id=&quot;51-N-皇后&quot;&gt;&lt;a href=&quot;#51-N-皇后&quot; </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>全排列问题</title>
    <link href="http://example.com/2022/12/26/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/12/26/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-26T03:07:21.564Z</published>
    <updated>2023-02-01T09:12:14.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h1><p>46.全排列</p><p>47.全排列 II</p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        dfs(nums);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) {<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) {<br>            <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.add(nums[i]);<br>            dfs(nums);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h2><p>去重必须先将数组排序</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">boolean</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        Arrays.sort(nums);<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[nums.length];<br>        dfs(nums);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-keyword">if</span> (path.size() == nums.length) {<br>            result.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) {<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.add(nums[i]);<br>            dfs(nums);<br>            path.removeLast();<br>            used[i] = <span class="hljs-literal">false</span>;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;全排列问题&quot;&gt;&lt;a href=&quot;#全排列问题&quot; class=&quot;headerlink&quot; title=&quot;全排列问题&quot;&gt;&lt;/a&gt;全排列问题&lt;/h1&gt;&lt;p&gt;46.全排列&lt;/p&gt;
&lt;p&gt;47.全排列 II&lt;/p&gt;
&lt;h2 id=&quot;46-全排列&quot;&gt;&lt;a href=&quot;#46-全</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>子集问题</title>
    <link href="http://example.com/2022/12/26/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/12/26/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-26T02:29:31.773Z</published>
    <updated>2022-12-26T02:31:27.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><p>78.子集</p><p>90.子集 II</p><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        dfs(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> lists;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> startIndex)</span> {<br>        lists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; ++i) {<br>            list.add(nums[i]);<br>            dfs(nums,i + <span class="hljs-number">1</span>);<br>            list.removeLast();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90.子集 II"></a>90.子集 II</h2><p><em><strong>1.用used[]排除重复项必须先对数组进行排序</strong></em></p><p><em><strong>2.是判断used[i-1]而不是used[i]</strong></em></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        Arrays.sort(nums);<br>        dfs(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> lists;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> startIndex)</span> {<br>        lists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; ++i) {<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            path.add(nums[i]);<br>            used[i] = <span class="hljs-number">1</span>;<br>            dfs(nums,i + <span class="hljs-number">1</span>);<br>            used[i] = <span class="hljs-number">0</span>;<br>            path.removeLast();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;子集问题&quot;&gt;&lt;a href=&quot;#子集问题&quot; class=&quot;headerlink&quot; title=&quot;子集问题&quot;&gt;&lt;/a&gt;子集问题&lt;/h1&gt;&lt;p&gt;78.子集&lt;/p&gt;
&lt;p&gt;90.子集 II&lt;/p&gt;
&lt;h2 id=&quot;78-子集&quot;&gt;&lt;a href=&quot;#78-子集&quot; clas</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>分割问题</title>
    <link href="http://example.com/2022/12/24/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/12/24/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-24T03:31:00.664Z</published>
    <updated>2023-02-24T01:22:26.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h1><p>131.分割回文串</p><p>93.复原IP地址</p><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;String&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> {<br>        backTracking(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> lists;<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> startIndex)</span> {<br>        <span class="hljs-keyword">if</span> (startIndex &gt;= s.length()) {<br>            lists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(deque));<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; s.length(); i++) {<br>            <span class="hljs-keyword">if</span> (isPalindrome(s, startIndex, i)) {<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> s.substring(startIndex, i + <span class="hljs-number">1</span>);<br>                deque.addLast(str);<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            backTracking(s, i + <span class="hljs-number">1</span>);<br>            deque.removeLast();<br>        }<br>    }<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> end)</span> {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex, j = end; i &lt; j; i++, j--) {<br>            <span class="hljs-keyword">if</span> (s.charAt(i) != s.charAt(j)) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-23_09-25-55.png"></p><p><img src="/image/Snipaste_2023-02-23_09-27-01.png"></p><p>验证回文串的时候，每一次都得使用「双指针」的方式验证子串是否是回文子串。利用「力扣」第 5 题：最长回文子串 的思路，可以先用动态规划把结果算出来，这样就可以以 O(1) 的时间复杂度直接得到一个子串是否是回文。</p><h3 id="回溯的优化（使用动态规划得到所有子串是否是回文"><a href="#回溯的优化（使用动态规划得到所有子串是否是回文" class="headerlink" title="回溯的优化（使用动态规划得到所有子串是否是回文)"></a>回溯的优化（使用动态规划得到所有子串是否是回文)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> res;<br>        }<br><br>        <span class="hljs-type">char</span>[] charArray = s.toCharArray();<br>        <span class="hljs-comment">// 预处理</span><br>        <span class="hljs-comment">// 状态：dp[i][j] 表示 s[i][j] 是否是回文</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len][len];<br>        <span class="hljs-comment">// 状态转移方程：在 s[i] == s[j] 的时候，dp[i][j] 参考 dp[i + 1][j - 1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; len; right++) {<br>            <span class="hljs-comment">// 注意：left &lt;= right 取等号表示 1 个字符的时候也需要判断</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; left &lt;= right; left++) {<br>                <span class="hljs-keyword">if</span> (charArray[left] == charArray[right] &amp;&amp; (right - left &lt;= <span class="hljs-number">2</span> || dp[left + <span class="hljs-number">1</span>][right - <span class="hljs-number">1</span>])) {<br>                    dp[left][right] = <span class="hljs-literal">true</span>;<br>                }<br>            }<br>        }<br><br>        Deque&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        dfs(s, <span class="hljs-number">0</span>, len, dp, stack, res);<br>        <span class="hljs-keyword">return</span> res;<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> len, <span class="hljs-type">boolean</span>[][] dp, Deque&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; res)</span> {<br>        <span class="hljs-keyword">if</span> (index == len) {<br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; len; i++) {<br>            <span class="hljs-keyword">if</span> (dp[index][i]) {<br>                path.addLast(s.substring(index, i + <span class="hljs-number">1</span>));<br>                dfs(s, i + <span class="hljs-number">1</span>, len, dp, path, res);<br>                path.removeLast();<br>            }<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h2><p>1、一开始，字符串的长度小于 4 或者大于 12 ，一定不能拼凑出合法的 ip 地址（这一点可以一般化到中间结点的判断中，以产生剪枝行为）；</p><p>2、每一个结点可以选择截取的方法只有 3 种：截 1 位、截 2 位、截 3 位，因此每一个结点可以生长出的分支最多只有 3 条分支；</p><p>根据截取出来的字符串判断是否是合理的 ip 段，这里写法比较多，可以先截取，再转换成 int ，再判断。我采用的做法是先转成 int，是合法的 ip 段数值以后，再截取。</p><p>3、由于 ip 段最多就 4 个段，因此这棵三叉树最多 4 层，这个条件作为递归终止条件之一；</p><p><img src="/image/Snipaste_2023-02-23_13-08-23.png"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;String&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">12</span> || len &lt; <span class="hljs-number">4</span>) {<br>            <span class="hljs-keyword">return</span> res;<br>        }<br><br>        dfs(s, len, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> residue)</span> {<br>        <span class="hljs-keyword">if</span> (begin == len) {<br>            <span class="hljs-keyword">if</span> (residue == <span class="hljs-number">0</span>) {<br>                res.add(String.join(<span class="hljs-string">"."</span>, path));<br>            }<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begin; i &lt; begin + <span class="hljs-number">3</span>; i++) {<br>            <span class="hljs-keyword">if</span> (i &gt;= len) {<br>                <span class="hljs-keyword">break</span>;<br>            }<br><br>            <span class="hljs-keyword">if</span> (residue * <span class="hljs-number">3</span> &lt; len - i) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br><br>            <span class="hljs-keyword">if</span> (judgeIpSegment(s, begin, i)) {<br>                <span class="hljs-type">String</span> <span class="hljs-variable">currentIpSegment</span> <span class="hljs-operator">=</span> s.substring(begin, i + <span class="hljs-number">1</span>);<br>                path.addLast(currentIpSegment);<br><br>                dfs(s, len, i + <span class="hljs-number">1</span>, residue - <span class="hljs-number">1</span>);<br>                path.removeLast();<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judgeIpSegment</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> right - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">1</span> &amp;&amp; s.charAt(left) == <span class="hljs-string">'0'</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) {<br>            res = res * <span class="hljs-number">10</span> + s.charAt(left) - <span class="hljs-string">'0'</span>;<br>            left++;<br>        }<br><br>        <span class="hljs-keyword">return</span> res &gt;= <span class="hljs-number">0</span> &amp;&amp; res &lt;= <span class="hljs-number">255</span>;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-24_09-14-11.png"></p><p><img src="/image/Snipaste_2023-02-24_09-20-11.png"></p><p><img src="/image/Snipaste_2023-02-24_09-21-12.png"></p><p>## 参考</p><p>- [1] <a href="https://leetcode.cn/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/">liweiwei1419</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分割问题&quot;&gt;&lt;a href=&quot;#分割问题&quot; class=&quot;headerlink&quot; title=&quot;分割问题&quot;&gt;&lt;/a&gt;分割问题&lt;/h1&gt;&lt;p&gt;131.分割回文串&lt;/p&gt;
&lt;p&gt;93.复原IP地址&lt;/p&gt;
&lt;h2 id=&quot;131-分割回文串&quot;&gt;&lt;a href=&quot;#13</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>组合问题</title>
    <link href="http://example.com/2022/12/23/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/12/23/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/</id>
    <published>2022-12-23T03:27:56.784Z</published>
    <updated>2023-02-01T08:24:20.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h1><p>77.组合</p><p>216.组合总和 III</p><p>39.组合总和</p><p>40.组合总和 II</p><p>17.电话号码的字母组合</p><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h2><p>例如：n = 6 ，k = 4。</p><p>path.size() == 1 的时候，接下来要选择 3 个数，搜索起点最大是 4，最后一个被选的组合是 [4, 5, 6]；<br>path.size() == 2 的时候，接下来要选择 2 个数，搜索起点最大是 5，最后一个被选的组合是 [5, 6]；<br>path.size() == 3 的时候，接下来要选择 1 个数，搜索起点最大是 6，最后一个被选的组合是 [6]；</p><p>再如：n = 15 ，k = 4。<br>path.size() == 1 的时候，接下来要选择 3 个数，搜索起点最大是 13，最后一个被选的是 [13, 14, 15]；<br>path.size() == 2 的时候，接下来要选择 2 个数，搜索起点最大是 14，最后一个被选的是 [14, 15]；<br>path.size() == 3 的时候，接下来要选择 1 个数，搜索起点最大是 15，最后一个被选的是 [15]；</p><p>搜索起点的上界 + 接下来要选择的元素个数 - 1 = n</p><p>其中，接下来要选择的元素个数 <code>= k - path.size()</code>，整理得到：</p><p>搜索起点的上界 = n - (k - path.size()) + 1</p><p>所以，我们的剪枝过程就是：把 <code>i &lt;= n</code> 改成 <code>i &lt;= n - (k - path.size()) + 1</code> </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> {<br>        dfs(n,k,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> lists;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> indexStart)</span> {<br>        <span class="hljs-keyword">if</span> (path.size() == k) {<br>            lists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexStart; i &lt;= n - (k - path.size()) + <span class="hljs-number">1</span>; ++i) {<br>            path.add(i);<br>            dfs(n,k,i + <span class="hljs-number">1</span>);<br>            path.removeLast();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216.组合总和 III"></a>216.组合总和 III</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum3</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span> {<br>        dfs(k,n,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> lists;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> sum)</span> {<br>        <span class="hljs-keyword">if</span> (path.size() == k) {<br>            <span class="hljs-keyword">if</span> (sum == n) {<br>                lists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            }<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= <span class="hljs-number">9</span>; ++i) {<br>            path.add(i);<br>            sum += i;<br>            dfs(k,n,i + <span class="hljs-number">1</span>,sum);<br>            sum -= i;<br>            path.removeLast();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h2><p>数组排序进行剪枝优化</p><p>如果没有if (sum + arr[i] &gt; target) break,会导致栈溢出</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> {<br>        Arrays.sort(candidates);<br>        dfs(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> lists;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr,<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> index)</span> {<br>        <span class="hljs-keyword">if</span>(sum == target) {<br>            lists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; arr.length; ++i) {<br>            <span class="hljs-keyword">if</span> (sum + arr[i] &gt; target) <span class="hljs-keyword">break</span>;<br>            path.add(arr[i]);<br>            sum += arr[i];<br>            dfs(arr,target,sum,i);<br>            sum -= arr[i];<br>            path.removeLast();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40.组合总和 II"></a>40.组合总和 II</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span>[] used;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> {<br>        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[candidates.length];<br>        Arrays.sort(candidates);<br>        dfs(candidates,target,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> lists;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> {<br>        <span class="hljs-keyword">if</span> (sum == target) {<br>            lists.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; arr.length; ++i) {<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; arr[i] == arr[i - <span class="hljs-number">1</span>] &amp;&amp; used[i-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (arr[i] + sum &gt; target) <span class="hljs-keyword">break</span>; <br>            path.add(arr[i]);<br>            used[i] = <span class="hljs-number">1</span>;<br>            sum += arr[i];<br>            dfs(arr,target,sum,i + <span class="hljs-number">1</span>);<br>            sum -= arr[i];<br>            used[i] = <span class="hljs-number">0</span>;<br>            path.removeLast();<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h2><p>StringBuilder temp = new StringBuilder()</p><p>temp.deleteCharAt()</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;String&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(String digits)</span> {<br>        <span class="hljs-keyword">if</span> (digits == <span class="hljs-literal">null</span> || digits.length() == <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> lists;<br>        }<br>        String[] sArr = {<span class="hljs-string">""</span>,<span class="hljs-string">""</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"def"</span>,<span class="hljs-string">"ghi"</span>,<span class="hljs-string">"jkl"</span>,<span class="hljs-string">"mno"</span>,<span class="hljs-string">"pqrs"</span>,<span class="hljs-string">"tuv"</span>,<span class="hljs-string">"wxyz"</span>};<br>        dfs(digits,sArr,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> lists;<br>    }<br><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String digits,String[] sArr,<span class="hljs-type">int</span> num)</span> {<br>        <span class="hljs-keyword">if</span>(digits.length() == num) {<br>            lists.add(temp.toString());<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sArr[digits.charAt(num) - <span class="hljs-string">'0'</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i &lt; str.length(); ++i) {<br>            temp.append(str.charAt(i));<br>            dfs(digits, sArr, num + <span class="hljs-number">1</span>);<br>            temp.deleteCharAt(temp.length() - <span class="hljs-number">1</span>);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><img src="/image/Snipaste_2023-02-01_15-53-32.png" alt="Snipaste_2023-02-01_15-53-32"></p><p><img src="/image/Snipaste_2023-02-01_15-59-09.png" alt="Snipaste_2023-02-01_15-59-09"></p><p><img src="/image/Snipaste_2023-02-01_16-01-55.png" alt="Snipaste_2023-02-01_16-01-55"></p><p><img src="/image/Snipaste_2023-02-01_16-04-56.png" alt="Snipaste_2023-02-01_16-04-56"></p><p><img src="/image/Snipaste_2023-02-01_16-19-12.png" alt="Snipaste_2023-02-01_16-19-12"></p><p>## 参考</p><p>- [1] <a href="https://leetcode.cn/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/">liweiwei1419</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组合问题&quot;&gt;&lt;a href=&quot;#组合问题&quot; class=&quot;headerlink&quot; title=&quot;组合问题&quot;&gt;&lt;/a&gt;组合问题&lt;/h1&gt;&lt;p&gt;77.组合&lt;/p&gt;
&lt;p&gt;216.组合总和 III&lt;/p&gt;
&lt;p&gt;39.组合总和&lt;/p&gt;
&lt;p&gt;40.组合总和 II&lt;/p&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的修改与构造</title>
    <link href="http://example.com/2022/12/22/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    <id>http://example.com/2022/12/22/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0/</id>
    <published>2022-12-22T02:32:25.978Z</published>
    <updated>2023-02-21T08:12:48.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的修改与构造"><a href="#二叉搜索树的修改与构造" class="headerlink" title="二叉搜索树的修改与构造"></a>二叉搜索树的修改与构造</h1><p>701.二叉搜索树中的插入操作</p><p>450.删除二叉搜索树中的节点</p><p>669.修剪二叉搜索树</p><p>108.将有序数组转换为二叉搜索树</p><h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> {<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>        }<br>        <span class="hljs-keyword">if</span>(root.val &lt; val) {<br>            root.right = insertIntoBST(root.right,val);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; val) {<br>            root.left = insertIntoBST(root.left,val);<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> key)</span> {<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root.val &lt; key) {<br>            root.right = deleteNode(root.right,key);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; key) {<br>            root.left = deleteNode(root.left,key);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.right;<br>            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.left;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">currNode</span> <span class="hljs-operator">=</span> root.right;<br>            <span class="hljs-keyword">while</span> (currNode.left != <span class="hljs-literal">null</span>) {<br>                currNode = currNode.left;<br>            }<br>            currNode.left = root.left;<br>            root = root.right;<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-21_15-39-07.png"></p><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669.修剪二叉搜索树"></a>669.修剪二叉搜索树</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">trimBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> {<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(root.val &lt; low) {<br>            <span class="hljs-keyword">return</span> trimBST(root.right,low,high);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &gt; high) {<br>            <span class="hljs-keyword">return</span> trimBST(root.left,low,high);<br>        }<br><br>        root.left = trimBST(root.left,low,high);<br>        root.right = trimBST(root.right,low,high);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-21_16-12-12.png"></p><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h2><p>数组构造二叉树，构成平衡树是自然而然的事情，因为大家默认都是从数组中间位置取值作为节点元素，一般不会随机取。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-keyword">return</span> dfs(nums,<span class="hljs-number">0</span>,nums.length - <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> {<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>        root.left = dfs(nums,left,mid - <span class="hljs-number">1</span>);<br>        root.right = dfs(nums,mid + <span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉搜索树的修改与构造&quot;&gt;&lt;a href=&quot;#二叉搜索树的修改与构造&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的修改与构造&quot;&gt;&lt;/a&gt;二叉搜索树的修改与构造&lt;/h1&gt;&lt;p&gt;701.二叉搜索树中的插入操作&lt;/p&gt;
&lt;p&gt;450.删除二叉搜索树</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="分治" scheme="http://example.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的属性</title>
    <link href="http://example.com/2022/12/20/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://example.com/2022/12/20/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7/</id>
    <published>2022-12-20T03:10:37.791Z</published>
    <updated>2023-02-21T07:39:49.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的属性"><a href="#二叉搜索树的属性" class="headerlink" title="二叉搜索树的属性"></a>二叉搜索树的属性</h1><p>700.二叉搜索树中的搜索</p><p>98.验证二叉搜索树</p><p>530.二叉搜索树的最小绝对差</p><p>501.二叉搜索树中的众数</p><p>538.把二叉搜索树转换为累加树</p><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h2><h4 id="递归，普通二叉树"><a href="#递归，普通二叉树" class="headerlink" title="递归，普通二叉树"></a>递归，普通二叉树</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> {<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root.val == val) {<br>            <span class="hljs-keyword">return</span> root;<br>        }<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> searchBST(root.left, val);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span>) {<br>            <span class="hljs-keyword">return</span> left;<br>        }<br>        <span class="hljs-keyword">return</span> searchBST(root.right, val);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="递归，利用二叉搜索树特点，优化"><a href="#递归，利用二叉搜索树特点，优化" class="headerlink" title="递归，利用二叉搜索树特点，优化"></a>递归，利用二叉搜索树特点，优化</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">searchBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> val)</span> {<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || root.val == val) {<br>            <span class="hljs-keyword">return</span> root;<br>        }<br>        <span class="hljs-keyword">if</span> (val &lt; root.val) {<br>            <span class="hljs-keyword">return</span> searchBST(root.left, val);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">return</span> searchBST(root.right, val);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-17_10-18-22.png" alt="Snipaste_2023-02-17_10-18-22"></p><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-type">long</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> {<br>        <span class="hljs-keyword">return</span> inorder(root);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode node)</span> {<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> inorder(node.left);<br>        <span class="hljs-keyword">if</span>(node.val &lt;= pre) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = node.val;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> inorder(node.right);<br>        <span class="hljs-keyword">return</span> l &amp;&amp; r;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-21_14-47-26.png"></p><h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-type">int</span> pre;<br>    <span class="hljs-type">int</span> ans;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumDifference</span><span class="hljs-params">(TreeNode root)</span> {<br>        pre = -<span class="hljs-number">1</span>;<br>        ans = Integer.MAX_VALUE;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> {<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(root.left);<br>        <span class="hljs-keyword">if</span>(pre == -<span class="hljs-number">1</span>) {<br>            pre = root.val;<br>        } <span class="hljs-keyword">else</span> {<br>            ans = Math.min(ans,root.val - pre);<br>            pre = root.val;<br>        }<br>        dfs(root.right);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="/image/Snipaste_2023-02-21_14-32-51.png" alt="Snipaste_2023-02-21_14-32-51"></p><p><img src="/image/Snipaste_2023-02-21_14-39-16.png" alt="Snipaste_2023-02-21_14-39-16"></p><h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    List&lt;Integer&gt; answer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    <span class="hljs-type">int</span> base, count, maxCount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findMode(TreeNode root) {<br>        dfs(root);<br>        <span class="hljs-type">int</span>[] mode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[answer.size()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; answer.size(); ++i) {<br>            mode[i] = answer.get(i);<br>        }<br>        <span class="hljs-keyword">return</span> mode;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode o)</span> {<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        dfs(o.left);<br>        update(o.val);<br>        dfs(o.right);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> {<br>        <span class="hljs-keyword">if</span> (x == base) {<br>            ++count;<br>        } <span class="hljs-keyword">else</span> {<br>            count = <span class="hljs-number">1</span>;<br>            base = x;<br>        }<br>        <span class="hljs-keyword">if</span> (count == maxCount) {<br>            answer.add(base);<br>        }<br>        <span class="hljs-keyword">if</span> (count &gt; maxCount) {<br>            maxCount = count;<br>            answer.clear();<br>            answer.add(base);<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> {<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        root.right = convertBST(root.right);<br>        sum += root.val;<br>        root.val = sum;<br>        root.left = convertBST(root.left);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">convertBST</span><span class="hljs-params">(TreeNode root)</span> {<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> {<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>        dfs(root.right);<br>        sum += root.val;<br>        root.val = sum;<br>        dfs(root.left);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉搜索树的属性&quot;&gt;&lt;a href=&quot;#二叉搜索树的属性&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的属性&quot;&gt;&lt;/a&gt;二叉搜索树的属性&lt;/h1&gt;&lt;p&gt;700.二叉搜索树中的搜索&lt;/p&gt;
&lt;p&gt;98.验证二叉搜索树&lt;/p&gt;
&lt;p&gt;530.二叉搜</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="广度优先搜索" scheme="http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
</feed>
